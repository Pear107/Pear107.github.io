<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A + B 问题</title>
    <url>/2023/03/31/A-B-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    std::cout &lt;&lt; a + b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LibreOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>ASCII 表</title>
    <url>/2023/04/18/ASCII-%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="ASCII-表"><a href="#ASCII-表" class="headerlink" title="ASCII 表"></a>ASCII 表</h2><table>
<thead>
<tr>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td>40</td>
<td>(</td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td>41</td>
<td>)</td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>/</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td>91</td>
<td>[</td>
<td>123</td>
<td>{</td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>/</td>
<td>124</td>
<td>|</td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>=</td>
<td>93</td>
<td>]</td>
<td>125</td>
<td>}</td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>`</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody></table>
<h2 id="特殊字符解释"><a href="#特殊字符解释" class="headerlink" title="特殊字符解释"></a>特殊字符解释</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>NUL</td>
<td>空</td>
<td>VT</td>
<td>垂直制表</td>
<td>SYN</td>
<td>空转同步</td>
</tr>
<tr>
<td>STX</td>
<td>正文开始</td>
<td>CR</td>
<td>回车</td>
<td>CAN</td>
<td>作废</td>
</tr>
<tr>
<td>ETX</td>
<td>正文结束</td>
<td>SO</td>
<td>移位输出</td>
<td>EM</td>
<td>纸尽</td>
</tr>
<tr>
<td>EOY</td>
<td>传输结束</td>
<td>SI</td>
<td>移位输入</td>
<td>SUB</td>
<td>换置</td>
</tr>
<tr>
<td>ENQ</td>
<td>询问字符</td>
<td>DLE</td>
<td>空格</td>
<td>ESC</td>
<td>换码</td>
</tr>
<tr>
<td>ACK</td>
<td>承认</td>
<td>DC1</td>
<td>设备控制1</td>
<td>FS</td>
<td>文字分隔符</td>
</tr>
<tr>
<td>BEL</td>
<td>报警</td>
<td>DC2</td>
<td>设备控制2</td>
<td>GS</td>
<td>组分隔符</td>
</tr>
<tr>
<td>BS</td>
<td>退一格</td>
<td>DC3</td>
<td>设备控制3</td>
<td>RS</td>
<td>记录分隔符</td>
</tr>
<tr>
<td>HT</td>
<td>横向列表</td>
<td>DC4</td>
<td>设备控制4</td>
<td>US</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>LF</td>
<td>换行</td>
<td>NAK</td>
<td>否定</td>
<td>DEL</td>
<td>删除</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ char* 和 string</title>
    <url>/2023/03/25/C-char-%E5%92%8C-string/</url>
    <content><![CDATA[<p>char* 和 string 都是 C++ 中表示字符串的数据类型，但它们有很大的区别。</p>
<p>char* 是一种字符指针类型，它指向一块内存区域，这个内存区域通常用于存储一系列字符。char* 类型的字符串以空字符 ‘\0’ 结尾，被称为以空字符为结尾的字符串或 C 语言风格的字符串。char* 类型的字符串可以使用 C 语言库函数，如 strlen()、strcpy()、strcat()、strcmp() 等来进行操作。char* 类型的字符串需要手动管理内存，包括分配和释放等。</p>
<p>string 是 C++ 标准库提供的一种字符串类型，它是一个类，封装了一个字符数组和一些与字符串相关的操作函数。string 类型的字符串不需要以空字符结尾，因为它内部使用了长度信息来管理字符串。string 类型的字符串可以使用类中提供的成员函数，如 size()、append()、substr()、find() 等来进行操作。string 类型的字符串由 C++ 标准库自动管理内存，不需要手动分配和释放。</p>
<p>总的来说，char* 类型的字符串是一种较底层的字符串表示方式，需要手动管理内存，而 string 类型的字符串则是一种高层次的表示方式，由 C++ 标准库自动管理内存，提供了更多的操作函数和安全性。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ map</title>
    <url>/2023/03/31/C-map/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在 C++ 中，map 是一种关联容器，它提供了一种映射关系，将一组键值对映射到对应的值上。map 内部实现了一种红黑树数据结构，能够高效地实现键值对的查找、插入和删除等操作。map 中的每个元素都是一个键值对，其中键是唯一的，值可以重复。map 中的元素按照键的比较顺序进行有序排列，默认情况下按照键的升序排列。map 支持随机访问和迭代访问，可以使用键访问值，也可以使用迭代器访问键值对。需要注意的是，map 内部使用红黑树数据结构实现，因此在插入或删除元素时可能会涉及到元素移动和内存重新分配，需要注意效率问题。在使用 map 时，应该尽量避免频繁的插入和删除操作，以提高性能。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>map 的常用操作包括：</p>
<ul>
<li>insert：插入一个键值对。</li>
<li>erase：删除一个键值对。</li>
<li>find：查找指定键的位置。</li>
<li>size：返回 map 中键值对的数量。</li>
<li>empty：判断 map 是否为空。</li>
<li>clear：清空 map 中的所有键值对。</li>
</ul>
<p>map 还提供了一些高级操作，如 lower_bound、upper_bound、equal_range 等，用于在有序的键值对序列中查找或操作元素。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ new 和 malloc</title>
    <url>/2023/03/26/C-new-%E5%92%8C-malloc/</url>
    <content><![CDATA[<p>new和malloc都是用于动态分配内存的函数，但它们有以下不同点：</p>
<ul>
<li>用法：new是C++中的关键字，malloc是C语言中的函数。</li>
<li>参数：new使用类名或类型名作为参数，malloc 使用要分配的内存大小作为参数。</li>
<li>返回值：new返回类型的指针，malloc 返回 void 类型的指针。</li>
<li>内存分配：new分配的内存包括类型信息，malloc 分配的内存只是一块连续的内存空间。</li>
<li>构造函数和析构函数：使用 new 分配的内存将自动调用对象的构造函数，使用 delete  释放内存时将自动调用析构函数。使用malloc 分配的内存不会自动调用构造函数和析构函数。</li>
<li>内存分配失败处理：new 抛出 std::bad_alloc 异常，malloc 返回空指针。</li>
</ul>
<p>总之，new 和 malloc 都可以用于动态分配内存，但 new 更适合用于 C++ 程序中，因为它可以自动调用构造函数和析构函数，而 malloc 更适合用于 C 程序中。在使用时应根据实际情况选择。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ new 重写</title>
    <url>/2023/03/26/C-new-%E9%87%8D%E5%86%99/</url>
    <content><![CDATA[<p>C++ 中的 new 运算符是一个高级别的内存管理函数，它用于在运行时分配内存。new 运算符的实现通常依赖于 malloc 函数，因为它们都用于分配内存。下面是一个简单的 C++ new 运算符的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个实现中，new运算符被重载为一个函数，它接受一个 size_t 类型的参数，表示要分配的内存大小。该函数使用 malloc 函数分配内存，并检查返回指针是否为 NULL。如果内存分配失败，它将抛出 std::bad_alloc 异常。否则，它将返回一个指向分配的内存块的指针。</p>
<p>需要注意的是，C++ 的 new 运算符可以被重载，因此它的实现可能会因不同的实现而异。此外，C++ new 运算符还支持其他的重载形式，例如带有定位 new 的版本，它允许在指定地址上分配内存。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ nullptr 和 NULL</title>
    <url>/2023/03/25/C-nullptr-%E5%92%8C-NULL/</url>
    <content><![CDATA[<p>nullptr 和 NULL 都是C++中表示空指针的常量，它们的含义和使用方式略有不同。</p>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><ul>
<li>nullptr 是C++11中引入的关键字，用于表示空指针。它的定义如下：<code>nullptr_t nullptr = 0</code></li>
<li>nullptr 的类型是 nullptr_t，它是一种特殊的空指针类型，可以隐式转换为任意类型的空指针。在C++11之前，通常使用0或者NULL来表示空指针，但由于0或者NULL可以转换为整型，可能会引起一些问题，因此C++11引入了 nullptr 关键字来避免这种问题。</li>
</ul>
<h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><ul>
<li>NULL 是 C++ 中表示空指针的宏定义，在 C++11 之前广泛使用。它的定义如下：<code>#define NULL 0</code></li>
<li>NULL 实际上是一个整型常量 0，可以被隐式转换为任意类型的空指针。但由于 0 也可以被隐式转换为整型，可能会出现一些问题，因此在 C++11 中推荐使用 nullptr 代替 NULL。</li>
</ul>
<p>总的来说，nullptr是一种更加安全和明确的表示空指针的方式，建议在C++11及以上的版本中使用nullptr代替NULL。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ static</title>
    <url>/2023/03/25/C-static/</url>
    <content><![CDATA[<p>在C++中，static 关键字可以用于变量、函数和类的成员，其作用如下：</p>
<ul>
<li>用于变量：static 关键字可以将变量声明为静态变量，即该变量在程序运行期间只被初始化一次，不会被销毁，生命周期与程序相同。同时，静态变量的作用域只在声明它的文件内部。</li>
<li>用于函数：static 关键字可以将函数声明为静态函数，即该函数只能在声明它的文件内部调用，不能被其他文件调用。静态函数可以减少函数名的污染，提高程序的安全性。</li>
<li>用于类的成员：static 关键字可以将类的成员声明为静态成员，即该成员被所有类的对象共享，不依赖于任何对象而存在，可以直接通过类名访问。静态成员可以用于记录类的某些全局信息，或者用于实现单例模式等。</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; count++; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    MyClass obj2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; MyClass::count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序定义了一个 MyClass 类，其中包含了一个静态成员 count。在程序运行期间，每创建一个 MyClass 对象，count 的值就会自增1。最后输出 count 的值，即为对象的总数。由于 count 是静态成员，可以直接通过类名访问。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ typeof</title>
    <url>/2023/04/18/C-typeof/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>C++ vector</title>
    <url>/2023/03/26/C-vector/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在 C++ 中，vector 是一种动态数组容器，它能够自动扩展和收缩内部存储空间，使得用户能够创建一个可变长度的数组，同时还提供了丰富的数组操作方法。vector 内部实现了一个动态数组，能够随着元素的添加和删除自动调整数组的大小。vector 支持随机访问和迭代访问，可以像数组一样使用下标访问元素，也可以使用迭代器访问元素。vector 的底层实现是使用连续的内存空间存储元素，因此在插入或删除元素时可能会涉及到元素移动和内存重新分配，需要注意效率问题。在使用 vector 时，应该尽量避免频繁的插入和删除操作，以提高性能。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>vector 的常用操作包括：</p>
<ul>
<li>push_back：在 vector 的末尾添加一个元素。</li>
<li>pop_back：从 vector 的末尾删除一个元素。</li>
<li>size：返回 vector 中元素的数量。</li>
<li>empty：判断 vector 是否为空。</li>
<li>clear：清空 vector 中的所有元素。</li>
<li>insert：在指定位置插入一个元素。</li>
<li>erase：删除指定位置或指定范围内的一个或多个元素。</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>在C ++中，当使用向量时，可能会出现一些异常情况，包括：</p>
<ul>
<li>超出范围：使用 at() 或 [] 访问的元素索引超出向量范围时，会抛出 std::out_of_range 异常。</li>
<li>插入和删除时的迭代器失效：当向量中的元素被插入或删除时，迭代器可能会失效。尝试使用失效的迭代器可能会导致未定义的行为。</li>
<li>内存不足：当向量需要动态分配内存时，如果内存不足，则会抛出 std::bad_alloc 异常。</li>
<li>迭代器越界：当使用 end() 迭代器之后的迭代器进行访问时，会导致未定义的行为。</li>
<li>不支持的操作：当向量执行不支持的操作时，例如尝试对 const 向量进行插入或删除操作，会抛出 std::logic_error 异常。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 内存分区</title>
    <url>/2023/03/25/C-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><p>C++ 内存分区模型通常是由以下几个部分组成：</p>
<ul>
<li>栈区（Stack）：存放函数的参数、返回值和局部变量等。栈区内存由编译器自动分配和释放，具有自动管理的特点。</li>
<li>堆区（Heap）：存放动态分配的内存，由程序员手动申请和释放。堆区内存具有手动管理的特点，需要程序员自己负责内存的申请和释放。</li>
<li>全局区（Static）：存放全局变量和静态变量等，程序运行时一直存在，直到程序结束后系统才会释放。</li>
<li>常量区（Constant）：存放常量，如字符串常量、全局常量等。常量区内存由系统管理，不允许程序员修改。</li>
<li>代码区（Code）：存放程序的代码，由系统管理，不允许程序员修改。</li>
</ul>
<p>C++ 内存分区模型的实现可能会因操作系统、编译器等环境的不同而有所差异，但是大部分 C++ 编译器都会遵循这个模型。在程序的开发和调试过程中，了解 C++ 的内存分区模型十分重要，可以帮助程序员更好地管理内存，避免出现内存泄漏、野指针等问题。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+----------------+</span><br><span class="line">|      Stack     |</span><br><span class="line">|                |</span><br><span class="line">|                |</span><br><span class="line">+----------------+</span><br><span class="line">|      Heap      |</span><br><span class="line">|                |</span><br><span class="line">|                |</span><br><span class="line">+----------------+</span><br><span class="line">|    Global/     |</span><br><span class="line">|    Static      |</span><br><span class="line">|                |</span><br><span class="line">+----------------+</span><br><span class="line">|   Constant     |</span><br><span class="line">|    Memory      |</span><br><span class="line">|                |</span><br><span class="line">+----------------+</span><br><span class="line">|     Code       |</span><br><span class="line">|                |</span><br><span class="line">|                |</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure>

<h2 id="可执行程序段"><a href="#可执行程序段" class="headerlink" title="可执行程序段"></a>可执行程序段</h2><p>可执行程序通常包含以下几个段：</p>
<ul>
<li>代码段（text segment）：也称为只读代码段，存放程序的指令或函数体的二进制代码。这个段通常是只读的，不允许修改，也不允许在此段上执行写操作。</li>
<li>数据段（data segment）：存放程序中已经被初始化的全局变量和静态变量，这个段通常是可读写的。</li>
<li>BSS 段（bss segment）：存放未被初始化的全局变量和静态变量，该段内存中的值默认为 0。这个段通常是可读写的。</li>
<li>其他段：在某些情况下，可执行程序还可能包含其他的段，比如常量段（常量字符串）和符号表段等。</li>
</ul>
<p>可执行程序的段的具体实现可能会因操作系统、编译器等环境的不同而有所差异。在程序的开发和调试过程中，了解可执行程序的不同段及其特点十分重要，可以帮助程序员更好地管理内存，避免出现内存泄漏、野指针等问题。</p>
<h2 id="特殊存储类型分区"><a href="#特殊存储类型分区" class="headerlink" title="特殊存储类型分区"></a>特殊存储类型分区</h2><ul>
<li>auto 变量：auto 变量是在函数内部定义的局部变量，存放在栈区。</li>
<li>extern 变量：extern 变量是由其他文件定义的全局变量，在本文件中只是声明（extern int a;），存放在数据段或BSS段。</li>
<li>static 变量：static 变量是由局部变量或全局变量加上 static 关键字定义的，存放在数据段或BSS段。</li>
<li>register 变量：register 变量是由局部变量加上 register 关键字定义的，存放在寄存器中。但是，编译器不一定会将变量放在寄存器中，而是根据具体情况决定是否放在寄存器中。</li>
<li>字符串常量：字符串常量是存放在只读数据段的常量区中，不能被修改。</li>
</ul>
<p>需要注意的是，C++ 的内存分配方式可能会因编译器、操作系统等环境的不同而有所差异，上述变量和常量所在的内存区域也可能因此而有所不同。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 内存映射</title>
    <url>/2023/03/25/C-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>C++ 中的内存映射是一种将文件映射到内存中的技术，可以直接在内存中读写文件，提高数据访问效率。</p>
<p>内存映射通过将文件的一部分映射到进程的虚拟内存空间中，使得进程可以直接读写文件的内容，而不需要进行系统调用。内存映射可以实现高效的随机访问和共享内存等功能，特别适用于大型文件的处理。</p>
<p>C++ 中可以通过 mmap() 函数进行内存映射，其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，addr 表示映射的起始地址，如果为 NULL 则由系统自动分配；length 表示映射区域的大小；prot 表示映射区域的保护方式，如 PROT_READ 表示只读，PROT_WRITE 表示可写等；flags 表示映射区域的特性，如 MAP_SHARED 表示共享内存，MAP_PRIVATE 表示私有内存等；fd 表示映射的文件描述符；offset 表示映射的文件偏移量。</p>
<p>内存映射使用完成后，需要使用 munmap() 函数进行解除映射，其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，addr 表示映射区域的起始地址，length 表示映射区域的大小。</p>
<p>需要注意的是，内存映射需要谨慎使用，需要注意文件访问权限和内存映射的保护方式，避免对系统造成安全风险。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 内联函数</title>
    <url>/2023/03/25/C-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>C++中的内联函数是一种特殊的函数，它的定义和声明可以放在类定义中，通常用于简单的函数或者频繁调用的函数。内联函数的调用不需要进行函数调用的开销，可以提高程序的执行效率。</p>
<p>内联函数的定义需要在函数声明前加上 inline 关键字，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">functionName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TO-DO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>内联函数的主要优点有：</p>
<ul>
<li>减少函数调用的开销，提高程序的执行效率。</li>
<li>由于内联函数直接嵌入到调用点，可以避免因为函数调用而导致的栈空间的分配和回收，从而提高程序的运行速度。</li>
<li>内联函数可以避免函数调用时的参数压栈、栈帧建立和函数返回时的栈帧销毁等开销，提高程序的效率。</li>
</ul>
<p>需要注意的是，内联函数适用于简单的函数或者频繁调用的函数，对于复杂的函数内联可能会导致代码膨胀，反而降低程序的执行效率。此外，内联函数的定义和声明通常应该放在头文件中，否则会导致链接错误。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 友元函数和友元类</title>
    <url>/2023/03/25/C-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>C++ 中的友元函数和友元类是一种特殊的访问权限，它们可以访问类的私有成员和保护成员。</p>
<p>友元函数是定义在类外部的普通函数，它可以被声明为类的友元函数，从而获得访问类的私有成员和保护成员的权限。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendFunction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">friendFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.privateMember = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 friendFunction() 函数被声明为 MyClass 的友元函数，可以访问 MyClass 中的私有成员 privateMember。</p>
<p>友元类是指在一个类中声明另一个类为友元类，从而使得该类可以访问友元类的私有成员和保护成员。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> privateMember;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">friendFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FriendClass obj;</span><br><span class="line">    obj.privateMember = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 MyClass 中声明了 FriendClass 为友元类，从而允许 FriendClass 访问 MyClass 中的私有成员和保护成员。</p>
<p>需要注意的是，友元函数和友元类打破了类的封装性，应谨慎使用。它们一般用于提高代码的灵活性和效率。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 和 C 有哪些不同</title>
    <url>/2023/03/25/C-%E5%92%8C-C-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>C++是在C语言的基础上扩展而来的，因此C++与C语言有很多相似之处，但也存在一些不同之处。以下是C++与C的主要区别：</p>
<ul>
<li>支持面向对象编程（OOP）：C++ 引入了类和对象等概念，支持 OOP，而 C 语言只支持过程式编程。</li>
<li>支持函数重载：C++ 允许在同一个作用域内定义多个同名的函数，但它们的参数类型、个数、或顺序必须不同。C 语言不支持函数重载。</li>
<li>引入命名空间（namespace）：C++ 中引入了命名空间的概念，可以避免命名冲突的问题。而 C 语言中没有命名空间。</li>
<li>支持运算符重载：C++ 允许重载运算符，使得自定义类型的操作更加灵活，而 C 语言不支持运算符重载。</li>
<li>引入构造函数和析构函数：C++ 中的类可以有构造函数和析构函数，它们分别用于对象的初始化和销毁。C 语言中没有构造函数和析构函数的概念。</li>
<li>支持继承和多态：C++  中支持类的继承和多态，可以更好地实现 OOP 的特性。C 语言中不支持类的继承和多态。</li>
<li>引入模板（template）：C++ 中引入了模板的概念，可以实现泛型编程，提高代码的复用性和可维护性。C 语言中没有模板的概念。</li>
</ul>
<p>总之，C++相比于C语言更加强大和灵活，能够支持更多的编程范式和特性，适用于更加复杂和庞大的项目。但同时，C++ 的语法也更加复杂，需要更加谨慎和注意编写。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 左值右值</title>
    <url>/2023/03/31/C-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在 C++ 中，左值（Lvalue）和右值（Rvalue）是表达式的两种分类方式，它们代表了表达式的不同特性。</p>
<h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><p>左值是指可以出现在赋值运算符左边的表达式，它们代表了一个具体内存地址的值，可以被取地址和修改。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;i; <span class="comment">// 取 i 的地址</span></span><br><span class="line">i = <span class="number">2</span>; <span class="comment">// 修改 i 的值</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，变量 i 是一个左值，因为它可以出现在赋值运算符左边，并且可以取地址和修改值。</p>
<p>C++ 字符串保存在文字常量区，所以也是左值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; &amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">// 打印字符串的地址</span></span><br></pre></td></tr></table></figure>

<h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><p>右值是指不能出现在赋值运算符左边的表达式，它们代表了一个临时的计算结果，不能被取地址和修改。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = i + <span class="number">2</span>; <span class="comment">// i + 2 是一个右值</span></span><br><span class="line"><span class="type">int</span>* p = &amp;(i + <span class="number">2</span>); <span class="comment">// 错误：右值不能取地址</span></span><br><span class="line">(i + <span class="number">2</span>) = <span class="number">3</span>; <span class="comment">// 错误：右值不能修改</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，i + 2 是一个右值，因为它不能出现在赋值运算符左边，不能取地址和修改值。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 左值引用右值引用</title>
    <url>/2023/03/31/C-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>左值引用和右值引用是 C++11 中引入的两种引用类型，它们分别引用左值和右值，具有不同的语义和用途。</p>
<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>左值引用是指一个引用变量绑定到一个左值上，可以使用 &amp; 运算符进行声明。左值引用可以用来做参数传递和返回值类型，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = i; <span class="comment">// 左值引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>; <span class="comment">// 左值引用参数</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func</span><span class="params">()</span></span>; <span class="comment">// 左值引用返回值</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，变量 r 是一个左值引用，它绑定到变量 i 上。函数参数和返回值类型都可以使用左值引用，这样可以避免复制大型对象，提高代码效率。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>右值引用是指一个引用变量绑定到一个右值上，可以使用 &amp;&amp; 运算符进行声明。右值引用通常用于移动语义和完美转发，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; r = <span class="number">1</span>; <span class="comment">// 右值引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span></span>; <span class="comment">// 右值引用参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(T&amp;&amp; t)</span></span>; <span class="comment">// 完美转发</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，变量 r 是一个右值引用，它绑定到字面量 1 上。函数参数可以使用右值引用，这样可以避免在函数内部产生临时变量，提高代码效率。模板函数中的 T&amp;&amp; 是一个通用的右值引用类型，用于实现完美转发，可以将参数原封不动地转发到其他函数中。</p>
<p>需要注意的是，左值引用和右值引用有着不同的生命周期和使用方式，需要根据具体情况选择合适的引用类型。在使用右值引用时，需要注意避免引用到已经被销毁的对象，从而导致悬垂指针的问题。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 指针和引用</title>
    <url>/2023/03/25/C-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>指针和引用是 C++ 中两种重要的变量类型，它们都可以用于对变量进行间接访问。指针和引用的区别如下：</p>
<ul>
<li>定义方式：指针使用 * 来定义，而引用使用 &amp; 来定义。</li>
<li>作用：指针可以存储变量的地址，并进行间接访问；而引用是变量的别名，用于直接访问变量。</li>
<li>空指针：指针可以被赋值为空指针（nullptr 或 NULL），而引用不能被赋值为空。</li>
<li>变量地址：指针可以指向任何变量的地址，而引用必须在定义时初始化，并且只能指向同一类型的变量。</li>
<li>操作方式：指针需要使用解引用符 * 进行操作，而引用直接使用变量名进行操作。</li>
<li>传递参数：指针可以作为函数参数传递，可以实现对变量的修改；而引用也可以作为函数参数传递，可以直接访问变量，同时也可以实现对变量的修改。</li>
</ul>
<p>需要注意的是，指针和引用都可以实现对变量的间接访问，但它们的使用场景和语法有所不同。指针通常用于动态内存分配、数组、链表等数据结构，而引用通常用于函数参数传递、避免拷贝大对象等场景。在实际编程中，需要根据具体的情况选择适合的变量类型。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 指针和数组</title>
    <url>/2023/03/25/C-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>数组和指针在 C++ 中都是非常重要的概念，它们之间有以下几点区别：</p>
<ul>
<li>定义方式不同：数组是一组连续的相同类型的变量的集合，数组的定义需要指定数组类型、数组名称和数组大小。指针是一个变量，用来存储一个变量的地址。指针的定义需要指定指针类型和指针名称。</li>
<li>存储方式不同：数组中的元素是在内存中连续存储的，可以通过下标来访问数组中的元素。指针是一个变量，存储的是一个地址，通过指针可以访问和修改存储在该地址上的变量的值。指针所指向的变量可以是数组中的元素，也可以是普通的变量。</li>
<li>大小不同：数组的大小是在定义时确定的，一旦定义后，数组的大小就不能再改变。指针的大小是固定的，与指针所指向的变量类型有关。</li>
<li>操作方式不同：数组的操作主要是通过下标来访问和修改数组元素的值。指针的操作主要是通过指针来访问和修改所指向的变量的值，可以进行指针运算，如加、减等。</li>
<li>作用不同：数组主要用于存储一组相同类型的变量，通常用于存储数据。指针主要用于访问和修改存储在内存中的变量的值，可以用于传递函数参数、动态内存分配等。</li>
</ul>
<p>综上所述，数组和指针在C++中都是非常常用的概念，但它们有不同的定义方式、存储方式、大小、操作方式和作用。在使用时需要根据具体的需求选择合适的数据类型</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 智能指针</title>
    <url>/2023/03/28/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>C++智能指针是一种特殊的指针，它可以自动释放所指向的对象，在程序中避免了内存泄漏等问题。C++ 中的智能指针主要有以下几种：</p>
<ul>
<li><p>unique_ptr：unique_ptr 是一种独占式智能指针，它使用move语义来传递所有权，即同一时间只能有一个 unique_ptr 指向某一对象。当 unique_ptr 超出作用域或被销毁时，它会自动调用delete来释放所指向的内存。</p>
</li>
<li><p>shared_ptr：shared_ptr 是一种共享式智能指针，它可以有多个 shared_ptr 指向同一个对象。当最后一个 shared_ptr 超出作用域或被销毁时，它会自动调用 delete 来释放所指向的内存。</p>
</li>
<li><p>weak_ptr：weak_ptr 是一种弱引用智能指针，它指向一个由 shared_ptr 管理的对象，但不会增加对象的引用计数。当最后一个 shared_ptr 超出作用域或被销毁时，weak_ptr 会自动失效。</p>
</li>
<li><p>auto_ptr（已被废弃）：auto_ptr 是一种独占式智能指针，它使用类似于 unique_ptr 的方式管理内存，但已经被废弃，不建议使用。</p>
</li>
</ul>
<p>智能指针可以帮助程序员管理对象的生命周期，避免内存泄漏等问题，但也需要注意使用方法，避免出现悬空指针等问题。同时，需要根据具体的业务场景和需求来选择合适的智能指针类型，以达到最佳的性能和可靠性。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 构造函数和析构函数</title>
    <url>/2023/03/25/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数（Constructor）是一个特殊的成员函数，用于在对象创建时初始化对象的数据成员。构造函数的名称必须与类名相同，它没有返回值（包括 void），可以有参数，但也可以没有参数。当创建对象时，编译器会自动调用构造函数来初始化对象的数据成员。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码中，Person 类定义了一个构造函数，该构造函数有两个参数（姓名和年龄），用于初始化对象的数据成员（name 和 age）。当创建 Person 对象时，会自动调用该构造函数。</p>
<h3 id="构造函数执行顺序"><a href="#构造函数执行顺序" class="headerlink" title="构造函数执行顺序"></a>构造函数执行顺序</h3><p>在C++中，当派生类对象被创建时，会先调用基类的构造函数，再调用派生类的构造函数。同时，派生类中成员类的构造函数也会在派生类构造函数中被调用。具体来说，构造函数的执行顺序如下：</p>
<ul>
<li>基类构造函数：派生类的构造函数会先调用基类的构造函数，以初始化基类中的成员变量。</li>
<li>成员类构造函数：派生类中的成员类的构造函数会在派生类构造函数中被调用，以初始化成员类中的成员变量。</li>
<li>派生类构造函数：最后，派生类的构造函数会被调用，以初始化派生类中新增的成员变量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Member</span>() &#123; cout &lt;&lt; <span class="string">&quot;Member constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Member member;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，创建 Derived 类对象d时，会先调用 Base 的构造函数，然后调用 Member 的构造函数，最后调用 Derived 的构造函数。输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Member constructor</span><br><span class="line">Derived constructor</span><br></pre></td></tr></table></figure>

<h3 id="为什么基类比派生类先构造"><a href="#为什么基类比派生类先构造" class="headerlink" title="为什么基类比派生类先构造"></a>为什么基类比派生类先构造</h3><p>基类比派生类先构造是因为在派生类的构造函数中需要先调用基类的构造函数，以确保基类的成员变量被正确初始化。因此，在派生类的构造函数中，先执行基类的构造函数，然后再执行派生类自己的构造函数。这样可以保证对象的完整性和正确性。</p>
<h3 id="为什么成员类比派生类先构造"><a href="#为什么成员类比派生类先构造" class="headerlink" title="为什么成员类比派生类先构造"></a>为什么成员类比派生类先构造</h3><p>成员类比派生类先构造是因为在派生类的构造函数中，需要先构造成员类对象，以便在派生类构造函数中使用。因此，成员类的构造函数会先于派生类的构造函数被调用，以确保成员类对象被正确初始化。这是因为成员类是派生类的一部分，成员类中的成员变量和成员函数在派生类中可以直接使用，因此必须先初始化成员类对象，才能在派生类中使用成员类对象的成员变量和成员函数。</p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数（Destructor）是用于在对象销毁时释放资源的特殊成员函数。析构函数的名称也必须与类名相同，但它必须以一个波浪线（~）作为前缀，它也没有返回值（包括void），不接受任何参数。当对象销毁时，编译器会自动调用析构函数来释放对象所占用的资源，例如动态分配的内存等。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Object destroyed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码中，Person 类定义了一个析构函数，当对象销毁时，会自动调用该析构函数，输出一条消息。</p>
<h3 id="析构函数执行顺序"><a href="#析构函数执行顺序" class="headerlink" title="析构函数执行顺序"></a>析构函数执行顺序</h3><p>在C++中，当派生类对象被销毁时，会先调用派生类的析构函数，再调用成员类的析构函数，最后调用基类的析构函数。具体来说，析构函数的执行顺序如下：</p>
<ul>
<li>派生类析构函数：析构函数的执行顺序与构造函数的执行顺序相反，因此派生类的析构函数会先被调用。</li>
<li>成员类析构函数：派生类中的成员类的析构函数会在派生类析构函数中被调用，以释放成员类中的资源。</li>
<li>基类析构函数：最后，基类的析构函数会被调用，以释放基类中的资源。</li>
</ul>
<p>需要注意的是，如果成员类的析构函数中有需要被派生类析构函数调用的资源释放操作，程序员需要在派生类析构函数中进行调用。否则，可能会导致资源泄漏或未定义行为。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Member</span>() &#123; cout &lt;&lt; <span class="string">&quot;Member destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Member member;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，销毁Derived类对象d时，会先调用Derived的析构函数，然后调用Member的析构函数，最后调用Base的析构函数。输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Derived destructor</span><br><span class="line">Member destructor</span><br><span class="line">Base destructor</span><br></pre></td></tr></table></figure>

<h3 id="为什么派生类比基类先析构"><a href="#为什么派生类比基类先析构" class="headerlink" title="为什么派生类比基类先析构"></a>为什么派生类比基类先析构</h3><p>派生类比基类先析构是因为在派生类的析构函数中，需要先释放派生类对象的成员变量和成员函数所占用的资源，然后再释放基类的成员变量和成员函数所占用的资源。因此，派生类的析构函数会先被调用，然后再调用基类的析构函数。这是因为在类继承中，派生类继承了基类的成员变量和成员函数，因此派生类对象中包含了基类对象，必须先销毁派生类对象中的成员变量和成员函数所占用的资源，才能销毁派生类对象中的基类对象的成员变量和成员函数所占用的资源。因此，派生类比基类先析构。</p>
<h3 id="为什么派生类比成员类先析构"><a href="#为什么派生类比成员类先析构" class="headerlink" title="为什么派生类比成员类先析构"></a>为什么派生类比成员类先析构</h3><p>派生类比成员类先析构是因为在派生类的析构函数中，需要先释放派生类对象中的成员变量和成员函数所占用的资源，然后再释放成员类对象中的成员变量和成员函数所占用的资源。因此，派生类的析构函数会先被调用，然后再调用成员类的析构函数。这是因为在类继承中，成员类是派生类的一部分，成员类中的成员变量和成员函数在派生类中可以直接使用，因此必须先释放派生类对象中的成员变量和成员函数所占用的资源，才能释放成员类对象中的成员变量和成员函数所占用的资源。因此，派生类比成员类先析构。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 构造函数类型</title>
    <url>/2023/03/26/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p>默认构造函数是指在没有提供显式定义的情况下，编译器自动生成的构造函数。默认构造函数没有参数，其作用是用默认值初始化对象的成员变量。</p>
<p>默认构造函数在以下情况下被自动创建：</p>
<ul>
<li>没有定义任何构造函数：如果类没有定义任何构造函数，编译器会自动创建一个默认构造函数。</li>
<li>定义了无参构造函数：如果类定义了无参构造函数，那么这个无参构造函数就是默认构造函数。</li>
<li>没有定义拷贝构造函数：如果类没有定义拷贝构造函数，但需要进行拷贝构造，编译器会自动创建一个默认的拷贝构造函数。</li>
</ul>
<p>默认构造函数的特点是没有参数，并且没有函数体。默认构造函数在以下情况下会被调用：</p>
<ul>
<li>对象被定义时：例如，<code>MyClass obj;</code>，编译器会自动调用默认构造函数来初始化obj对象的成员变量。</li>
<li>对象被赋初值时：例如，<code>MyClass obj = MyClass();</code>，编译器会自动调用默认构造函数来初始化临时对象 <code>MyClass()</code> 的成员变量，并将其赋值给 <code>obj</code> 对象。</li>
</ul>
<p>需要注意的是，如果类定义了自定义的构造函数，那么默认构造函数不会被自动生成。如果需要使用默认构造函数，可以通过显式定义一个无参构造函数来实现，默认构造函数也可以被显式地定义为有参函数，只要所有参数都有默认值即可。</p>
<h2 id="普通构造函数"><a href="#普通构造函数" class="headerlink" title="普通构造函数"></a>普通构造函数</h2><p>普通构造函数是指用户自己定义的构造函数，用于创建和初始化类的对象。普通构造函数可以接受参数，用于对对象的成员变量进行初始化。</p>
<p>普通构造函数的特点是：</p>
<ul>
<li>与类名相同：普通构造函数的名称与类名相同，没有返回值，包括void类型，也不需要显式声明返回类型。</li>
<li>可以有参数：普通构造函数可以接受参数，用于对对象的成员变量进行初始化。</li>
<li>可以重载：同一类中可以定义多个不同的普通构造函数，只要它们的参数类型或参数个数不同即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> num); <span class="comment">// 声明构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printNum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> num) &#123; <span class="comment">// 实现构造函数</span></span><br><span class="line">    m_num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::printNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_num = &quot;</span> &lt;&lt; m_num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>拷贝构造函数是一种特殊的构造函数，用于创建一个新的对象，并将其初始化为另一个同类型对象的副本。拷贝构造函数通常以引用方式传递参数，其作用是将被拷贝对象的成员变量复制到新对象中。</p>
<p>拷贝构造函数的特点是：</p>
<ul>
<li>参数为引用类型：拷贝构造函数的参数通常是一个同类型对象的引用，例如：MyClass(const MyClass&amp; obj)。</li>
<li>创建新对象：拷贝构造函数创建一个新的对象，并将其初始化为另一个同类型对象的副本。</li>
<li>默认实现：如果没有提供自定义的拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数，其作用是将被拷贝对象的成员变量复制到新对象中。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(); <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printNum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">    m_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj) &#123; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    m_num = obj.m_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::printNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_num = &quot;</span> &lt;&lt; m_num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赋值构造函数"><a href="#赋值构造函数" class="headerlink" title="赋值构造函数"></a>赋值构造函数</h2><p>赋值构造函数是一种特殊的构造函数，用于将一个同类型的对象赋值给另一个对象。与拷贝构造函数类似，赋值构造函数也用于创建一个新的对象，并将其初始化为另一个同类型对象的副本。不同之处在于，赋值构造函数的参数是一个同类型的对象引用，而不是一个 const 引用。</p>
<p>赋值构造函数的特点是：</p>
<ul>
<li>参数为引用类型：赋值构造函数的参数通常是一个同类型对象的引用，例如：<code>MyClass&amp; operator=(const MyClass&amp; obj)</code>。</li>
<li>创建新对象：赋值构造函数创建一个新的对象，并将其初始化为另一个同类型对象的副本。</li>
<li>避免浅拷贝：赋值构造函数需要避免浅拷贝，即将指针成员变量指向同一个地址的问题。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(); <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; obj); <span class="comment">// 赋值构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printNum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="built_in">int</span>(*obj.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass&amp; MyClass::<span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; obj) &#123; <span class="comment">// 赋值构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;obj) &#123; <span class="comment">// 避免自我赋值</span></span><br><span class="line">        <span class="keyword">delete</span> m_data; <span class="comment">// 释放原有资源</span></span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="built_in">int</span>(*obj.m_data); <span class="comment">// 深拷贝资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::printNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*m_data = &quot;</span> &lt;&lt; *m_data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h2><p>转换构造函数是一种特殊的构造函数，用于将其他类型的对象转换为当前类的对象。转换构造函数通常只有一个参数，可以将该类型的对象转换为当前类的对象。</p>
<p>转换构造函数的特点是：</p>
<ul>
<li>只有一个参数：转换构造函数只有一个参数，该参数是需要被转换的对象。</li>
<li>可以显式调用：转换构造函数可以显式调用，将其他类型的对象转换为当前类的对象。</li>
<li>可以隐式调用：转换构造函数也可以隐式调用，编译器会根据需要自动将其他类型的对象转换为当前类的对象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> num); <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> <span class="type">char</span>* str); <span class="comment">// 转换构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printNum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">    m_num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">    m_num = <span class="built_in">atoi</span>(str); <span class="comment">// 将字符串转换为整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::printNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_num = &quot;</span> &lt;&lt; m_num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，MyClass 类中定义了一个转换构造函数 MyClass(const char* str)，它的作用是将字符串转换为整数，并用这个整数来初始化 m_num 员变量。在函数内部，我们使用 atoi() 函数将字符串转换为整数并赋值给 m_num。在类外，我们可以显式调用这个转换构造函数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass obj = <span class="string">&quot;10&quot;</span>; <span class="comment">// 显式调用转换构造函数</span></span><br><span class="line">obj.<span class="built_in">printNum</span>(); <span class="comment">// 输出 m_num = 10</span></span><br></pre></td></tr></table></figure>

<h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><p>移动构造函数是C++11新增的一种特殊的构造函数，用于将一个对象的资源“移动”到另一个对象中，从而避免不必要的资源拷贝操作，提高程序的效率。</p>
<p>移动构造函数的特点是：</p>
<ul>
<li>参数为右值引用：移动构造函数的参数通常是一个右值引用，例如：MyClass(MyClass&amp;&amp; obj)。</li>
<li>创建新对象：移动构造函数创建一个新的对象，并将其初始化为另一个对象的副本，同时将被移动对象的资源转移到新对象中。</li>
<li>避免拷贝操作：移动构造函数的作用是将资源从一个对象“移动”到另一个对象中，避免了不必要的资源拷贝操作，提高了程序的效率。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(); <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; obj); <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printNum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="built_in">int</span>(*obj.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(MyClass&amp;&amp; obj) &#123; <span class="comment">// 移动构造函数</span></span><br><span class="line">    m_data = obj.m_data; <span class="comment">// 转移资源</span></span><br><span class="line">    obj.m_data = <span class="literal">nullptr</span>; <span class="comment">// 避免重复释放资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::printNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*m_data = &quot;</span> &lt;&lt; *m_data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><p>委托构造函数是C++11新增的一种特殊的构造函数，用于在一个构造函数中调用另一个构造函数，从而避免代码冗余。委托构造函数可以调用同一类中的其他构造函数，或者调用基类的构造函数。</p>
<p>委托构造函数的特点是：</p>
<ul>
<li>调用其他构造函数：委托构造函数的作用是调用同一类中的其他构造函数，或者调用基类的构造函数。</li>
<li>使用语法：委托构造函数使用语法为：构造函数名(参数列表) : 构造函数名(参数列表) { }。</li>
<li>避免代码冗余：委托构造函数可以避免代码冗余，提高程序的可读性和可维护性。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> num); <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">MyClass</span>(<span class="number">0</span>) &#123; &#125; <span class="comment">// 委托构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printNum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">    m_num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::printNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_num = &quot;</span> &lt;&lt; m_num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 模板</title>
    <url>/2023/03/25/C-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>C++ 中的模板是一种通用的编程工具，可以用于实现泛型编程。模板可以把类型作为参数，从而实现对不同类型的数据进行操作。</p>
<p>C++ 中有两种类型的模板：函数模板和类模板。</p>
<p>函数模板使用template关键字定义，可以接受任意类型的参数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T x, T y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 add() 函数是一个函数模板，它可以接受任何类型的参数，并进行相应的操作。</p>
<p>类模板也使用 template 关键字定义，可以接受任意类型的参数，并生成不同类型的类，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data is: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的 MyClass 类是一个类模板，它可以生成不同类型的类，例如 MyClass、MyClass 等。</p>
<p>在使用模板时，需要在调用时指定具体的类型，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">add</span>(x, y) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">MyClass&lt;<span class="type">int</span>&gt; obj;</span><br><span class="line">obj.data = <span class="number">10</span>;</span><br><span class="line">obj.<span class="built_in">print</span>();</span><br></pre></td></tr></table></figure>

<p>需要注意的是，模板的实现通常在头文件中，因为编译器需要在编译时生成具体的代码。此外，模板的使用需要谨慎，需要注意类型的合法性和效率问题</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 程序段</title>
    <url>/2023/03/25/C-%E7%A8%8B%E5%BA%8F%E6%AE%B5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>C++ 编译过程</title>
    <url>/2023/03/25/C-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>预处理：预处理器会处理源代码，执行一些预处理指令，例如 #include、#define 等，并生成一个预处理后的文件。</li>
<li>编译：编译器会将预处理后的文件编译成汇编语言。</li>
<li>汇编：汇编器会将汇编代码转换为机器指令，生成目标文件。</li>
<li>链接：链接器将目标文件和相关的库文件链接在一起，生成可执行文件。链接器会解析符号引用，符号引用是指在程序中引用的函数或变量，但是定义在其他文件中。链接器会将符号引用和符号定义关联起来，生成可执行文件。</li>
</ul>
<p>在实际编译过程中，编译器、汇编器和链接器通常会一起工作，将编译、汇编和链接步骤合并在一起，生成最终的可执行文件。此外，C++ 编译过程还包括词法分析、语法分析、语义分析、优化等步骤，这些步骤会在预处理和编译的过程中自动完成。</p>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+-----------------+</span><br><span class="line">|  源代码文件      |</span><br><span class="line">+-----------------+</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">+-----------------+</span><br><span class="line">|    预处理器      |</span><br><span class="line">+-----------------+</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">+-----------------+</span><br><span class="line">|     编译器       |</span><br><span class="line">+-----------------+</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">+-----------------+</span><br><span class="line">|     汇编器       |</span><br><span class="line">+-----------------+</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">+-----------------+</span><br><span class="line">|     链接器       |</span><br><span class="line">+-----------------+</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">+-----------------+</span><br><span class="line">|   可执行文件     |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 网络编程</title>
    <url>/2023/03/25/C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>C++ 网络编程主要是基于套接字通信实现的，可以使用 C++ 标准库提供的网络编程接口或第三方网络库来实现。以下是使用 C++ 标准库实现套接字通信的主要步骤：</p>
<h2 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h2><p>使用 socket() 函数创建套接字对象，指定套接字类型、协议类型和地址族等参数。例如，创建一个 TCP 套接字：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="绑定地址和端口号"><a href="#绑定地址和端口号" class="headerlink" title="绑定地址和端口号"></a>绑定地址和端口号</h2><p>使用 bind() 函数将套接字对象绑定到指定的地址和端口号上。例如，将套接字对象绑定到本地端口号为 8888 的地址上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);</span><br><span class="line"><span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="built_in">sizeof</span>(serv_addr));</span><br></pre></td></tr></table></figure>

<h2 id="监听连接请求"><a href="#监听连接请求" class="headerlink" title="监听连接请求"></a>监听连接请求</h2><p>使用 listen() 函数监听连接请求，指定最大连接数。例如，指定最大连接数为 5：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">listen</span>(sockfd, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h2 id="接受连接请求"><a href="#接受连接请求" class="headerlink" title="接受连接请求"></a>接受连接请求</h2><p>使用 accept() 函数接受连接请求，返回一个新的套接字对象用于和客户端进行通信。例如，接受一个连接请求：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cli_addr;</span><br><span class="line"><span class="type">socklen_t</span> clilen = <span class="built_in">sizeof</span>(cli_addr);</span><br><span class="line"><span class="type">int</span> newsockfd = <span class="built_in">accept</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;cli_addr, &amp;clilen);</span><br></pre></td></tr></table></figure>

<h2 id="发送和接收数据"><a href="#发送和接收数据" class="headerlink" title="发送和接收数据"></a>发送和接收数据</h2><p>使用 send() 和 recv() 函数发送和接收数据。例如，发送一条消息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* message = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="built_in">send</span>(newsockfd, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="关闭套接字"><a href="#关闭套接字" class="headerlink" title="关闭套接字"></a>关闭套接字</h2><p>使用 close() 函数关闭套接字对象，释放资源。例如，关闭套接字对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(sockfd);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 虚函数</title>
    <url>/2023/03/25/C-%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>C++中的虚函数是一种特殊的函数，它允许在派生类中重载基类中的同名函数，并且在运行时动态绑定到正确的函数。</p>
<p>虚函数使用虚函数表来实现动态绑定。每个对象都有一个指向虚函数表的指针，虚函数表存储了类中虚函数的地址。当调用虚函数时，程序会根据对象的虚函数表指针找到对应的虚函数地址，并进行调用。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>虚函数的定义需要在函数声明前加上 virtual 关键字，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">functionName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>在派生类中重载虚函数时，也需要使用 virtual 关键字，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">functionName</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<p>override关键字用于明确要重载基类中的虚函数，如果重载的函数和基类中的虚函数名称不匹配，则编译器会发出警告。</p>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数的定义需要在函数声明前加上关键字”= 0”，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">functionName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>如果一个类中存在纯虚函数，则该类为抽象类，不能被实例化。派生类必须实现父类中的纯虚函数才能被实例化。</p>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>菱形继承指的是一个类继承了两个有共同基类的类，导致在继承链中出现了菱形的形状。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcD</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，类 B 和类 C 都继承了类 A，而类 D 又同时继承了类 B 和类 C，因此在继承链中出现了菱形的形状。</p>
<p>这种继承方式可能会导致以下问题：</p>
<ul>
<li>内存浪费：由于类D同时继承了类 B 和类 C，因此会有两份 A 类的实例被继承。这会导致内存浪费，尤其是当 A 类较大时。</li>
<li>函数调用不明确：在菱形继承中，类 D 继承了两个 funcA() 函数，一个来自类 B，一个来自类 C。当在类 D 中调用 funcA() 时，编译器无法确定应该调用哪一个 funcA() 函数。这可能会导致程序出错。</li>
</ul>
<p>为了避免菱形继承带来的问题，可以使用虚继承。虚继承可以解决内存浪费和函数调用不明确的问题。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcD</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>虚函数的使用可以实现多态性，让程序根据对象的实际类型来调用正确的函数。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS 算法</title>
    <url>/2023/03/28/CAS-%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CAS（Compare and Swap）算法是一种用于实现并发控制的算法，它可以在多线程环境下保证数据的原子性和一致性。CAS 算法主要包括以下三个基本操作：</p>
<ul>
<li>比较操作（Compare）：CAS 算法首先会比较内存中的值和期望值是否相等，如果相等，则执行下一步操作，否则操作失败。</li>
<li>交换操作（Swap）：如果比较操作成功，则 CAS 算法会使用新值替换内存中的原值，从而完成对内存中数据的修改。</li>
<li>返回操作（Return）：无论操作是否成功，CAS 算法都会返回内存中的原值或新值，以便后续的处理。</li>
</ul>
<p>CAS算法可以保证多线程环境下数据的原子性和一致性，避免了数据竞争和死锁等问题。在实际应用中，CAS 算法常常被用于实现锁机制、线程同步和无锁数据结构等场景。需要注意的是，CAS 算法虽然可以保证数据的一致性，但也可能出现 ABA 问题，需要特殊处理。</p>
<h2 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h2><p>ABA问题是指在多线程环境中，由于线程的并发执行，可能导致一个变量的值从 A 变为 B，然后再从 B 变回 A，从而导致比较和替换操作（如 CAS 操作）出现误判，从而出现错误的结果。</p>
<p>例如，假设有两个线程 A 和 B，它们都要对同一个变量进行修改。线程 A 先读取到该变量的值为 A ，然后执行了一些操作，期间线程 B 也对该变量进行了修改，将其值从 A 改为了 B，然后又将其值从 B 改回了 A，最后线程 A 再次读取该变量时，仍然读取到了 A，于是它误以为变量的值没有被修改过，从而执行了一些错误的操作。</p>
<p>为了解决 ABA 问题，通常需要在 CAS 操作中加入版本号或时间戳等标记，每次修改变量时，都要更新标记，这样即使变量的值从 A 变为 B 再变回 A，但是标记也会相应地发生改变，从而避免误判。同时，还可以使用带有回调函数的 CAS 操作，当变量的值发生变化时，可以执行回调函数来进行处理。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 重载重写重定义</title>
    <url>/2023/03/25/C-%E9%87%8D%E8%BD%BD%E9%87%8D%E5%86%99%E9%87%8D%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>C++ 重载是指在同一作用域内定义多个具有相同名称但参数类型或数量不同的函数或运算符，使得它们可以根据不同的输入参数来执行不同的操作。C++ 支持函数重载和运算符重载。</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数重载是指在同一作用域内定义多个函数名相同但参数个数、类型或顺序不同的成员函数或非成员函数，使得它们可以根据不同的输入参数来执行不同的操作。函数重载可以提高代码的可读性和灵活性，避免编写大量重复代码。</p>
<p>在C++中，函数重载的实现需要满足以下条件：</p>
<ul>
<li>函数名相同；</li>
<li>参数列表不同，包括参数个数、类型或顺序；</li>
<li>返回值类型可以相同也可以不同（返回值类型不能作为函数重载的区分标准）。</li>
</ul>
<p>例如，可以在一个图形类中定义多个名为 area() 的函数，分别计算不同形状（如圆形、矩形、三角形等）的面积。这些函数可以有不同的参数个数、类型或顺序，以适应不同形状的计算需求，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * r * r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> p = (a + b + c) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(p * (p - a) * (p - b) * (p - c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在调用 area() 函数时，编译器会根据传入的参数类型、个数和顺序来判断应该调用哪个函数。</p>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>运算符重载是一种编程技术，允许程序员重新定义已有的运算符，使其能够在自定义类型上执行特定操作。通过重载运算符，程序员可以使用常见的算术、比较以及其他运算符来操作自己定义的类或结构体实例。</p>
<h5 id="可重载运算符"><a href="#可重载运算符" class="headerlink" title="可重载运算符"></a>可重载运算符</h5><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>双目算术运算符</td>
<td>+ (加)，-(减)，*(乘)，/(除)，% (取模)</td>
</tr>
<tr>
<td>关系运算符</td>
<td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，–(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>=, +=, -=, *=, /= , % = , &amp;=,</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td>()(函数调用)，-&gt;(成员访问)，,(逗号)，[](下标)</td>
</tr>
</tbody></table>
<h5 id="不可重载运算符"><a href="#不可重载运算符" class="headerlink" title="不可重载运算符"></a>不可重载运算符</h5><ul>
<li>.：成员访问运算符</li>
<li>.*, -&gt;*：成员指针访问运算符</li>
<li>::：域运算符</li>
<li>sizeof：长度运算符</li>
<li>?:：条件运算符</li>
<li>#： 预处理符号</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OperatorTest</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>+(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = data + other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator + called return=&quot;</span> &lt;&lt; tmp&lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>-(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = data - other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator - called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>*(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = data * other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator * called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>/(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = data/other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator / called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>%(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = data%other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator % called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">bool</span> tmp = data == other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator == called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">bool</span> tmp = data != other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator != called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">bool</span> tmp = data &gt; other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator &gt; called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">bool</span> tmp = data &lt; other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator &lt; called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">bool</span> tmp = data &gt;= other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator &gt;= called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">bool</span> tmp = data &lt;= other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator &lt;= called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> ||(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">bool</span> tmp = data || other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator || called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &amp;&amp;(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">bool</span> tmp = data &amp;&amp; other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator &amp;&amp; called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!() &#123;</span><br><span class="line">        <span class="type">bool</span> tmp = data ==<span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator ! called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>&amp;(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = data &amp; other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator &amp; called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>|(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = data | other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator | called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>~() &#123;</span><br><span class="line">        <span class="type">int</span> tmp = ~data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator ~ called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>^(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = data ^ other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator ^ called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>&lt;&lt;(<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = data &lt;&lt; i;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator &lt;&lt; called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>&gt;&gt;(<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = data &gt;&gt; i;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator &gt;&gt; called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> OperatorTest&amp; <span class="keyword">operator</span>=(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        data = other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator = called data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> OperatorTest&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        data += other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator += called data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> OperatorTest&amp; <span class="keyword">operator</span>-=(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        data -= other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator -= called data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> OperatorTest&amp; <span class="keyword">operator</span>*=(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        data *= other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator *= called data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> OperatorTest&amp; <span class="keyword">operator</span>/=(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        data /= other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator /= called data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> OperatorTest&amp; <span class="keyword">operator</span>%=(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        data %= other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator %= called data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> OperatorTest&amp; <span class="keyword">operator</span>&amp;=(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        data &amp;= other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator &amp;= called data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> OperatorTest&amp; <span class="keyword">operator</span>|=(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        data |= other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator |= called data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> OperatorTest&amp; <span class="keyword">operator</span>^=(<span class="type">const</span> OperatorTest&amp; other) &#123;</span><br><span class="line">        data ^= other.data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator ^= called data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> OperatorTest&amp; <span class="keyword">operator</span>&lt;&lt;=(<span class="type">int</span> i) &#123;</span><br><span class="line">        data &lt;&lt;= i;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator &lt;&lt;= called data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> OperatorTest&amp; <span class="keyword">operator</span>&gt;&gt;=(<span class="type">int</span> i)&#123;</span><br><span class="line">        data &gt;&gt;= i;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator &gt;&gt;= called data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>-() &#123;</span><br><span class="line">        <span class="type">int</span> tmp = -data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator - called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>+() &#123;</span><br><span class="line">        <span class="type">int</span> tmp = data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator + called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="type">int</span> tmp = *(&amp;data);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator * called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">operator</span>&amp;() &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> tmp = (<span class="type">unsigned</span> <span class="type">long</span>)<span class="keyword">this</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator &amp; called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="type">int</span> tmp = ++data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator ++ called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>++(<span class="type">int</span>)/&#123;</span><br><span class="line">        <span class="type">int</span> tmp = data++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator ++ called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>--()&#123;</span><br><span class="line">        <span class="type">int</span> tmp = --data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator -- called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">        <span class="type">int</span> tmp = data--;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator -- called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator new called&quot;</span>&lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr,<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator delete called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr,size)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator new[] called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* ptr,<span class="type">size_t</span> size) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator delete[] called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        ::<span class="keyword">operator</span> <span class="keyword">delete</span>[](ptr,size);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator () called data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        data = i;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator (i) called data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    OperatorTest* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator -&gt; called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>[](<span class="type">int</span> i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator [] called return=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span> ,(<span class="type">int</span> i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator , called return=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> tmp = data &gt; <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator bool called return=&quot;</span> &lt;&lt; tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">char</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> tmp = data&gt;&gt;<span class="number">24</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator char called return=&quot;</span> &lt;&lt; (<span class="type">int</span>)tmp &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="重写（覆盖）"><a href="#重写（覆盖）" class="headerlink" title="重写（覆盖）"></a>重写（覆盖）</h3><p>C++ 中的派生类可以继承基类的成员函数，并重写（覆盖）基类中的同名函数。当基类指针或引用指向派生类对象时，调用的是派生类中的函数，这就是函数的重写。</p>
<h3 id="重定义（隐藏）"><a href="#重定义（隐藏）" class="headerlink" title="重定义（隐藏）"></a>重定义（隐藏）</h3><p>C++ 中的派生类也可以定义与基类同名的成员函数，但是参数列表不同。这样的函数称为重定义函数。当基类指针或引用指向派生类对象时，调用的是基类中的函数，而不是派生类中的函数，这就是函数的重定义</p>
<p>隐藏有下面两种情况</p>
<ul>
<li>如果派生类的函数与基类的函数同名, 但是参数不同. 此时, 不论有无 virtual 关键字，基类的函数将被隐藏(注意别与重载混淆)</li>
<li>如果派生类的函数与基类的函数同名, 并且参数也相同, 但是基类函数没有 virtual 关键字，此时, 基类的函数被隐藏(注意别与覆盖混淆)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">float</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::f(float) &quot;</span>  &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::f(int) &quot;</span>  &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">float</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::g(float) &quot;</span>  &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(<span class="type">float</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::h(float) &quot;</span>  &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived::f(int) &quot;</span>  &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived::g(int) &quot;</span>  &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">(<span class="type">float</span> x)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived::h(float) &quot;</span>  &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    Base *pb = &amp;d;</span><br><span class="line">    Derived *pd = &amp;d;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//没出现隐藏的情况</span></span><br><span class="line">    pb-&gt;<span class="built_in">f</span>(<span class="number">3.14f</span>);             <span class="comment">//Derived::f(float) 3.14</span></span><br><span class="line">    pd-&gt;<span class="built_in">f</span>(<span class="number">3.14f</span>);             <span class="comment">//Derived::f(float) 3.14</span></span><br><span class="line">    </span><br><span class="line">    pd-&gt;<span class="built_in">f</span>(<span class="number">3</span>, <span class="number">2</span>);             <span class="comment">// error</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//出现隐藏的情况 1</span></span><br><span class="line">    pb-&gt;<span class="built_in">g</span>(<span class="number">3.14f</span>);             <span class="comment">//Base::g(float) 3.14</span></span><br><span class="line">    pd-&gt;<span class="built_in">g</span>(<span class="number">3.14f</span>);             <span class="comment">//Derived::g(int)  3       (surprise!)</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//出现隐藏的情况 2</span></span><br><span class="line">    pb-&gt;<span class="built_in">h</span>(<span class="number">3.14f</span>);             <span class="comment">//Base::h(float) 3.14         (surprise!)</span></span><br><span class="line">    pd-&gt;<span class="built_in">h</span>(<span class="number">3.14f</span>);             <span class="comment">//Derived::h(float)  3.14</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重定义一旦发生，就无法调用基类的同名函数</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CRT</title>
    <url>/2023/03/30/CRT/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>C++ CRT（C Runtime）是指 C++ 运行时库，是用于支持 C++ 语言的一系列函数和库的集合。C++ CRT 由多个库文件组成，包括 libcmt.lib、libcpmt.lib、libvcruntime.lib 等。C++ CRT 可以提供一些常用的函数和数据结构，例如数学函数、字符串函数、内存函数、文件操作函数、异常处理函数等，以及一些与 C++ 相关的数据结构和特性，例如类、对象、虚函数、RTTI 等。</p>
<p>C++ CRT 在编译和链接 C++ 程序时会被自动引入，程序员不需要显式地调用 C++ CRT 中的函数和库。C++ CRT 运行时库的版本可以根据编译器版本和操作系统版本的不同而有所不同。</p>
<p>C++ CRT 在 C++ 编程中扮演着重要的角色，它提供了许多 C++ 的标准库和函数，简化了 C++ 程序的编写和开发。C++ CRT 也是一些 C++ 应用程序必不可少的组成部分，例如 Microsoft Visual Studio 等。</p>
<h2 id="运行时库类型"><a href="#运行时库类型" class="headerlink" title="运行时库类型"></a>运行时库类型</h2><p>MT、MTd、MD、MDd 是 Microsoft Visual C++ 编译器的运行时库选项，用于指定程序运行时使用的 C++ 运行库类型。具体解释如下：</p>
<ul>
<li>MT（Multithreaded）：使用多线程方式编译和链接程序，并使用静态链接的 C++ 运行库。MT 可以提高程序的运行速度，但会增加程序的体积。</li>
<li>MTd（Multithreaded Debug）：使用多线程方式编译和链接程序，并使用静态链接的 C++ 调试运行库。MTd 可以提供调试信息，但会增加程序的体积。</li>
<li>MD（Multithreaded DLL）：使用多线程方式编译和链接程序，并使用动态链接的 C++ 运行库。MD 可以减少程序的体积，但需要依赖外部的 C++ 运行库。</li>
<li>MDd（Multithreaded Debug DLL）：使用多线程方式编译和链接程序，并使用动态链接的 C++ 调试运行库。MDd 可以提供调试信息，同时也需要依赖外部的 C++ 调试运行库。</li>
</ul>
<p>在使用 Microsoft Visual C++ 编译器进行程序开发时，需要根据具体的需求选择适当的运行时库选项。一般情况下，如果程序需要在多个平台上运行，建议使用 MD 或 MDd；如果程序需要提高运行速度，可以使用 MT 或 MTd。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake</title>
    <url>/2023/03/26/Cmake/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CMake是一种跨平台的构建工具，可用于生成与平台无关的构建脚本和编译器文件。CMake 使用 CMakeLists.txt 文件来描述构建过程，可以自动生成各种构建系统（如 Makefile、Visual Studio 项目等），从而让开发者能够更方便地使用不同的编译器和操作系统。<br>CMake 的主要特点包括：</p>
<ul>
<li>跨平台：CMake 可以在各种操作系统（如 Windows、Linux、macOS 等）上运行，并可以生成各种平台的构建文件。</li>
<li>简单易用：CMake 使用简单的语法和结构，易于学习和使用。CMakeLists.txt 文件可以很容易地描述项目的构建过程。</li>
<li>自动化构建：CMake 可以自动生成各种构建系统文件，如 Makefile、Visual Studio 项目等，从而让开发者能够更方便地使用不同的编译器和操作系统。</li>
<li>多语言支持：CMake 可以支持多种编程语言，包括 C、C++、Java、Python 等，可以方便地管理多语言项目。</li>
<li>可扩展性：CMake 可以通过插件机制进行扩展，可以使用各种插件来增强其功能和性能。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>DLL 为什么不能用 STL</title>
    <url>/2023/03/25/DLL-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8-STL/</url>
    <content><![CDATA[<p>在 DLL 中使用 STL（Standard Template Library）的主要问题是内存管理。STL 中的容器和算法是使用动态内存分配的，但是在 DLL 中，内存的分配和释放是由不同的内存管理器负责的。如果使用不同的内存管理器来分配和释放同一块内存，就可能会导致内存泄漏、重复释放等问题。</p>
<p>此外，STL 中的容器和算法可能会导致二进制兼容性问题。如果 DLL 中使用了 STL，那么其他程序需要使用相同的 STL 版本才能正确地调用和使用 DLL 中的函数，否则可能会导致编译错误或运行时错误。</p>
<p>为了避免这些问题，通常建议在 DLL 开发中避免使用 STL，或者只在 DLL 的导出函数和导出变量中使用 STL 的简单函数和数据结构，而不涉及动态内存分配和释放等操作。如果需要在 DLL 中使用 STL，可以考虑使用 COM（Component Object Model）接口，将 STL 封装在 COM 接口中，以便其他程序可以正确地使用它们。</p>
<p>总之，为了确保 DLL 的正确性和稳定性，需要仔细管理内存分配和释放，避免使用不兼容的 STL 版本，以及遵循 DLL 编程的最佳实践。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>DLL 和 LIB</title>
    <url>/2023/03/25/DLL-%E5%92%8C-LIB/</url>
    <content><![CDATA[<p>DLL（Dynamic Link Library）和LIB（Static Link Library）都是 Windows 平台上的库文件，用于在程序中共享代码。它们的主要区别在于链接方式和运行时机制。</p>
<h2 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h2><p>LIB 是一种静态链接库，它的代码在编译时被链接到可执行文件中，因此程序启动时加载的是完整的代码。而 DLL 是一种动态链接库，它的代码在运行时才被加载到内存中，因此程序启动时只需要加载 DLL 的导入表和一些必要的代码，而不是整个代码库。</p>
<h2 id="运行时机制"><a href="#运行时机制" class="headerlink" title="运行时机制"></a>运行时机制</h2><p>LIB 和 DLL 的运行时机制也不同。由于 LIB 的代码被链接到可执行文件中，因此程序启动后不需要再次加载库文件或者进行其他的操作，可以直接使用库函数。而 DLL 的代码在运行时才被加载，因此程序启动后需要在内存中加载 DLL 的代码，并且需要使用特定的函数来调用 DLL 中的函数。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>LIB 的主要优点在于它可以提高程序的性能，因为它的代码在编译时就被链接到可执行文件中，可以直接使用库函数。而 DLL 的主要优点在于它可以共享代码，多个程序可以共享同一个 DLL，从而节省内存。此外，DLL 的代码可以在运行时被更新，而 LIB 的代码必须重新编译才能更新。</p>
<p>总之，LIB 和 DLL 都是在程序中共享代码的工具，但是它们的链接方式和运行时机制不同，适用于不同的场景和需求。选择使用哪种方式取决于具体的情况和需求。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>DLL 重新编译情况</title>
    <url>/2023/03/25/DLL-%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<p>DLL 需要重新编译的情况有以下几种：</p>
<ul>
<li>修改了 DLL 中的导出函数或导出变量：如果修改了 DLL 中的导出函数或导出变量的定义，需要重新编译 DLL。</li>
<li>修改了 DLL 中的头文件：如果修改了 DLL 中的头文件，需要重新编译 DLL。</li>
<li>修改了 DLL 中的实现文件：如果修改了 DLL 中的实现文件，需要重新编译 DLL。</li>
<li>修改了 DLL 的编译选项或编译器版本：如果修改了 DLL 的编译选项或编译器版本，需要重新编译 DLL，以确保与其他程序的兼容性。</li>
<li>修改了 DLL 中依赖的库文件：如果修改了 DLL 中依赖的库文件，需要重新编译 DLL，以确保与其他程序的兼容性。</li>
<li>需要注意的是，如果 DLL 的接口部分没有变化，只需要重新编译 DLL 的实现部分即可。另外，如果其他程序使用了 DLL，需要重新编译这些程序以确保与 DLL 的兼容性。</li>
</ul>
<p>总之，在 DLL 的开发和维护过程中，需要及时重新编译 DLL，以确保 DLL 的正确性和稳定性，避免出现兼容性问题。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart 包管理工具</title>
    <url>/2023/04/18/Dart-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>pub 是 Dart 语言中的包管理器，用于管理Dart库和依赖项。以下是一些常用的 pub 命令：</p>
<ul>
<li>flutter pub get：从远程仓库下载项目的所有依赖项，并将它们安装到本地的 packages 目录下。</li>
<li>flutter pub upgrade：升级项目的依赖项到最新版本，并将其保存在 pubspec.lock 文件中。</li>
<li>flutter pub global activate：安装一个全局可执行程序，通常是一个 Dart 包。</li>
<li>flutter pub global deactivate：停止使用某个全局可执行程序。</li>
<li>flutter pub publish：将一个 Dart 包发布到 Pub 仓库，以供其他人使用。</li>
<li>flutter pub cache repair：修复本地缓存中的损坏或者不完整的依赖项。</li>
<li>flutter pub run：在当前项目中运行一个 Dart 脚本或者可执行程序。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>EMQX MQTT Server 搭建</title>
    <url>/2023/04/24/EMQX-MQTT-Server-%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="配置-EMQX-APT-源。"><a href="#配置-EMQX-APT-源。" class="headerlink" title="配置 EMQX APT 源。"></a>配置 EMQX APT 源。</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://assets.emqx.com/scripts/install-emqx-deb.sh | sudo bash</span><br></pre></td></tr></table></figure>

<p><img src="/img/uTools_1682281779488.png" alt="图片"></p>
<h2 id="安装-EMQX-最新版。"><a href="#安装-EMQX-最新版。" class="headerlink" title="安装 EMQX 最新版。"></a>安装 EMQX 最新版。</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install emqx</span><br></pre></td></tr></table></figure>

<h2 id="设置-dashboard-密码"><a href="#设置-dashboard-密码" class="headerlink" title="设置 dashboard 密码"></a>设置 dashboard 密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano /etc/emqx/emqx.conf</span><br></pre></td></tr></table></figure>

<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo emqx start</span><br></pre></td></tr></table></figure>

<p><img src="/img/uTools_1682283015248.png" alt="图片"></p>
<h2 id="访问-dashboard"><a href="#访问-dashboard" class="headerlink" title="访问 dashboard"></a>访问 dashboard</h2><p><img src="/img/uTools_1682283295696.png" alt="图片"></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 代理修改</title>
    <url>/2023/04/26/Go-%E4%BB%A3%E7%90%86%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2023/03/26/HTTP/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>HTTP（超文本传输协议）是一种应用层协议，用于在计算机网络之间传输万维网数据。目前，HTTP主要有以下版本：</p>
<ul>
<li>HTTP/0.9：是最初的HTTP协议，只支持GET请求方法，没有头部信息和状态码等特性。</li>
<li>HTTP/1.0：是第一个正式的HTTP协议版本，支持多种请求方法（如GET、POST等），支持头部信息、状态码等特性，但每个请求都需要建立一个新的TCP连接。</li>
<li>HTTP/1.1：是目前最广泛使用的HTTP协议版本，相对于HTTP/1.0，它引入了持久连接、管线化、分块传输编码和缓存等特性，从而提高了性能和效率。</li>
<li>HTTP/2：是HTTP协议的最新版本，它在HTTP/1.1的基础上引入了多路复用、头部压缩、服务器推送等新特性，从而进一步提高了性能和效率。</li>
</ul>
<h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>HTTP/1.1 是目前广泛使用的 HTTP 协议版本，相对于 HTTP/1.0，它引入了持久连接、管线化、分块传输编码和缓存等特性，从而提高了性能和效率。下面详细介绍 HTTP/1.1 的主要特性：</p>
<ul>
<li>持久连接：HTTP/1.1 引入了持久连接的概念，即在一个 TCP 连接上可以传输多个 HTTP 请求和响应，从而避免了每个请求都需要建立一个新的 TCP 连接的开销，提高了效率。</li>
<li>管线化：HTTP/1.1 支持管线化，即在一个 TCP 连接上可以同时发送多个请求，而不需要等到前一个请求的响应返回。这样可以减少网络延迟，提高性能。</li>
<li>分块传输编码：HTTP/1.1 支持分块传输编码，可以将一个大的 HTTP 响应分成多个块进行传输，从而避免了等待整个响应返回的开销，提高了效率。</li>
<li>缓存：HTTP/1.1 引入了缓存机制，可以将之前的 HTTP 响应缓存起来，以便之后的请求可以直接使用缓存中的响应，而不需要重新发送请求。这样可以减少网络流量和延迟，提高性能。</li>
<li>虚拟主机：HTTP/1.1 支持虚拟主机，即在同一个物理服务器上可以运行多个虚拟主机，每个虚拟主机可以有自己的域名和 IP 地址，从而提高了服务器的利用率。</li>
<li>安全：HTTP/1.1 引入了 HTTPS 协议，可以通过 SSL/TLS 来保证通信的安全性，避免了数据被窃取和篡改的风险。</li>
</ul>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><p>HTTP/2是HTTP协议的最新版本，它在HTTP/1.1的基础上引入了多路复用、头部压缩、服务器推送等新特性，从而进一步提高了性能和效率。下面详细介绍HTTP/2的主要特性：</p>
<ul>
<li>多路复用：HTTP/2 支持多路复用，即在一个 TCP 连接上可以同时传输多个 HTTP 请求和响应，而不需要等待前一个请求的响应返回。这样可以避免 HTTP/1.1 中的队头阻塞问题，提高性能和效率。</li>
<li>头部压缩：HTTP/2 引入了 HPACK 算法，可以对 HTTP 头部进行压缩，从而减少网络传输的数据量，提高性能和效率。</li>
<li>服务器推送：HTTP/2 支持服务器推送，即在客户端请求某个资源时，服务器可以主动推送相关的资源给客户端，而不需要客户端再次发送请求。这样可以避免网络延迟和等待时间，提高性能和效率。</li>
<li>二进制传输：HTTP/2 的消息格式采用二进制编码，而不是 HTTP/1.1 中的文本格式，可以更高效地进行解析和传输。</li>
<li>流量控制：HTTP/2 支持流量控制，可以根据网络状况和带宽限制来控制流量的传输，从而避免网络拥塞和性能下降。</li>
<li>安全性增强：HTTP/2 要求使用 HTTPS 协议，可以通过 SSL/TLS 来保证通信的安全性，避免了数据被窃取和篡改的风险。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>INT3 指令</title>
    <url>/2023/03/30/INT3-%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>IO 模型</title>
    <url>/2023/03/25/IO-%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>IO模型是指在计算机系统中，用于管理输入输出（IO）操作的一种方式，主要包括阻塞式 IO、非阻塞式 IO、IO 复用、信号驱动式 IO 和异步 IO 等。</p>
<ul>
<li>阻塞式 IO（Blocking IO）：在阻塞式 IO 中，当进程打开一个文件或套接字并发起一个 IO 操作时，进程会一直阻塞在 IO 操作上直到操作完成或发生错误。在这个过程中，进程无法进行其他的操作，因此会浪费大量的CPU时间。</li>
<li>非阻塞式 IO（Non-blocking IO）：在非阻塞式 IO 中，当进程发起一个 IO 操作时，它会立即返回并继续执行下一条语句，不会阻塞在 IO 操作上。进程需要周期性地轮询 IO 操作的状态，直到 IO 操作完成或发生错误。</li>
<li>IO 复用（IO Multiplexing）：在 IO 复用中，进程可以同时监听多个 IO 操作，并等待其中任意一个 IO 操作完成。常见的 IO 复用技术包括 select、poll 和 epoll 等。</li>
<li>信号驱动式 IO（Signal-driven IO）：在信号驱动式 IO 中，进程发起一个 IO 操作后，内核会为该操作注册一个信号处理函数，并在 IO 操作完成时发送一个信号给进程。进程需要在信号处理函数中处理 IO 操作的结果。</li>
<li>异步 IO（Asynchronous IO）：在异步 IO 中，进程发起一个 IO 操作后，它会立即返回并继续执行下一条语句。当 IO 操作完成时，内核会通知进程并返回 IO 操作的结果。与非阻塞式 IO 不同的是，进程不需要周期性地轮询 IO 操作的状态。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript this 指向</title>
    <url>/2023/02/19/JavaScript-this-%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h2 id="1-全局作用域中的-this"><a href="#1-全局作用域中的-this" class="headerlink" title="1 全局作用域中的 this"></a>1 全局作用域中的 this</h2><p>在严格模式下，在全局作用域中，this指向window对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;严格模式&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;在全局作用域中的this&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this.document === document&quot;</span>, <span class="variable language_">this</span>.<span class="property">document</span> === <span class="variable language_">document</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this === window&quot;</span>, <span class="variable language_">this</span> === <span class="variable language_">window</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">9804</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this.a === window.a===&#x27;</span>, <span class="variable language_">window</span>.<span class="property">a</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/img/158444221248359.png" alt="&#39;&#39;"></p>
<h2 id="2-全局作用域中函数中的-this"><a href="#2-全局作用域中函数中的-this" class="headerlink" title="2 全局作用域中函数中的 this"></a>2 全局作用域中函数中的 this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;严格模式&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在全局作用域中函数中的this&#x27;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">f3</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">f3</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>();</span><br><span class="line"><span class="title function_">f2</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/img/215784321243495.png" alt="&#39;&#39;"></p>
<h2 id="3-对象的函数（方法）中的-this"><a href="#3-对象的函数（方法）中的-this" class="headerlink" title="3 对象的函数（方法）中的 this"></a>3 对象的函数（方法）中的 this</h2><p>在严格模式下，对象的函数中的this指向调用函数的对象实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;严格模式&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;在对象的函数中的this&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">o.<span class="property">a</span> = <span class="string">&#x27;o.a&#x27;</span>;</span><br><span class="line">o.<span class="property">f5</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o.<span class="title function_">f5</span>());</span><br></pre></td></tr></table></figure>

<p><img src="/img/42504521237041.png" alt="&#39;&#39;"></p>
<h2 id="4-构造函数的-this"><a href="#4-构造函数的-this" class="headerlink" title="4 构造函数的 this"></a>4 构造函数的 this</h2><p>在严格模式下，构造函数中的this指向构造函数创建的对象实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;严格模式&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;构造函数中的this&quot;</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">constru</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="string">&#x27;constru.a&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">f2</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">b</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="title function_">constru</span>();</span><br><span class="line">o2.<span class="property">b</span> = <span class="string">&#x27;o2.b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o2.<span class="title function_">f2</span>());</span><br></pre></td></tr></table></figure>

<p><img src="/img/111874721230175.png" alt="&#39;&#39;"></p>
<h2 id="5-事件处理函数中的-this"><a href="#5-事件处理函数中的-this" class="headerlink" title="5 事件处理函数中的 this"></a>5 事件处理函数中的 this</h2><p>在严格模式下，在事件处理函数中，this指向触发事件的目标对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">blue_it</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === e.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;#00f&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  elements[i].<span class="property">onclick</span> = blue_it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码的作用是使被单击的元素背景色变为蓝色</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/404295421220705.png" alt="&#39;&#39;"></p>
<h2 id="6-内联事件处理函数中的-this"><a href="#6-内联事件处理函数中的-this" class="headerlink" title="6 内联事件处理函数中的 this"></a>6 内联事件处理函数中的 this</h2><p>在严格模式下，在内联事件处理函数中，有以下两种情况：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert((function()&#123;&#x27;use strict&#x27;; return this&#125;)());&quot;</span>&gt;</span></span><br><span class="line">  内联事件处理1</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 警告窗口中的字符为undefined --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;&#x27;use strict&#x27;; alert(this.tagName.toLowerCase());&quot;</span>&gt;</span></span><br><span class="line">  内联事件处理2</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 警告窗口中的字符为button --&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/597215821223209.png" alt="&#39;&#39;"></p>
<p><img src="/img/179235921232156.png" alt="&#39;&#39;"></p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript 事件</title>
    <url>/2023/02/19/JavaScript-%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>onclick</td>
<td>鼠标单击事件</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标移入事件</td>
</tr>
<tr>
<td>onmouseout</td>
<td>鼠标移出事件</td>
</tr>
<tr>
<td>onmousedown</td>
<td>鼠标按下事件</td>
</tr>
<tr>
<td>onmouseup</td>
<td>鼠标松开事件</td>
</tr>
<tr>
<td>onmousemove</td>
<td>鼠标移动事件</td>
</tr>
</tbody></table>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><table>
<thead>
<tr>
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>onkeydown</td>
<td>键盘按下</td>
</tr>
<tr>
<td>onkeyup</td>
<td>键盘松开</td>
</tr>
</tbody></table>
<h2 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h2><table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>onfocus</td>
<td>获取焦点</td>
</tr>
<tr>
<td>onblur</td>
<td>失去焦点</td>
</tr>
<tr>
<td>onselect</td>
<td>选中文本（单行文本框和多行文本框）</td>
</tr>
<tr>
<td>onchange</td>
<td>具有多个选项的表单元素</td>
</tr>
</tbody></table>
<p>支持焦点</p>
<ol>
<li>表单元素（单选框、复选框、单行文本框、多行文本框、下拉列表）</li>
<li>超链接</li>
</ol>
<p>支持 onchange</p>
<ol>
<li>单选框选择某一项时触发。</li>
<li>复选框选择某一项时触发。</li>
<li>下拉列表选择某一项时触发。</li>
</ol>
<h2 id="4-编辑事件"><a href="#4-编辑事件" class="headerlink" title="4 编辑事件"></a>4 编辑事件</h2><table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>oncopy</td>
<td>复制事件</td>
</tr>
<tr>
<td>onselectstart</td>
<td>防止被选取</td>
</tr>
<tr>
<td>oncontextmenu</td>
<td>禁止鼠标右键</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">oncopy</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello wrold&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">onselectstart</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">oncontextmenu</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-页面事件"><a href="#5-页面事件" class="headerlink" title="5 页面事件"></a>5 页面事件</h2><table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>onload</td>
<td>页面加载后调用</td>
</tr>
<tr>
<td>onunload</td>
<td>关闭窗口资源和内容是触发</td>
</tr>
<tr>
<td>beforeonload</td>
<td>浏览器关闭或者页面刷新时触发</td>
</tr>
</tbody></table>
<p>如果一个函数仅仅是定义而没有被调用的话，则函数本身是不会执行的。</p>
]]></content>
  </entry>
  <entry>
    <title>C++ 初始化列表</title>
    <url>/2023/03/25/C-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在C++中，初始化列表是一种用于初始化类成员变量的语法结构，它使用冒号（:）后跟逗号分隔的成员变量列表来定义初始化值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b), <span class="built_in">z</span>(c) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，MyClass 类的构造函数使用初始化列表来初始化成员变量 x、y 和 z。在冒号后面的成员变量列表中，每个成员变量都有对应的初始化值，这些值按照顺序与成员变量一一对应。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>更高效：初始化列表可以避免在构造函数体内进行赋值操作，提高了代码的执行效率。</li>
<li>更方便：初始化列表可以一次性对所有成员变量进行初始化，减少了代码的编写量。</li>
<li>更安全：初始化列表可以避免因成员变量未初始化而导致的不确定行为和潜在的安全问题。</li>
</ul>
<p>需要注意的是，初始化列表只能用于构造函数中，并且只能初始化成员变量，不能初始化静态成员变量或全局变量。此外，如果有多个构造函数，它们的初始化列表应该保持一致，以确保程序的正确性。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>初始化 const 成员变量：const 成员变量必须在构造函数的初始化列表中进行初始化。</li>
<li>初始化引用成员变量：引用成员变量必须在构造函数的初始化列表中进行初始化。</li>
<li>初始化类成员对象：如果类中含有其他类对象作为成员变量，那么这些对象必须在构造函数的初始化列表中进行初始化。</li>
<li>初始化基类：如果一个类有基类，那么基类的构造函数必须在构造函数的初始化列表中进行调用。</li>
<li>提高效率：使用初始化列表可以避免在构造函数体内进行赋值操作，从而提高代码的执行效率。</li>
<li>初始化数组成员变量：如果类中含有数组成员变量，那么数组也必须在构造函数的初始化列表中进行初始化</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 对象不变性</title>
    <url>/2023/02/19/JavaScript-%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%98%E6%80%A7/</url>
    <content><![CDATA[<h2 id="对象常量"><a href="#对象常量" class="headerlink" title="对象常量"></a>对象常量</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不可重新负责</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">name</span> = <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line"><span class="comment">// 不可删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="title class_">Person</span>.<span class="property">name</span></span><br><span class="line"><span class="comment">// 不可重新定义</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(<span class="title class_">Person</span>)</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">age</span> = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>) <span class="comment">// &#123;&quot;name&quot;:&quot;Alice&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(<span class="title class_">Person</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h2><p>Object.seal() 会创建一个密封的对象，这个方法实际上会在一个现有对象上调用 object.preventExtensions(…) 并把所有现有属性标记为 configurable:false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(<span class="title class_">Person</span>)</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">age</span> = <span class="number">10</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>, <span class="string">&#x27;gender&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">age</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">name</span> = <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>) <span class="comment">// &#x27;Bob&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isSealed</span>(<span class="title class_">Person</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h2><p>Object.freeze() 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal()，并把所有现有属性标记为 writable: false，这样就无法修改它们的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(<span class="title class_">Person</span>)</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">name</span> = <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>) <span class="comment">// &#x27;Alice&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(<span class="title class_">Person</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 对象判空</title>
    <url>/2023/02/19/JavaScript-%E5%AF%B9%E8%B1%A1%E5%88%A4%E7%A9%BA/</url>
    <content><![CDATA[<h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>将对象转换为字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringfy</span>(ojb) === <span class="string">&#x27;&#123;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>判断对象 key 长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span> === <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>判断对象不在原型链的属性的长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj).<span class="property">length</span> === <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h2><p>遍历字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEmpty</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isEmpty</span>(obj)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 对象合并</title>
    <url>/2023/02/19/JavaScript-%E5%AF%B9%E8%B1%A1%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h2 id="手动合并"><a href="#手动合并" class="headerlink" title="手动合并"></a>手动合并</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zs&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">13</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ls&quot;</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">obj1.<span class="property">name</span> = obj2.<span class="property">name</span>;</span><br><span class="line">obj1.<span class="property">sex</span> = obj2.<span class="property">sex</span>;</span><br></pre></td></tr></table></figure>

<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zs&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">13</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ls&quot;</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> newObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj === obj1); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj === obj2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zs&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">13</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ls&quot;</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(obj1, obj2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj === obj1); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj === obj2); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    name:&#x27;ls&#x27;,</span></span><br><span class="line"><span class="comment">//    age:13,</span></span><br><span class="line"><span class="comment">//    sex:&#x27;女&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>Object.assign()方法可以接收一个目标对象和一个或者多个源对象作为参数，如果对象中有一样的属性，后面对象的属性会覆盖掉前面对象的那个属性。</p>
<blockquote>
<p>其原理是将后面的对象通过 set 访问属性来添加进目标对象，所以最后返回的值其实就是第一个目对象，可以在目标对象上添加访问属性来见识覆盖过程</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">val1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, &#123; <span class="attr">a</span>: <span class="string">&#x27;tom&#x27;</span> &#125;, &#123; <span class="attr">a</span>: <span class="string">&#x27;jerry&#x27;</span> &#125;, &#123; <span class="attr">a</span>: <span class="string">&#x27;dog&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">//&#x27;tom&#x27;</span></span><br><span class="line"><span class="comment">//&#x27;jerry&#x27;</span></span><br><span class="line"><span class="comment">//&#x27;dog&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="手写函数"><a href="#手写函数" class="headerlink" title="手写函数"></a>手写函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">merger</span> = (<span class="params">...opts</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">combine</span> = (<span class="params">opt</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> opt) &#123;</span><br><span class="line">      <span class="keyword">if</span> (opt.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">        res[prop] = opt[prop];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//扩张运算符将两个对象合并到一个数组里，因此opts可以调用length方法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; opts.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">combine</span>(opts[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;dk&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&#x27;99&#x27;</span>,</span><br><span class="line">  <span class="attr">feature</span>: <span class="string">&#x27;stronge&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tk&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&#x27;99&#x27;</span>,</span><br><span class="line">  <span class="attr">feature1</span>: <span class="string">&#x27;noStronge&#x27;</span>,</span><br><span class="line">  <span class="attr">address</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;广州&#x27;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">      <span class="attr">city</span>: <span class="string">&#x27;深圳&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">skills</span>: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;React&#x27;</span>, <span class="string">&#x27;Node&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">merger</span>(obj1, obj2);</span><br><span class="line"></span><br><span class="line">res.<span class="property">address</span>.<span class="property">address</span>.<span class="property">city</span> = <span class="string">&#x27;杭州&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 执行过程</title>
    <url>/2023/03/25/JavaScript-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<ul>
<li>语法分析：JavaScript 引擎会对源代码进行语法分析，将其转换为抽象语法树（AST），以便进行下一步的解释执行。</li>
<li>预编译：JavaScript 引擎会对代码进行预编译，包括变量声明、函数声明等。预编译的过程中，JavaScript 引擎会将变量和函数的定义提升到当前作用域的顶部，以便后续的解释执行。</li>
<li>解释执行：JavaScript 引擎会对 AST 进行解释执行，执行过程中会根据作用域链查找变量和函数，并执行相应的操作。解释执行过程中，JavaScript 引擎还会进行垃圾回收、内存管理等操作，以确保代码的正确性和性能。</li>
<li>在解释执行过程中，JavaScript 引擎会对代码进行优化，例如使用 JIT（即时编译）技术、内联函数、去除死代码等，以提高代码的执行效率。此外，JavaScript 引擎还会进行异步操作、事件处理等，以处理与用户交互相关的操作。</li>
</ul>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 拷贝</title>
    <url>/2023/02/19/JavaScript-%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><ul>
<li>Array.prototype.concat()</li>
<li>Array.prototype.slice()</li>
<li>Array.from()</li>
<li>Object.assign()</li>
</ul>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringfy</span>())</span><br></pre></td></tr></table></figure>

<p>缺点，不能拷贝特殊对象，如 function，regex 以及循环引用会报错</p>
<h3 id="手动深拷贝"><a href="#手动深拷贝" class="headerlink" title="手动深拷贝"></a>手动深拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target ) || <span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isObject</span>(data)) &#123;</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="title class_">Date</span>, <span class="title class_">RegExp</span>].<span class="title function_">includes</span>(data.<span class="property">constructor</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> data.<span class="title function_">constructor</span>(<span class="params">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;return &#x27;</span> + data.<span class="title function_">toString</span>())()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> exist = map.<span class="title function_">get</span>(data)</span><br><span class="line">        <span class="keyword">if</span> (exist) &#123;</span><br><span class="line">            <span class="keyword">return</span> exist</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="title class_">Map</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">            map.<span class="title function_">set</span>(data, result)</span><br><span class="line">            data.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isObject</span>(val)) &#123;</span><br><span class="line">                    result.<span class="title function_">set</span>(key, <span class="title function_">clone</span>(val))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="title function_">set</span>(key, val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data <span class="keyword">instanceof</span> <span class="title class_">Set</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">            map.<span class="title function_">set</span>(data, result)</span><br><span class="line">            data.<span class="title function_">forEach</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="title function_">isObject</span>(val)) &#123;</span><br><span class="line">                    result.<span class="title function_">add</span>(<span class="title function_">clone</span>(val))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="title function_">add</span>(val)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(data)</span><br><span class="line">        <span class="keyword">const</span> allDesc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(data)</span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(data), allDesc)</span><br><span class="line">        map.<span class="title function_">set</span>(data, result)</span><br><span class="line">        keys.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> val = data[key]</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isObject</span>(val)) &#123;</span><br><span class="line">                result[key] = <span class="title function_">clone</span>(val)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[key] = val</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">clone</span>(target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="structuredClone"><a href="#structuredClone" class="headerlink" title="structuredClone"></a>structuredClone</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">name</span>: <span class="string">&#x27;MDN&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> clone = <span class="title function_">structuredClone</span>(original)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(clone)</span><br></pre></td></tr></table></figure>

<p>支持循环引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">name</span>: <span class="string">&#x27;MDN&#x27;</span> &#125;</span><br><span class="line">original.<span class="property">_itself</span> = original</span><br><span class="line"><span class="keyword">const</span> clone = <span class="title function_">structuredClone</span>(original)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(clone)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 类型检测</title>
    <url>/2023/02/19/JavaScript-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>typeof 会返回六种类型</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> “number”</li>
<li><input checked="" disabled="" type="checkbox"> “string”</li>
<li><input checked="" disabled="" type="checkbox"> “boolean”</li>
<li><input checked="" disabled="" type="checkbox"> “object”</li>
<li><input checked="" disabled="" type="checkbox"> “function”</li>
<li><input checked="" disabled="" type="checkbox"> “undefined”</li>
</ul>
<p>typeof 遇 null 会返回 object</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">type</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (o === <span class="literal">null</span>) ? <span class="string">&quot;null&quot;</span> : <span class="keyword">typeof</span> (o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>typeof 不能检测复杂数据类型，如正则表达式、日期对象、数学对象等</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><table>
<thead>
<tr>
<th>值</th>
<th>typeof</th>
<th>constructor</th>
</tr>
</thead>
<tbody><tr>
<td>let value = 1</td>
<td>“number”</td>
<td>Number</td>
</tr>
<tr>
<td>let value = “a”</td>
<td>“string”</td>
<td>String</td>
</tr>
<tr>
<td>let value = true</td>
<td>“boolean”</td>
<td>Boolean</td>
</tr>
<tr>
<td>let value = {}</td>
<td>“object”</td>
<td>Object</td>
</tr>
<tr>
<td>let value = new Object()</td>
<td>“object”</td>
<td>Object</td>
</tr>
<tr>
<td>let value = []</td>
<td>“object”</td>
<td>Array</td>
</tr>
<tr>
<td>let value = new Array()</td>
<td>“object”</td>
<td>Array</td>
</tr>
<tr>
<td>let value = function(){}</td>
<td>“function”</td>
<td>Function</td>
</tr>
<tr>
<td>function className(){}</td>
<td>“object”</td>
<td>className</td>
</tr>
</tbody></table>
<p>获取对象唯一的 class 必须调用 Object 默认的 toString() 方法，因为不同对象都会定义自己的 toString() 方法</p>
<p>对于 null 和 undefined，constructor 会抛出异常</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">type</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> o &amp;&amp; o.<span class="property">constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整类型检测方法"><a href="#完整类型检测方法" class="headerlink" title="完整类型检测方法"></a>完整类型检测方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">typeOf</span> = (<span class="params">o</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> _toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span></span><br><span class="line">  <span class="keyword">const</span> _type = &#123;</span><br><span class="line">    <span class="string">&quot;undefined&quot;</span>: <span class="string">&quot;undefined&quot;</span>,</span><br><span class="line">    <span class="string">&quot;number&quot;</span>: <span class="string">&quot;number&quot;</span>,</span><br><span class="line">    <span class="string">&quot;boolean&quot;</span>: <span class="string">&quot;boolean&quot;</span>,</span><br><span class="line">    <span class="string">&quot;string&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[object Function]&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[object RegExp]&quot;</span>: <span class="string">&quot;regexp&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[object Array]&quot;</span>: <span class="string">&quot;array&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[object Date]&quot;</span>: <span class="string">&quot;date&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[object Error]&quot;</span>: <span class="string">&quot;error&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[object Math]&quot;</span>: <span class="string">&quot;math&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[object Object]&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[object HTMLDocument]&quot;</span>: <span class="string">&quot;htmldocument&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[object global]&quot;</span>: <span class="string">&quot;window&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _type[<span class="keyword">typeof</span> o] || _type[_toString.<span class="title function_">call</span>(o)] || (o ? <span class="string">&quot;object&quot;</span> : <span class="string">&quot;null&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单独类型检测"><a href="#单独类型检测" class="headerlink" title="单独类型检测"></a>单独类型检测</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isUndefined</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj === <span class="built_in">void</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isNull</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj === <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isBoolean</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">typeof</span>(obj) === <span class="string">&#x27;boolean&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isNumber</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">typeof</span>(obj) === <span class="string">&#x27;number&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isString</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">typeof</span>(obj) === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isArray</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="property">isArray</span>?<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj):<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFunction</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">typeof</span>(obj) === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isDate</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isRegExp</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isError</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isArguments</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj) === <span class="string">&#x27;[object Arguments]&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 类数组</title>
    <url>/2023/02/19/JavaScript-%E7%B1%BB%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><ul>
<li>Object.prototype.toString.call 返回 [object arguments]，代表不是数组</li>
<li>具有 length 属性</li>
<li>在严格模式下，剩余参数、默认参数和解构赋值参数的存在不会改变 arguments对象的行为，但是在非严格模式下会改变</li>
</ul>
<h2 id="用-getElementsByTagName-Classname-Name-获得的-HTMLCollection"><a href="#用-getElementsByTagName-Classname-Name-获得的-HTMLCollection" class="headerlink" title="用 getElementsByTagName/Classname/Name 获得的 HTMLCollection"></a>用 getElementsByTagName/Classname/Name 获得的 HTMLCollection</h2><ul>
<li>Object.prototype.toString.call 返回 [object HTMLFormElement]，代表不是数组</li>
<li>HTML DOM 对象的一个接口，包含获取到的 DOM 元素集合类</li>
<li>DOM 更新时会实时更新</li>
</ul>
<h2 id="用-querySelector-获得的-NodeList"><a href="#用-querySelector-获得的-NodeList" class="headerlink" title="用 querySelector 获得的 NodeList"></a>用 querySelector 获得的 NodeList</h2><ul>
<li>Object.prototype.toString.call 返回 [object NodeList]，代表不是数组实时更新</li>
<li>DOM 更新时会实时更新</li>
</ul>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 遍历</title>
    <url>/2023/02/19/JavaScript-%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>,len=arr.<span class="property">length</span>; j &lt; len; j++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value, index, arr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h2><h3 id="遍历键"><a href="#遍历键" class="headerlink" title="遍历键"></a>遍历键</h3><p>数组对象都能遍历，不一定是按顺序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arra) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历原型"><a href="#遍历原型" class="headerlink" title="遍历原型"></a>遍历原型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="function">() =&gt;</span> &#123; &#125;</span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> array) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="function">() =&gt;</span> &#123; &#125;</span><br><span class="line"><span class="keyword">const</span> object = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">test</span> = <span class="function">() =&gt;</span> &#123; &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params"></span>) =&gt; &#123; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> func) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果存在循环依赖，会产生死循环</p>
<h2 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h2><p>可遍历 Array，String，TypedArray，Set，Map</p>
<h3 id="遍历-Array"><a href="#遍历-Array" class="headerlink" title="遍历 Array"></a>遍历 Array</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [value, index] <span class="keyword">of</span> array.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> array.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> array.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = <span class="string">&quot;boo&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0x00</span>, <span class="number">0xff</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&quot;a&quot;</span>, <span class="number">1</span>], [<span class="string">&quot;b&quot;</span>, <span class="number">2</span>], [<span class="string">&quot;c&quot;</span>, <span class="number">3</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;a&quot;, 1]</span></span><br><span class="line"><span class="comment">// [&quot;b&quot;, 2]</span></span><br><span class="line"><span class="comment">// [&quot;c&quot;, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历-Set"><a href="#遍历-Set" class="headerlink" title="遍历 Set"></a>遍历 Set</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历生成器"><a href="#遍历生成器" class="headerlink" title="遍历生成器"></a>遍历生成器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">of</span> gen) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(o);</span><br><span class="line">  <span class="keyword">break</span>;<span class="comment">// 关闭生成器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器不应该重用，以下没有意义！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">of</span> gen) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他迭代对象"><a href="#其他迭代对象" class="headerlink" title="其他迭代对象"></a>其他迭代对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iterable = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">i</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">i</span> &lt; <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">i</span>++, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>它使用 hasOwnProperty() ，所以不能遍历原型</p>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">filter</span>(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p>有一个满足就返回 true，否则返回 false，在 return true 时结束循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;买笔&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;买笔记本&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;练字&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bool = arr.<span class="title function_">some</span>(<span class="keyword">function</span> (<span class="params">item, index</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> item.<span class="property">done</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bool);</span><br></pre></td></tr></table></figure>

<h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p>所有满足才返回 true，否则返回 false，在 return false 时结束循环，在一循环没有返回 true 则视为返回 false</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;买笔&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;买笔记本&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;练字&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bool = arr.<span class="title function_">every</span>(<span class="keyword">function</span> (<span class="params">item, index</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> item.<span class="property">done</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bool);</span><br></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>找到满足的第一个元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = arr.<span class="title function_">find</span>(<span class="keyword">function</span> (<span class="params">item, index</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> item === <span class="number">3</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br></pre></td></tr></table></figure>

<h2 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h2><p>找到满足的第一个元素的索引</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = arr.<span class="title function_">findIndex</span>(<span class="keyword">function</span> (<span class="params">item, index</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> item === <span class="number">3</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br></pre></td></tr></table></figure>

<h2 id="reduce、reduceRight"><a href="#reduce、reduceRight" class="headerlink" title="reduce、reduceRight"></a>reduce、reduceRight</h2><p>reduce 方法接收两个参数，第一个参数是回调函数（callback） ，第二个参数是初始值（initialValue）。</p>
<p>reduceRight 方法除了与 reduce 执行方向相反外（从右往左），其他完全与其一致。</p>
<p>回调函数接收四个参数：</p>
<ul>
<li>accumulator：MDN 上解释为累计器，但我觉得不恰当，按我的理解它应该是截至当前元素，之前所有的数组元素被回调函数处理累计的结果。</li>
<li>current：当前被执行的数组元素。</li>
<li>currentIndex：当前被执行的数组元素索引。</li>
<li>sourceArray：原数组，也就是调用 reduce 方法的数组。</li>
</ul>
<p>如果不传入初始值，reduce 方法会从索引 1 开始执行回调函数，如果传入初始值，将从索引 0 开始、并从初始值的基础上累计执行回调。</p>
<h3 id="累加"><a href="#累加" class="headerlink" title="累加"></a>累加</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list  = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;left&#x27;</span>, <span class="attr">width</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;center&#x27;</span>, <span class="attr">width</span>: <span class="number">70</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;right&#x27;</span>, <span class="attr">width</span>: <span class="number">10</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> total = list.<span class="title function_">reduce</span>(<span class="function">(<span class="params">currentTotal, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> currentTotal + item.<span class="property">width</span>;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// total: 100</span></span><br></pre></td></tr></table></figure>

<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list  = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;left&#x27;</span>, <span class="attr">width</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;right&#x27;</span>, <span class="attr">width</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;center&#x27;</span>, <span class="attr">width</span>: <span class="number">70</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;right&#x27;</span>, <span class="attr">width</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;left&#x27;</span>, <span class="attr">width</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;right&#x27;</span>, <span class="attr">width</span>: <span class="number">10</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> repeatTime = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> result = list.<span class="title function_">reduce</span>(<span class="function">(<span class="params">array, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (repeatTime[item.<span class="property">name</span>]) &#123;</span><br><span class="line">    repeatTime[item.<span class="property">name</span>]++;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br><span class="line">  repeatTime[item.<span class="property">name</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> [...array, item];</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<h3 id="计算最值"><a href="#计算最值" class="headerlink" title="计算最值"></a>计算最值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list  = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;left&#x27;</span>, <span class="attr">width</span>: <span class="number">20</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;right&#x27;</span>, <span class="attr">width</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;center&#x27;</span>, <span class="attr">width</span>: <span class="number">70</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;top&#x27;</span>, <span class="attr">width</span>: <span class="number">40</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;bottom&#x27;</span>, <span class="attr">width</span>: <span class="number">20</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> max = list.<span class="title function_">reduce</span>(<span class="function">(<span class="params">curItem, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> curItem.<span class="property">width</span> &gt;= item.<span class="property">width</span> ? curItem : item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> min = list.<span class="title function_">reduce</span>(<span class="function">(<span class="params">curItem, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> curItem.<span class="property">width</span> &lt;= item.<span class="property">width</span> ? curItem : item;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h2><table>
<thead>
<tr>
<th></th>
<th>break</th>
<th>continue</th>
<th>return</th>
</tr>
</thead>
<tbody><tr>
<td>for</td>
<td>终止 ✔️</td>
<td>跳出本次循环✔️</td>
<td>❌</td>
</tr>
<tr>
<td>forEach</td>
<td>❌ ️</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>map</td>
<td>❌ ️</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>for…of…</td>
<td>终止 ✔️</td>
<td>跳出本次循环 ✔️</td>
<td>❌</td>
</tr>
<tr>
<td>for…in…</td>
<td>终止 ✔️</td>
<td>跳出本次循环 ✔️</td>
<td>❌</td>
</tr>
<tr>
<td>some</td>
<td>❌️</td>
<td>❌</td>
<td>return true ✔️</td>
</tr>
<tr>
<td>every</td>
<td>❌️</td>
<td>❌</td>
<td>return false ✔️</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 闭包</title>
    <url>/2023/02/07/JavaScript-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="闭包使用"><a href="#闭包使用" class="headerlink" title="闭包使用"></a>闭包使用</h2><h3 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">father</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">son</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    t = t + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">son</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="title function_">father</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m);</span><br></pre></td></tr></table></figure>

<h3 id="正确示范"><a href="#正确示范" class="headerlink" title="正确示范"></a>正确示范</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">father</span>(<span class="params">t</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">son</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (t = t + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="title function_">father</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">m</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">m</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">m</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">m</span>());</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">father</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">son</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    t = t + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="title function_">father</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">m</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">m</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">m</span>());</span><br></pre></td></tr></table></figure>

<h2 id="循环中创建闭包"><a href="#循环中创建闭包" class="headerlink" title="循环中创建闭包"></a>循环中创建闭包</h2><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  arr[i] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="title function_">i</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这五个闭包在循环中被创建，但他们共享了同一个词法作用域，在这个作用域中存在一个变量 i。这是因为变量 i 使用 var 进行声明，由于变量提升，所以具有函数作用域。当数组赋值时，i 的值被决定。由于循环在数组赋值之前早已执行完毕，变量对象 i（被五个闭包所共享）已经指向了 i 的最后一项。</p>
</blockquote>
<h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  arr[i] = (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  arr[i] = <span class="title function_">test</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="title function_">i</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包-this-指向"><a href="#闭包-this-指向" class="headerlink" title="闭包 this 指向"></a>闭包 this 指向</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">foo</span> = <span class="string">&quot;3&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">func</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">foo</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(self.<span class="property">foo</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">foo</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(self.<span class="property">foo</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">myObject.<span class="title function_">func</span>()();</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux hook</title>
    <url>/2023/03/31/Linux-hook/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，Hook 是一种机制，可以在内核中的某些关键点注入代码，用于拦截、处理或修改内核的行为。在 Linux 内核中，Hook 通常被称为钩子（Hook）或者拦截器（Interceptor），主要包括以下几种：</p>
<ul>
<li>系统调用钩子（System Call Hook）：用于拦截和修改系统调用，可以实现对系统调用的监视和过滤。</li>
<li>网络钩子（Netfilter Hook）：用于拦截和处理进出Linux内核的网络数据包，可以实现网络安全、网络流量控制等功能。</li>
<li>内存钩子（Memory Hook）：用于拦截和修改内存管理函数，可以实现内存监视、内存泄漏检测等功能。</li>
<li>文件系统钩子（Filesystem Hook）：用于拦截和修改文件系统的行为，可以实现文件访问控制、文件系统监视等功能。</li>
<li>模块钩子（Module Hook）：用于拦截和处理内核模块的加载和卸载，可以实现内核模块的监视和管理。</li>
</ul>
<p>Hook 机制可以为系统提供更高的灵活性和可扩展性，可以实现各种自定义的功能和扩展。但是，Hook 机制也带来了一些安全风险，如果 Hook 的代码存在漏洞或恶意代码，可能会导致系统崩溃或被攻击者利用。因此，在使用 Hook 机制时需要谨慎，并遵循最佳实践。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下的 QEvent 实现</title>
    <url>/2023/03/30/Linux-%E4%B8%8B%E7%9A%84-QEvent-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在 Linux 系统中，Qt 通过 X11 协议和系统窗口管理器交互，实现 GUI 应用程序的显示和事件处理。具体来说，Qt 使用 Xlib 库和 XCB 库与 X11 服务器通信，使用 X11 窗口系统 API 创建和管理窗口，使用 X11 事件系统处理 GUI 事件。</p>
<p>在 Qt 中，QEventLoop 类是事件循环的核心，它通过 X11 事件队列（X11 event queue）接收和分发事件。当一个事件到达事件队列时，QEventLoop 会检查该事件是否与当前正在处理的事件相同，如果相同则直接处理；否则，QEventLoop 会将该事件发送给适当的接收者（QObject 对象），或者将其放入事件过滤器（QEventFilter）进行拦截和处理。</p>
<p>在 Linux 下，Qt 还提供了一些与 X11 事件系统相关的类和函数，如 QX11Info 类、QX11EmbedWidget 类、QX11EmbedContainer 类、QX11EmbedManager 类等，用于实现X11窗口和Qt窗口的交互、嵌入和管理。</p>
<p>总的来说，Qt 在 Linux 系统中实现 GUI 应用程序的显示和事件处理，主要依赖于 X11 协议和窗口系统 API。通过 QEventLoop 类和 X11 事件队列，Qt 能够接收和分发各种 GUI 事件，从而实现应用程序的交互和响应。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内存分布情况</title>
    <url>/2023/03/31/Linux-%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>内核空间（Kernel Space）：内核空间是操作系统内核运行的区域，通常占用了系统的前 1GB 内存空间。这个区域包括操作系统内核代码、驱动程序、中断向量表等。</li>
<li>用户空间（User Space）：用户空间是用户应用程序运行的区域，通常占用了系统剩余的内存空间。这个区域包括用户应用程序代码、数据、堆栈等。</li>
<li>缓存（Cache）：缓存是用于加速文件系统访问的一种内存区域，通常包括文件系统缓存、页缓存等。这个区域会根据系统的需要动态调整大小，当系统内存不足时，缓存会被释放。</li>
<li>共享内存（Shared Memory）：共享内存是一种特殊的内存区域，用于不同进程之间进行通信。共享内存通常使用 mmap 系统调用实现。</li>
<li>内存映射文件（Memory-Mapped File）：内存映射文件是一种特殊的文件访问方式，将文件映射到内存中，以加快文件的访问速度。内存映射文件通常使用 mmap 系统调用实现。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内核和 Windows 内核区别</title>
    <url>/2023/03/30/Linux-%E5%86%85%E6%A0%B8%E5%92%8C-Windows-%E5%86%85%E6%A0%B8%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Linux 内核和 Windows 内核是两个不同的操作系统内核，它们有许多不同之处，主要包括以下几个方面：</p>
<ul>
<li>开源和闭源：Linux 内核是开源的，任何人都可以查看和修改其源代码；而 Windows 内核是闭源的，只有微软公司才能查看和修改其源代码。</li>
<li>架构：Linux 内核是基于 Unix 的设计，采用的是分层架构，将内核分为不同的层次，每层都有自己的职责和功能；而 Windows 内核则采用的是单内核架构，它将所有的功能都集成在一个核心中。</li>
<li>设备驱动：Linux 内核支持大量的设备驱动程序，包括网络设备、存储设备、输入设备等；而 Windows 内核则支持相对较少的设备驱动程序，大部分设备驱动都是由第三方开发商提供的。</li>
<li>内存管理：Linux 内核采用的是基于页面的虚拟内存管理机制，可以更好地管理内存资源；而 Windows 内核则采用的是基于段的虚拟内存管理机制。</li>
<li>安全性：Linux 内核强调安全性和稳定性，支持许多安全机制，如 SELinux、AppArmor 等；而 Windows 内核则强调易用性和应用程序的兼容性。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 查看端口占用</title>
    <url>/2023/02/19/Linux-%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8/</url>
    <content><![CDATA[<h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof -i:端口号</span><br><span class="line"></span><br><span class="line">lsof abc.txt：显示开启文件abc.txt的进程</span><br><span class="line"></span><br><span class="line">lsof -c abc：显示abc进程现在打开的文件</span><br><span class="line"></span><br><span class="line">lsof -c -p 1234：列出进程号为1234的进程所打开的文件</span><br><span class="line"></span><br><span class="line">lsof -g gid：显示归属gid的进程情况</span><br><span class="line"></span><br><span class="line">lsof +d /usr/local/：显示目录下被进程开启的文件</span><br><span class="line"></span><br><span class="line">lsof +D /usr/local/：同上，但是会搜索目录下的目录，时间较长</span><br><span class="line"></span><br><span class="line">lsof -d 4：显示使用fd为4的进程</span><br><span class="line"></span><br><span class="line">lsof -i -U：显示所有打开的端口和UNIX domain文件</span><br></pre></td></tr></table></figure>

<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tunlp 用于显示 tcp，udp 的端口和进程等相关情况。</span><br><span class="line"></span><br><span class="line">netstat 查看端口占用语法格式：</span><br><span class="line"></span><br><span class="line">netstat -tunlp | grep 端口号</span><br></pre></td></tr></table></figure>

<ul>
<li>-t (tcp) 仅显示tcp相关选项</li>
<li>-u (udp)仅显示udp相关选项</li>
<li>-n 拒绝显示别名，能显示数字的全部转化为数字</li>
<li>-l 仅列出在Listen(监听)的服务状态</li>
<li>-p 显示建立相关链接的程序名</li>
</ul>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep 端口号</span><br></pre></td></tr></table></figure>

<h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Linux 进程</title>
    <url>/2023/03/31/Linux-%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Linux中，进程是指正在运行的程序实例。每个进程都有自己的内存空间和资源，可以独立运行和终止。在 Linux 中，每个进程都有一个唯一的进程标识符（PID），用于标识进程的身份。</p>
<p>Linux进程可以分为前台进程和后台进程两种类型。前台进程是指在终端中直接运行的进程，会占据终端的输入输出，并在终端关闭时自动结束。后台进程是指在终端中以非交互方式运行的进程，会在后台运行而不会占据终端的输入输出。</p>
<p>Linux进程的管理包括查看进程信息、结束进程、启动新进程等操作。可以通过命令行工具 ps、top、htop 等来查看进程信息，通过 kill 命令来结束进程，通过 nohup 命令来启动新的后台进程。</p>
<p>在Linux中，进程间通信是非常重要的功能之一。进程间可以通过共享内存、消息队列、信号量、管道等方式进行通信和数据交换。这些通信方式可以实现不同进程之间的协作和协同工作，从而实现更加复杂的应用程序和系统。</p>
<h2 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h2><p>在 Linux 中，每个进程都有一个独立的进程描述符（Process Descriptor），它包含了进程的所有信息，如进程 ID、父进程 ID、进程状态、进程优先级、进程资源限制、进程的代码、数据和堆栈段等。进程描述符保存在系统内核的进程表中，可以通过系统调用和内核函数来访问和操作。</p>
<p>Linux 中的进程信息可以通过 /proc 文件系统进行访问和查看。/proc 目录下的每个子目录都对应一个进程的进程 ID，子目录中包含了进程描述符的各种信息，如进程状态、进程命令行参数、进程的打开文件等。可以使用 cat 命令、ps 命令、top 命令等工具来查看进程的信息，也可以直接读取 /proc 目录下的信息文件来获取进程信息。</p>
<p>除了 /proc 文件系统外，Linux 中还提供了一些系统调用和库函数，例如通过系统调用 getpid、getppid、getpriority、waitpid 等可以获取进程的 ID、父进程 ID、优先级和等待子进程结束等信息。通过内核函数 schedule、fork、exec 等可以实现进程的调度、创建和执行等操作。</p>
<p>在 Linux 中，进程信息保存在内核的进程表中，可以通过系统调用和内核函数来访问和操作。进程表中包含了所有进程的信息，包括进程 ID、进程状态、CPU 占用率、内存占用等，</p>
<h2 id="进程链"><a href="#进程链" class="headerlink" title="进程链"></a>进程链</h2><p>在 Linux 中，进程链（Process Chain）是指父进程和其直接或间接创建的所有子进程之间的关系链。每个进程都有一个父进程，除了 init 进程之外，它是所有进程的祖先进程。</p>
<p>进程链的特点是每个子进程只有一个父进程，而每个父进程可以有多个子进程。在进程链中，子进程可以继承父进程的一些属性，如用户 ID、组 ID、环境变量等，也可以通过管道、共享内存等方式与其它进程通信。</p>
<p>Linux 中的进程链可以通过命令行工具 ps 和 pstree 进行查看。ps 命令可以列出当前所有进程的信息，包括进程 ID、进程状态、CPU 占用率、内存占用等信息。pstree 命令则可以以树状结构形式显示进程链的关系，便于用户直观地了解进程之间的关系。</p>
<p>在 Linux中，通过进程链可以实现进程管理、进程间通信、进程间协作等功能。进程链可以用于实现父进程与子进程之间的数据共享和通信，也可以用于实现进程的协作和协同工作。</p>
<h2 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h2><p>在 Linux 系统中，进程表（Process Table）是内核维护的一个数据结构，用于存储系统中所有进程的信息。进程表中记录了每个进程的进程 ID、父进程 ID、进程状态、进程优先级、进程资源使用状况以及进程的代码、数据、堆栈段、打开文件、共享内存、消息队列等信息。通过访问进程表，可以实现对进程的管理、监控和通信等操作。</p>
<p>进程表是 Linux 系统中进程管理的核心，它是内核对进程的管理和调度的基础。通过进程表，内核可以有效地管理和控制系统中的所有进程，实现进程的创建、运行、结束和资源分配等功能。</p>
<p>在 Linux 系统中，进程表是一个动态的数据结构，它会随着进程的创建和结束而动态地改变。当一个进程被创建时，内核会在进程表中为其分配一个唯一的进程 ID，并初始化其进程表项。当进程结束时，内核会从进程表中删除其进程表项，并释放相关资源。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Mat 和 Image 转换</title>
    <url>/2023/05/07/Mat-%E5%92%8C-Image-%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>Image 转 Mat</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line">from PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy  </span><br><span class="line">  </span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;plane.jpg&quot;</span>)  </span><br><span class="line">image.<span class="built_in">show</span>()  </span><br><span class="line">img = cv2.<span class="built_in">cvtColor</span>(numpy.<span class="built_in">asarray</span>(image),cv2.COLOR_RGB2BGR)  </span><br><span class="line">cv2.<span class="built_in">imshow</span>(<span class="string">&quot;OpenCV&quot;</span>,img)  </span><br><span class="line">cv2.<span class="built_in">waitKey</span>()  </span><br></pre></td></tr></table></figure>

<p>cv2保存图片用cv2.imwrite(“/home/1.jpg” ,frame * 1) # <em>1才为彩色,后面</em>1可以不写<br>cv2看图片大小用 img.shape # 它的输出是(480, 640, 3)，记住这里宽是480,长是640，深度是3色的彩色<br>cv2裁剪用img = img[60:420, 60:580, :] #eg:[宽为60~（480-60），长为60～（640-60),第三个是选择全部深度]</p>
<p>Mat 转 Image</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line">from PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy  </span><br><span class="line">  </span><br><span class="line">img = cv2.<span class="built_in">imread</span>(<span class="string">&quot;plane.jpg&quot;</span>)  </span><br><span class="line">cv2.<span class="built_in">imshow</span>(<span class="string">&quot;OpenCV&quot;</span>,img)  </span><br><span class="line">image = Image.<span class="built_in">fromarray</span>(cv2.<span class="built_in">cvtColor</span>(img,cv2.COLOR_BGR2RGB))  </span><br><span class="line">image.<span class="built_in">show</span>()  </span><br><span class="line">cv2.<span class="built_in">waitKey</span>() </span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>MySQL 存储过程</title>
    <url>/2023/04/08/MySQL-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 定时任务</title>
    <url>/2023/04/08/MySQL-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="事件功能介绍"><a href="#事件功能介绍" class="headerlink" title="事件功能介绍"></a>事件功能介绍</h2><p>MySQL Event 是 MySQL 数据库的一种事件调度器，可以用来执行定时任务。它可以周期性地执行某个 SQL 语句或者调用某个存储过程，也可以一次性地执行一些任务。使用 MySQL Event 可以方便地实现一些常见的定时任务，如数据备份、数据统计、定时清理等。它的使用方法类似于 Linux 中的 cron 定时任务，但是比 cron 更灵活，可以执行更复杂的任务。</p>
<h2 id="开启事件功能"><a href="#开启事件功能" class="headerlink" title="开启事件功能"></a>开启事件功能</h2><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE <span class="string">&#x27;event_scheduler&#x27;</span>;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">SELECT @@event_scheduler;</span><br><span class="line"></span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| event_scheduler | OFF   |</span><br><span class="line">+-----------------+-------+</span><br></pre></td></tr></table></figure>

<h3 id="开启-关闭功能"><a href="#开启-关闭功能" class="headerlink" title="开启/关闭功能"></a>开启/关闭功能</h3><p>开启功能命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET GLOBAL event_scheduler = 1;</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">SET GLOBAL event_scheduler = ON;</span><br></pre></td></tr></table></figure>

<p>关闭功能命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET GLOBAL event_scheduler = 0;</span><br><span class="line">SET GLOBAL event_scheduler = OFF;</span><br></pre></td></tr></table></figure>

<h2 id="事件功能说明"><a href="#事件功能说明" class="headerlink" title="事件功能说明"></a>事件功能说明</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EVENT [IFNOT <span class="keyword">EXISTS</span>] event_name</span><br><span class="line">    　　 <span class="keyword">ON</span> SCHEDULE schedule(调度时间设置)</span><br><span class="line">    　　 [<span class="keyword">ON</span> COMPLETION [<span class="keyword">NOT</span>] PRESERVE]</span><br><span class="line">    　　 [ENABLE <span class="operator">|</span> DISABLE <span class="operator">|</span> DISABLE <span class="keyword">ON</span> SLAVE]</span><br><span class="line">    　　 [COMMENT <span class="string">&#x27;comment&#x27;</span>]</span><br><span class="line">    　　 DO sql_statement;</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><table>
<thead>
<tr>
<th>SQL 语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINER</td>
<td>可选项，给指定用户使用权限</td>
</tr>
<tr>
<td>IF NOT EXISTS</td>
<td>可选项，用于判断要创建的事件是否存在</td>
</tr>
<tr>
<td>EVENT event_name</td>
<td>必选项，指定事件名称，event_name 的最大长度为 64 个字符，如果为指定 event_name，则默认为当前的 MySQL 用户名（不区分大小写）</td>
</tr>
<tr>
<td>ON SCHEDULE schedule</td>
<td>必选项，这里的 schedule 用于定义执行的时间和时间间隔，在下面我们详细讲解</td>
</tr>
<tr>
<td>ON COMPLETION [NOT] PRESERVE</td>
<td>可选项，配置事件执行完一次后的处理方式：<br/> 当为 on completion preserve 的时候,当event 到期了,event 会被 disable,但是该 event 还是会存在<br/>当为 on completion not preserve 的时候，当 event 到期的时候,该 event 会被自动删除掉</td>
</tr>
<tr>
<td>ENABLE、DISABLE、DISABLE ON SLAVE</td>
<td>可选项，用于指定事件的一种属性。<br/>ENABLE 表示该事件是开启的，也就是调度器检查事件是否必选调用；<br/>DISABLE 表示该事件是关闭的，也就是事件的声明存储到目录中，但是调度器不会检查它是否应该调用；<br/>DISABLE ON SLAVE 表示事件在从机中是关闭的。如果不指定这三个选择中的任意一个，则在一个事件创建之后，它立即变为活动的。</td>
</tr>
<tr>
<td>COMMENT ‘comment’</td>
<td>可选项，用于定义事件的注释</td>
</tr>
<tr>
<td>DO event_body</td>
<td>必选项，用于指定事件启动时所要执行的代码。可以是任何有效的SQL语句、存储过程或者一个计划执行的事件。如果包含多条语句，可以使用BEGIN…END复合结构</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> event if <span class="keyword">not</span> <span class="keyword">EXISTS</span> insert_clock_event </span><br><span class="line"><span class="keyword">on</span> schedule <span class="keyword">every</span> <span class="number">1</span> <span class="keyword">DAY</span> STARTS <span class="type">date</span>(<span class="built_in">CURRENT_DATE</span><span class="operator">+</span><span class="number">1</span>) </span><br><span class="line"><span class="keyword">on</span> completion preserve  do <span class="keyword">call</span> insert_clock(); </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 锁</title>
    <url>/2023/03/28/MySQL-%E9%94%81/</url>
    <content><![CDATA[<h2 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><h2 id="粒度分类"><a href="#粒度分类" class="headerlink" title="粒度分类"></a>粒度分类</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h3 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h3><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><h2 id="属性分类"><a href="#属性分类" class="headerlink" title="属性分类"></a>属性分类</h2><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><h2 id="状态分类"><a href="#状态分类" class="headerlink" title="状态分类"></a>状态分类</h2><h3 id="意向共享锁"><a href="#意向共享锁" class="headerlink" title="意向共享锁"></a>意向共享锁</h3><h3 id="意向排他锁"><a href="#意向排他锁" class="headerlink" title="意向排他锁"></a>意向排他锁</h3><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><h3 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h3>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Netfilter</title>
    <url>/2023/03/31/Netfilter/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Netfilter是Linux内核中的一个网络数据包过滤框架，它可以拦截和处理进出Linux内核的网络数据包，实现网络安全、网络流量控制等功能。Netfilter提供了一组钩子（Hook）机制，可以在数据包经过不同的网络协议栈阶段时插入不同的处理函数。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>数据包过滤：可以根据各种规则，如IP地址、端口号、协议类型等，对进出 Linux 内核的网络数据包进行过滤。</li>
<li>NAT（Network Address Translation）：可以将私有 IP 地址转换为公有 IP 地址，实现内部网络与外部网络之间的通信。</li>
<li>防火墙：可以阻止未经授权的数据包进入内部网络，保护系统免受攻击。</li>
<li>流量控制：可以对进出网络的流量进行限制和控制，以避免网络拥塞和资源浪费。</li>
<li>Netfilter 的用户空间工具为 iptables，它可以通过命令行配置 Netfilter 的规则，实现上述功能。iptables 可以对进入和离开系统的数据包进行处理，支持多种匹配模式和动作。</li>
<li>Netfilter 是一个强大的网络过滤框架，可以实现各种网络安全和网络流量控制功能。但是，由于它是在内核中实现的，配置和使用比较复杂，需要一定的技术水平。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV 编译（包含 Contrib 模块）</title>
    <url>/2023/02/18/OpenCV-%E7%BC%96%E8%AF%91%EF%BC%88%E5%8C%85%E5%90%AB-Contrib-%E6%A8%A1%E5%9D%97%EF%BC%89/</url>
    <content><![CDATA[<h2 id="OpenCV-下载"><a href="#OpenCV-下载" class="headerlink" title="OpenCV 下载"></a>OpenCV 下载</h2><p>下载地址 <a href="https://opencv.org/releases/">https://opencv.org/releases/</a></p>
<p><img src="/img/uTools_1676785638590.png" alt="OpenCV"></p>
<p>点击 source 下载</p>
<h2 id="OpenCV-Contrib-下载"><a href="#OpenCV-Contrib-下载" class="headerlink" title="OpenCV-Contrib 下载"></a>OpenCV-Contrib 下载</h2><p>下载地址 <a href="https://www.raoyunsoft.com/opencv/opencv_contrib/">https://www.raoyunsoft.com/opencv/opencv_contrib/</a></p>
<p><img src="/img/uTools_1676786045142.png" alt="OpenCV-Contrib"></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>首先打开 cmake-gui</p>
<p><img src="/img/uTools_1676787496973.png" alt="cmake-gui"></p>
<p>点击 configure，选择 Visual Studio 2019，点击 Finish</p>
<p><img src="/img/uTools_1676787614494.png" alt="cmake-gui"></p>
<p>添加 contrib 模块（如果要编译 QT，确保 QT 的 cmake 目录在环境变量里，并勾选 WITH_QT）</p>
<p><img src="/img/uTools_1676788578088.png" alt="contrib"></p>
<p>点击 configure，确保没有红色之后点击 generate</p>
<p><img src="/img/uTools_1676788387531.png" alt="cmake-gui"></p>
<p>点击 open project，右键解决方案</p>
<p><img src="/img/uTools_1676788731713.png" alt="解决方案"></p>
<p>选择批生成，勾选 ALL_BUILD 和 INSTALL，选择生成</p>
<p><img src="/img/uTools_1676788846834.png" alt="批生成"></p>
<p>编译成功后在 build/install 目录可有看到生成的文件</p>
<h2 id="configure-过程中爆红"><a href="#configure-过程中爆红" class="headerlink" title="configure 过程中爆红"></a>configure 过程中爆红</h2><p>由于网速原因，一些模块无法下载，需要按照以下方式下载</p>
<ul>
<li>对于常见的如 ffmpeg，需要通过添加代理，并需要把 <code>raw.githubusercontent.com</code> 的 <code>IP</code> 地址添加到系统 <code>hosts</code> 文件中去</li>
<li>有些下载地址已经改变，根据错误文件提示找到对于 cmake 文件路径，替换 cmake 中的下载路径（原目录跟新目录比较接近）</li>
<li>前两种方法都无法解决，用方法 2 找到正确的下载路径并下载，参照 .cache 目录（前两种方法生成）中的添加方式去添加，注意要根据电脑系统设置正确的 hash</li>
</ul>
]]></content>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV 面具覆盖</title>
    <url>/2023/02/09/OpenCV-%E9%9D%A2%E5%85%B7%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QImage <span class="title">DetectThread::toQImage</span><span class="params">(cv::Mat src)</span></span>&#123;</span><br><span class="line">    cv::Mat dst;</span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(src, dst, cv::COLOR_BGR2RGB);</span><br><span class="line">    <span class="function">QImage <span class="title">img</span><span class="params">((<span class="type">const</span> uchar*)dst.data,dst.cols,dst.rows,dst.step,QImage::Format_RGB888)</span></span>;</span><br><span class="line">    img.<span class="built_in">bits</span>(); <span class="comment">// 深拷贝，不然无法显示图片</span></span><br><span class="line">    <span class="keyword">return</span> img;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DetectThread::run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>(<span class="string">&quot;detect&quot;</span>);</span><br><span class="line">    cv::VideoCapture capture = cv::<span class="built_in">VideoCapture</span>(<span class="number">0</span>,  cv::CAP_DSHOW);</span><br><span class="line">    <span class="keyword">if</span>(!capture.<span class="built_in">isOpened</span>())&#123;</span><br><span class="line">        <span class="function">emit <span class="title">sendError</span><span class="params">(QStringLiteral(<span class="string">&quot;打开摄像头失败，请检查是否安装摄像头设备&quot;</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    capture.<span class="built_in">set</span>(cv::CAP_PROP_FRAME_WIDTH,<span class="number">640</span>);</span><br><span class="line">    capture.<span class="built_in">set</span>(cv::CAP_PROP_FRAME_HEIGHT,<span class="number">480</span>);</span><br><span class="line">    cv::CascadeClassifier cascadeClassifier;</span><br><span class="line">    cv::Mat frame, frameGray;</span><br><span class="line">    cv::Mat faceCover, faceCoverResize, faceCoverGray, faceThreshold, faceCoverBitwise;</span><br><span class="line">    cv::Mat frameROI;</span><br><span class="line">    cv::Mat equalizeFrame;</span><br><span class="line">    ushort cover = _cover;</span><br><span class="line">    ushort classifier = _classifier;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;:/assets/classifier/classifier.json&quot;</span>)</span></span>;</span><br><span class="line">    std::string a[] = &#123;  <span class="string">&quot;assets/classifier/haarcascade_frontalface_alt.xml&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;assets/classifier/haarcascade_eye.xml&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;assets/classifier/haarcascade_mcs_mouth.xml&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;assets/classifier/haarcascade_mcs_nose.xml&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;assets/classifier/haarcascade_mcs_leftear.xml&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;assets/classifier/haarcascade_mcs_rightear.xml&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(!cascadeClassifier.<span class="built_in">load</span>(a[_classifier]))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isInterruptionRequested</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(classifier != _classifier)&#123;</span><br><span class="line">            classifier = _classifier;</span><br><span class="line">            <span class="keyword">if</span>(!cascadeClassifier.<span class="built_in">load</span>(a[_classifier]))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        capture&gt;&gt;frame;</span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(frame, frameGray, cv::COLOR_BGR2GRAY);</span><br><span class="line">        cv::<span class="built_in">equalizeHist</span>(frameGray, equalizeFrame);</span><br><span class="line">        std::vector&lt;cv::Rect&gt; faceRects;</span><br><span class="line">        cascadeClassifier.<span class="built_in">detectMultiScale</span>(equalizeFrame, faceRects, <span class="number">1.1</span>, <span class="number">3</span>, <span class="number">0</span>, cv::<span class="built_in">Size</span>(<span class="number">30</span>, <span class="number">30</span>));</span><br><span class="line">        QVector&lt;cv::Point&gt; centers;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i: faceRects)&#123;</span><br><span class="line">            <span class="keyword">if</span>(_cover == <span class="number">0</span>)&#123;</span><br><span class="line">                cover = _cover;</span><br><span class="line">                cv::<span class="built_in">rectangle</span>(frame, i, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(faceCover.<span class="built_in">empty</span>() || cover != _cover)&#123;</span><br><span class="line">                    cover = _cover;</span><br><span class="line">                    <span class="function">QFile <span class="title">file</span><span class="params">(covers[_classifier][_cover - <span class="number">1</span>])</span></span>;</span><br><span class="line">                    <span class="keyword">if</span>(file.<span class="built_in">open</span>(QIODevice::ReadOnly))</span><br><span class="line">                    &#123;</span><br><span class="line">                        qint64 sz = file.<span class="built_in">size</span>();</span><br><span class="line">                        <span class="function">std::vector&lt;uchar&gt; <span class="title">buf</span><span class="params">(sz)</span></span>;</span><br><span class="line">                        file.<span class="built_in">read</span>((<span class="type">char</span>*)buf.<span class="built_in">data</span>(), sz);</span><br><span class="line">                        faceCover = <span class="built_in">imdecode</span>(buf, cv::IMREAD_COLOR);</span><br><span class="line">                    &#125;</span><br><span class="line">                    file.<span class="built_in">close</span>();</span><br><span class="line">                    QVector&lt;cv::Point&gt; centers;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(_classifier == <span class="number">1</span> &amp;&amp; _cover == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="function">cv::Point <span class="title">center</span><span class="params">(i.x + <span class="type">int</span>(i.width * <span class="number">0.5</span>), i.y + <span class="type">int</span>(i.height))</span></span>;</span><br><span class="line">                    centers.<span class="built_in">push_back</span>(center);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cv::Rect <span class="built_in">faceRect</span>(i.x, i.y, i.width, i.height);</span><br><span class="line">                    cv::<span class="built_in">resize</span>(faceCover, faceCoverResize, i.<span class="built_in">size</span>());</span><br><span class="line">                    cv::<span class="built_in">cvtColor</span>(faceCoverResize, faceCoverGray, cv::COLOR_RGB2GRAY);</span><br><span class="line">                    cv::<span class="built_in">threshold</span>(faceCoverGray, faceThreshold, <span class="number">233</span>, <span class="number">255</span>, cv::THRESH_BINARY_INV);</span><br><span class="line">                    frameROI = <span class="built_in">frame</span>(i);</span><br><span class="line">                    faceCoverResize.<span class="built_in">copyTo</span>(frameROI, faceThreshold);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(centers.<span class="built_in">size</span>() == <span class="number">2</span>)&#123;</span><br><span class="line">                cv::Point leftPoint, rightPoint;</span><br><span class="line">                <span class="keyword">if</span>(centers[<span class="number">0</span>].x &lt; centers[<span class="number">1</span>].x)&#123;</span><br><span class="line">                    leftPoint = centers[<span class="number">0</span>];</span><br><span class="line">                    rightPoint = centers[<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    leftPoint = centers[<span class="number">1</span>];</span><br><span class="line">                    rightPoint = centers[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> w = <span class="number">2.3</span> * (rightPoint.x - leftPoint.x);</span><br><span class="line">                <span class="type">int</span> h = <span class="built_in">int</span>(<span class="number">0.4</span> * w);</span><br><span class="line">                <span class="type">int</span> x = leftPoint.x - <span class="number">0.25</span>*w;</span><br><span class="line">                <span class="type">int</span> y = leftPoint.y - <span class="number">0.5</span>*h;</span><br><span class="line">                <span class="keyword">if</span>(x + w &lt; frame.cols &amp;&amp; y + h &lt; frame.rows &amp;&amp; x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    cv::<span class="built_in">resize</span>(faceCover, faceCoverResize, cv::<span class="built_in">Size</span>(w, h));</span><br><span class="line">                    cv::<span class="built_in">cvtColor</span>(faceCoverResize, faceCoverGray, cv::COLOR_RGB2GRAY);</span><br><span class="line">                    cv::<span class="built_in">threshold</span>(faceCoverGray, faceThreshold, <span class="number">233</span>, <span class="number">255</span>, cv::THRESH_BINARY_INV);</span><br><span class="line">                    frameROI = <span class="built_in">frame</span>(cv::<span class="built_in">Rect</span>(x, y, w, h));</span><br><span class="line">                    faceCoverResize.<span class="built_in">copyTo</span>(frameROI, faceThreshold);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">emit <span class="title">sendImage</span><span class="params">(toQImage(frame))</span></span>;</span><br><span class="line">        cv::<span class="built_in">waitKey</span>(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DetectThread::<span class="built_in">DetectThread</span>(QObject *parent)&#123;&#125;</span><br><span class="line"></span><br><span class="line">DetectThread::~<span class="built_in">DetectThread</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ushort <span class="title">DetectThread::cover</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _cover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ushort <span class="title">DetectThread::classifier</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _classifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DetectThread::receiveCover</span><span class="params">(QString cover)</span></span>&#123;</span><br><span class="line">    _cover = cover.<span class="built_in">toUShort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DetectThread::receiveClassifier</span><span class="params">(QString classifier)</span></span>&#123;</span><br><span class="line">    _classifier = classifier.<span class="built_in">toUShort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>PV 操作</title>
    <url>/2023/02/08/PV-%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>爸爸、妈妈、儿子、女儿共用一个盘子，盘中一次只能放一个水果。当盘子为空时，爸爸或妈妈可将一个水果放入果盘中。已知爸爸只可放苹果，妈妈只可放桔子。若放入果盘中的是桔子，则允许儿子吃，女儿必须等待；若放入果盘中的是苹果，则允许女儿吃，儿子必须等待。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="C-语言版本"><a href="#C-语言版本" class="headerlink" title="C 语言版本"></a>C 语言版本</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = <span class="number">1</span>;</span><br><span class="line">semaphore apple = <span class="number">0</span>;</span><br><span class="line">semaphore orange = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">father</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mother</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">son</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">daughter</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tids[<span class="number">4</span>];</span><br><span class="line">    pthread_create(&amp;tids[<span class="number">0</span>], <span class="literal">NULL</span>, father, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tids[<span class="number">1</span>], <span class="literal">NULL</span>, mother, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tids[<span class="number">2</span>], <span class="literal">NULL</span>, daughter, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tids[<span class="number">3</span>], <span class="literal">NULL</span>, son, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">father</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">        <span class="keyword">if</span> (empty == <span class="number">1</span>) &#123;</span><br><span class="line">            empty=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (mutex == <span class="number">1</span>) &#123;</span><br><span class="line">                mutex=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;放苹果&quot;</span>);</span><br><span class="line">                mutex=<span class="number">1</span>;</span><br><span class="line">                apple=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">mother</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">        <span class="keyword">if</span> (empty == <span class="number">1</span>) &#123;</span><br><span class="line">            empty=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (mutex == <span class="number">1</span>) &#123;</span><br><span class="line">                mutex=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;放橘子&quot;</span>);</span><br><span class="line">                mutex=<span class="number">1</span>;</span><br><span class="line">                orange=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">son</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">        <span class="keyword">if</span> (orange == <span class="number">1</span>) &#123;</span><br><span class="line">            orange=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (mutex == <span class="number">1</span>) &#123;</span><br><span class="line">                mutex=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;吃橘子&quot;</span>);</span><br><span class="line">                mutex=<span class="number">1</span>;</span><br><span class="line">                empty=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">daughter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">        <span class="keyword">if</span> (apple == <span class="number">1</span>) &#123;</span><br><span class="line">            apple=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (mutex == <span class="number">1</span>) &#123;</span><br><span class="line">                mutex=<span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;吃苹果&quot;</span>);</span><br><span class="line">                mutex=<span class="number">1</span>;</span><br><span class="line">                empty=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JS-版本"><a href="#JS-版本" class="headerlink" title="JS 版本"></a>JS 版本</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mutex = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> empty = <span class="literal">true</span>,</span><br><span class="line">  orange = <span class="literal">false</span>,</span><br><span class="line">  apple = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">father</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">    empty = !empty;</span><br><span class="line">    <span class="keyword">if</span> (mutex) &#123;</span><br><span class="line">      mutex = !mutex;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;放入苹果&quot;</span>);</span><br><span class="line">      apple = !apple;</span><br><span class="line">      mutex = !mutex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">setTimeout</span>(father, ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3</span> + <span class="number">399</span>));</span><br><span class="line">&#125;, ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3</span> + <span class="number">399</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">mother</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">    empty = !empty;</span><br><span class="line">    <span class="keyword">if</span> (mutex) &#123;</span><br><span class="line">      mutex = !mutex;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;放入橘子&quot;</span>);</span><br><span class="line">      orange = !orange;</span><br><span class="line">      mutex = !mutex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">setTimeout</span>(mother, ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3</span> + <span class="number">399</span>));</span><br><span class="line">&#125;, ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3</span> + <span class="number">399</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">daughter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (apple) &#123;</span><br><span class="line">    apple = !apple;</span><br><span class="line">    <span class="keyword">if</span> (mutex) &#123;</span><br><span class="line">      mutex = !mutex;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;吃掉苹果&quot;</span>);</span><br><span class="line">      empty = !empty;</span><br><span class="line">      mutex = !mutex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">setTimeout</span>(daughter, ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3</span> + <span class="number">399</span>));</span><br><span class="line">&#125;, ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3</span> + <span class="number">399</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">son</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (orange) &#123;</span><br><span class="line">    orange = !orange;</span><br><span class="line">    <span class="keyword">if</span> (mutex) &#123;</span><br><span class="line">      mutex = !mutex;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;吃掉橘子&quot;</span>);</span><br><span class="line">      empty = !empty;</span><br><span class="line">      mutex = !mutex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">setTimeout</span>(son, ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3</span> + <span class="number">399</span>));</span><br><span class="line">&#125;, ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3</span> + <span class="number">399</span>));</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>PromiseAll 实现</title>
    <url>/2023/02/07/PromiseAll-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>Promise.all 返回的是一个 Promise 对象</li>
<li>Promise.all 接收的可迭代对象数组需要通过 Array.from 转换为数组</li>
<li>Promise.all 是并发执行的。</li>
<li>Promise.all 中一个 reject 直接返回 reject 的结果。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getBar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFoo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getError</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promiseAll</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promises[i]).<span class="title function_">then</span>(</span><br><span class="line">        <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          result[i] = res;</span><br><span class="line">          count++;</span><br><span class="line">          <span class="keyword">if</span> (count === promises.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">promiseAll</span>([<span class="title function_">getFoo</span>(), <span class="title function_">getBar</span>(), <span class="title function_">getError</span>()]).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Python requirments.txt</title>
    <url>/2023/04/22/Python-requirments-txt/</url>
    <content><![CDATA[<h2 id="生成-requirments"><a href="#生成-requirments" class="headerlink" title="生成 requirments"></a>生成 requirments</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip freeze &gt;requirements.txt</span><br></pre></td></tr></table></figure>

<h2 id="从-requirments-安装"><a href="#从-requirments-安装" class="headerlink" title="从 requirments 安装"></a>从 requirments 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirement.txt</span><br></pre></td></tr></table></figure>

<h2 id="从-requiremnts-卸载"><a href="#从-requiremnts-卸载" class="headerlink" title="从 requiremnts 卸载"></a>从 requiremnts 卸载</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip uninstall -r requirement.txt</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 字符串格式化</title>
    <url>/2023/04/23/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title="%"></a>%</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>字符串（采用 str() 的显示）</td>
</tr>
<tr>
<td>%r</td>
<td>字符串（采用 repr() 的显示）</td>
</tr>
<tr>
<td>%c</td>
<td>单个字符</td>
</tr>
<tr>
<td>%b</td>
<td>二进制整数</td>
</tr>
<tr>
<td>%d</td>
<td>十进制整数</td>
</tr>
<tr>
<td>%i</td>
<td>十进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>八进制整数</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制整数</td>
</tr>
<tr>
<td>%e</td>
<td>指数（基底写为e）</td>
</tr>
<tr>
<td>%E</td>
<td>指数（基底写为 E）</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%F</td>
<td>浮点数，与上相同</td>
</tr>
<tr>
<td>%g</td>
<td>指数（e）或浮点数 (根据显示长度)</td>
</tr>
<tr>
<td>%G</td>
<td>指数（E）或浮点数 (根据显示长度)</td>
</tr>
<tr>
<td>%%</td>
<td>字符 “%”，显示百分号 %</td>
</tr>
</tbody></table>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>使用占位符的语法如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&quot;Hello, %s&quot;</span> % name</span><br></pre></td></tr></table></figure>

<p>其中，%s 是占位符，name 是要替换的值。如果有多个占位符，可以使用元组来传递值，例如：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&quot;My name is %s, and I&#x27;m %d years old&quot;</span> % (name, age)</span><br></pre></td></tr></table></figure>

<p>还可以使用字典来传递值，例如：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">string = <span class="string">&quot;My name is %(name)s, and I&#x27;m %(age)d years old&quot;</span> % &#123;<span class="string">&quot;name&quot;</span>: name, <span class="string">&quot;age&quot;</span>: age&#125;</span><br></pre></td></tr></table></figure>

<h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;0:b&#125;,&#123;0:c&#125;,&#123;0:d&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">425</span>)</span><br></pre></td></tr></table></figure>

<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>&lt;填充&gt;&lt;对齐&gt;&lt;宽度&gt;&lt;,&gt;&lt;.精度&gt;&lt;类型&gt;</p>
<h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>指宽度内除了参数外的字符采用什么方式表示，默认采用空格，可以通过填充更换。</p>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>指参数在宽度内输出时的对齐方式，分别使用 &lt;、&gt; 和 ^ 三个符号表示左对齐、右对齐和居中对齐。</p>
<h3 id="宽度"><a href="#宽度" class="headerlink" title="宽度"></a>宽度</h3><p>指当前槽的设定输出字符宽度，如果该槽对应的 format() 参数长度比宽度设定值大，则使用参数实际长度。如果该值的实际位数小于指定宽度，则位数将被默认以空格字符补充。</p>
<h3 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h3><p>逗号（，）用于显示数字的千位分隔符，例如：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;0:-^20,&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">1234567890</span>)</span><br><span class="line"><span class="string">&quot;&#123;0:-^20&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">1234567890</span>)</span><br><span class="line"><span class="string">&quot;&#123;0:-^20,&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">12345.67890</span>)</span><br></pre></td></tr></table></figure>

<h3 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h3><p>表示两个含义，由小数点（.）开头。对于浮点数，精度表示小数部分输出的有效位数。对于字符串，精度表示输出的最大长度。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&#123;0:.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">12345.67890</span>)</span><br><span class="line"><span class="string">&quot;&#123;0:H^20.3f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">12345.67890</span>)</span><br><span class="line"><span class="string">&quot;&#123;0:.4&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;PYTHON&quot;</span>)</span><br></pre></td></tr></table></figure>


<h3 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h3><ul>
<li>b: 输出整数的二进制方式</li>
<li>c: 输出整数对应的 Unicode 字符</li>
<li>d: 输出整数的十进制方式</li>
<li>o: 输出整数的八进制方式</li>
<li>x: 输出整数的小写十六进制方式</li>
<li>X: 输出整数的大写十六进制方式</li>
<li>e: 输出浮点数对应的小写字母 e 的指数形式；</li>
<li>E: 输出浮点数对应的大写字母 E 的指数形式；</li>
<li>f: 输出浮点数的标准浮点形式；</li>
<li>%: 输出浮点数的百分形式。</li>
</ul>
<h2 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>&lt;填充&gt;&lt;对齐&gt;&lt;宽度&gt;&lt;,&gt;&lt;.精度&gt;&lt;类型&gt;</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 异常处理</title>
    <url>/2023/04/23/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能出现异常的代码</span></span><br><span class="line">    x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数字：&quot;</span>))</span><br><span class="line">    y = <span class="number">10</span> / x</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;计算结果为：&quot;</span>, y)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="comment"># 处理ValueError异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入的不是数字，请重新输入！&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="comment"># 处理ZeroDivisionError异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;除数不能为零，请重新输入！&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 处理其他异常</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序出现了异常：&quot;</span>, e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 没有异常时执行的代码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序执行完毕！&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 无论是否有异常，都会执行的代码</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序结束！&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，try-except 语句块中的代码可能会出现异常，如果出现异常，则根据异常类型执行对应的 except 语句块中的代码。如果没有出现异常，则执行 else 语句块中的代码。无论是否出现异常，都会执行finally语句块中的代码。在 except 语句块中可以使用多个 except 语句来处理不同类型的异常，也可以使用一个 except 语句来处理所有类型的异常，如上面的代码中的最后一个except语句。在 except 语句块中，可以使用 as 关键字将异常对象赋值给一个变量，方便输出异常信息。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 配置文件</title>
    <url>/2023/04/24/Python-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="ini"><a href="#ini" class="headerlink" title="ini"></a>ini</h2><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="attr">host</span>     = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">user</span>     = root</span><br><span class="line"><span class="attr">password</span> = <span class="number">123456</span></span><br><span class="line"><span class="attr">port</span>     = <span class="number">3306</span></span><br><span class="line"><span class="attr">database</span> = mysql</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cfg = ConfigParser()</span><br><span class="line">cfg.read(<span class="string">&quot;./src/config.ini&quot;</span>)</span><br><span class="line">SQLALCHEMY_DATABASE_URL = <span class="string">&#x27;mysql+pymysql://%s:%s@%s:%d/%s&#x27;</span> % (cfg.get(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;user&quot;</span>), cfg.get(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;password&quot;</span>),</span><br><span class="line">                                                              cfg.get(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;host&quot;</span>), cfg.getint(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;port&quot;</span>),</span><br><span class="line">                                                              cfg.get(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;database&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="toml"><a href="#toml" class="headerlink" title="toml"></a>toml</h2><h2 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h2>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QGraphicsView</title>
    <url>/2023/03/30/QGraphicsView/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>QGraphicsView 是 Qt 库中提供的2D图形视图框架，用于显示和管理大量的2D图形项。它提供了一个可滚动的视图窗口，允许用户缩放、旋转、平移视图，以及交互式地选择、移动、删除图形项。QGraphicsView 还支持多种视觉效果，如反锯齿、渐变、阴影等，可以使图形更加美观和逼真。</p>
<p>在QGraphicsView中，每个图形项都是一个 QGraphicsItem 的子类，可以包括各种 2D 图形元素，如线条、矩形、椭圆、多边形、文本、图像等。图形项可以设置各种属性，如位置、大小、颜色、笔刷、画笔、字体等，可以响应用户的事件，如鼠标点击、拖拽、键盘事件等。</p>
<p>使用 QGraphicsView，开发人员可以通过各种方式来创建和管理图形项，如手动创建、从文件加载、从数据库读取等。QGraphicsView 还提供了一些辅助工具，如 QGraphicsScene、QGraphicsItemGroup、QGraphicsTransform 等，用于管理、组合和变换图形项，以及实现高级特性，如动画、碰撞检测等。</p>
<p>QGraphicsView 是 Qt GUI 应用程序中最常用的图形视图框架之一，被广泛用于绘制、显示和编辑各种 2D 图形和图形化应用程序。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QObject</title>
    <url>/2023/03/30/QObject/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>QObject 是 Qt 中最重要的类之一，也是 Qt 的对象模型的核心。QObject 类提供了以下功能：</p>
<ul>
<li>对象树和父子关系：每个 QObject 对象都可以有一个父对象，形成一个对象树结构。当父对象被删除时，其子对象也会被删除。</li>
<li>信号和槽机制：QObject 支持信号和槽机制，是 Qt 中最重要的通信机制之一。信号是一种事件，当特定的事件发生时，信号被发射。槽是一种函数，用于处理这些信号。通过信号和槽，可以实现对象之间的松耦合通信。</li>
<li>特定的元对象系统：QObject 支持元对象系统，允许在运行时查询和操作对象的属性、信号和槽等元数据。元对象系统是 Qt 的反射机制之一，使得 Qt 可以实现一些高级功能，如信号和槽动态连接、动态创建对象等。</li>
<li>事件系统：QObject 支持事件系统，允许对象接收和处理事件。事件是一种轻量级的通信机制，可以用于处理 GUI 事件、网络事件等。</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>QObject 是 Qt 中的基础类，几乎所有的 Qt 类都继承自 QObject 类或其子类，因此了解 QObject 是 Qt 开发的关键。在使用 QObject 时，需要注意以下几点：</p>
<ul>
<li>QObject 对象必须在堆上创建，不能在栈上创建。</li>
<li>QObject 对象的父子关系必须在构造函数中设置。</li>
<li>QObject 对象的生命周期由其父对象管理。当父对象被删除时，其所有子对象都会被自动删除。</li>
<li>QObject 对象的属性、信号和槽必须在元对象系统中注册，可以使用 Q_OBJECT 宏来自动生成元对象代码。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QPainter</title>
    <url>/2023/03/30/QPainter/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>QPainter 是 Qt 库中提供的 2D 图形渲染引擎，用于绘制各种 2D 图形和界面元素，如线条、矩形、椭圆、多边形、文本、图像等。QPainter 可以在 QWidget、QPixmap、QImage 等设备上绘制图形，支持透明度、阴影、渐变、反锯齿等特性。</p>
<p>使用 QPainter，开发人员可以通过绘制函数来绘制各种图形，如 drawLine()、drawRect()、drawEllipse()、drawPolygon() 等。QPainter 还提供了一些辅助函数，如 setPen()、setBrush()、setFont() 等，用于设置绘制的颜色、画笔、画刷、字体等属性。另外，QPainter 还提供了一些高级特性，如裁剪、变换、缓存等，可以使绘制更加灵活和高效。</p>
<p>QPainter 是 Qt GUI 应用程序中最常用的绘图工具之一，被广泛用于绘制各种用户界面元素和图形化应用程序。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QT 事件循环</title>
    <url>/2023/03/30/QT-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>Qt 事件循环是 Qt 库中提供的一种事件处理机制，用于接收和分发各种GUI事件，如鼠标事件、键盘事件、定时器事件等。事件循环是基于事件驱动的，每个 Qt 应用程序都有一个事件循环（QEventLoop），用于接收和处理事件。</p>
<p>在Qt事件循环中，每个事件都是一个 QEvent 对象，用于描述特定类型的事件。事件可以被发送到一个或多个接收者（QObject 对象），其中每个接收者都可以处理自己感兴趣的事件类型。事件可以通过事件过滤器（QEventFilter）进行拦截和处理，以实现事件的定制化处理。</p>
<p>事件循环通过调用 QCoreApplication::exec() 函数来启动，并且在应用程序退出之前一直运行。当事件循环启动时，它会从事件队列中获取一个事件并将其发送给适当的接收者。接收者可以重写 QObject 派生类中的虚函数（如 event()、timerEvent() 等）来处理各种事件，也可以通过安装事件过滤器来实现事件的定制化处理。</p>
<p>Qt 事件循环是 Qt 库中最重要的特性之一，被广泛用于开发各种 GUI 应用程序和多线程应用程序。它提供了一种简单而强大的事件处理机制，使开发人员可以更加方便地实现事件的处理和分发，提高了应用程序的可维护性和可扩展性</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QT 事件系统</title>
    <url>/2023/03/30/QT-%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Qt 事件系统是 Qt 库中提供的一种事件处理机制，用于处理 GUI 应用程序中的各种事件，如鼠标事件、键盘事件、定时器事件等。事件系统是基于事件循环机制实现的，每个 Qt 应用程序都有一个事件循环（QEventLoop），用于接收和分发事件。</p>
<p>在 Qt 事件系统中，每个事件都是一个 QEvent 对象，用于描述特定类型的事件。事件可以被发送到一个或多个接收者（QObject 对象），其中每个接收者都可以处理自己感兴趣的事件类型。事件可以通过事件过滤器（QEventFilter）进行拦截和处理，以实现事件的定制化处理。</p>
<p>使用Qt事件系统，开发人员可以通过重写 QObject 派生类中的虚函数（如 event()、timerEvent() 等）来处理各种事件，也可以通过安装事件过滤器来实现事件的定制化处理。事件系统还提供了一些辅助函数和宏，如 QEvent::registerEventType()、QEventLoop::exec() 等，用于简化事件的创建和处理。</p>
<p>Qt 事件系统是 Qt 库中最重要的特性之一，被广泛用于开发各种 GUI 应用程序和多线程应用程序。它提供了一种简单而强大的事件处理机制，使开发人员可以更加方便地实现事件的处理和分发，提高了应用程序的可维护性和可扩展性。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QT 信号</title>
    <url>/2023/03/30/QT-%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<p>Qt信号是Qt库中提供的一种事件驱动的编程机制，用于在对象之间传递消息和处理事件。信号是一种特殊的函数，用于通知其他对象发生了特定的事件，例如按钮被点击，文本框内容发生改变等。</p>
<p>在Qt中，信号是由QObject派生类中的signals关键字声明的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyObject</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mySignal</span><span class="params">(<span class="type">int</span> arg1, QString arg2)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，MyObject类声明了一个名为mySignal的信号，它带有两个参数：一个整数类型的参数arg1和一个字符串类型的参数arg2。</p>
<p>通过emit关键字，可以在对象中触发信号，例如：</p>
<p>emit mySignal(42, “Hello, world!”);<br>上面的代码将触发名为mySignal的信号，将42和”Hello, world!”作为参数传递给接收者。</p>
<p>使用Qt信号，开发人员可以通过connect()函数将一个信号连接到一个或多个槽函数，从而实现对象之间的消息传递和事件响应。信号槽机制支持多种连接方式，如直接连接、队列连接、延迟连接等，可以根据应用程序的需要进行灵活配置。</p>
<p>Qt信号是Qt库中最重要的特性之一，被广泛用于开发各种GUI应用程序和多线程应用程序。它提供了一种简单而强大的编程机制，使开发人员可以更加方便地实现事件处理和消息传递，提高了应用程序的可维护性和可扩展性。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QT 信号槽</title>
    <url>/2023/03/30/QT-%E4%BF%A1%E5%8F%B7%E6%A7%BD/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Qt 信号槽是 Qt 库中提供的一种事件驱动的编程机制，用于在对象之间传递消息和处理事件。信号槽机制基于发布/订阅模式，其中一个对象（信号发射器）发出信号，而一个或多个对象（槽函数）接收这个信号并作出相应的响应。</p>
<p>在 Qt 中，信号是一种特殊的函数，用于通知其他对象发生了特定的事件，例如按钮被点击，文本框内容发生改变等。每个信号都有一个名称和一组参数列表，用于描述事件的类型和属性。槽函数则是一种与信号相对应的函数，用于接收信号并作出相应的响应，例如更新界面、执行计算等。</p>
<p>使用 Qt 信号槽，开发人员可以通过 connect() 函数将一个信号连接到一个或多个槽函数，从而实现对象之间的消息传递和事件响应。信号槽机制支持多种连接方式，如直接连接、队列连接、延迟连接等，可以根据应用程序的需要进行灵活配置。</p>
<p>Qt 信号槽是 Qt 库中最重要的特性之一，被广泛用于开发各种 GUI 应用程序和多线程应用程序。它提供了一种简单而强大的编程机制，使开发人员可以更加方便地实现事件处理和消息传递，提高了应用程序的可维护性和可扩展性。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QT 元对象系统</title>
    <url>/2023/03/30/QT-%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Qt 元对象系统是 Qt 库中提供的一种运行时类型信息机制，用于支持信号槽机制、反射、动态属性、国际化等特性。元对象系统基于 C++ 对象模型，通过在编译时生成元对象信息，提供了一种在运行时查询和操作对象信息的方法。</p>
<p>在 Qt 中，每个 QObject 派生类都具有一个元对象（QMetaObject），用于描述该类的属性、方法、信号、槽等信息。元对象还包括一个元属性（QMetaProperty）列表，用于描述对象的属性和动态属性。通过元对象系统，开发人员可以在运行时查询和操作对象的属性、方法、信号、槽等信息，而无需手动编写大量的重复代码。</p>
<p>元对象系统还提供了一些辅助函数和宏，如 QObject::metaObject()、Q_OBJECT 宏、Q_PROPERTY 宏等，用于简化元对象信息的生成和访问。元对象系统还支持国际化和翻译，通过 QTranslator 类和 QCoreApplication::translate() 函数，可以实现多语言支持和本地化。</p>
<p>Qt 元对象系统是 Qt 库中最重要的特性之一，被广泛用于开发各种GUI应用程序和多线程应用程序。它提供了一种简单而强大的编程机制，使开发人员可以更加方便地实现信号槽、反射、动态属性等特性，提高了应用程序的可维护性和可扩展性。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QWidget</title>
    <url>/2023/03/30/QWidget/</url>
    <content><![CDATA[<p>QWidget是Qt库中提供的一种GUI控件类，用于创建和管理窗口、对话框、按钮、文本框、标签等GUI界面元素。QWidget是所有Qt GUI控件的基类，它提供了一些基本的GUI功能，如绘图、事件处理、布局管理等。</p>
<p>QWidget可以包含其他QWidget控件和子控件，从而实现复杂的GUI布局和功能。QWidget还支持Qt的信号槽机制，可以通过connect()函数将信号连接到一个或多个槽函数，实现对象之间的消息传递和事件响应。</p>
<p>在创建QWidget对象时，通常需要指定一个父对象，以便将QWidget添加到父对象中。QWidget的父对象可以是其他QWidget对象或Qt应用程序的主窗口（QMainWindow）。</p>
<p>QWidget还提供了一些常用的函数和属性，如setWindowTitle()、setGeometry()、setStyleSheet()等，用于设置窗口标题、位置、大小和样式表等。通过这些函数和属性，开发人员可以对QWidget进行灵活的设置和控制，以实现应用程序的特定需求。</p>
<p>QWidget是Qt库中最常用的类之一，被广泛用于开发各种GUI应用程序和窗口系统。它提供了一种简单而强大的GUI控件类，使开发人员可以更加方便地实现各种GUI界面元素和功能。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>QT 布局管理器</title>
    <url>/2023/03/30/QT-%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p>Qt布局管理器是Qt库中提供的一种自动布局机制，用于管理GUI界面中的控件位置和大小。布局管理器可以根据窗口大小自动调整控件的位置和大小，从而实现窗口的自适应和响应式。</p>
<p>Qt布局管理器包括以下几种：</p>
<ul>
<li>QHBoxLayout：水平布局，将控件横向排列。</li>
<li>QVBoxLayout：垂直布局，将控件纵向排列。</li>
<li>QGridLayout：网格布局，将控件按照网格排列。</li>
<li>QFormLayout：表单布局，将控件按照标签-编辑框的形式排列。</li>
<li>QStackedLayout：堆叠布局，将多个控件堆叠在一起，只显示其中一个控件。</li>
</ul>
<p>使用Qt布局管理器，开发人员可以将控件添加到布局中，而不需要手动计算控件的位置和大小。布局管理器会自动根据窗口大小和控件的大小调整控件的位置和大小，从而实现窗口的自适应和响应式。</p>
<p>布局管理器还支持嵌套布局，即在一个布局中添加另一个布局，从而实现复杂的布局效果。开发人员可以通过setLayout()函数将布局管理器设置为窗口或控件的布局。</p>
<p>Qt布局管理器是Qt库中最重要的特性之一，被广泛用于开发各种GUI应用程序。它提供了一种简单而强大的布局机制，使开发人员可以更加方便地实现自适应和响应式的GUI界面。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>RO 与 R3 通信</title>
    <url>/2023/03/30/RO-%E4%B8%8E-R3-%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Windows操作系统中，R3（Ring 3）是用户模式，R0（Ring 0）是内核模式。由于内核模式具有更高的特权级别和更广泛的系统访问权限，因此在R3和R0之间进行通信时需要特别小心，以避免对系统的安全和稳定性造成影响。</p>
<p>在 R3 和 R0 之间进行通信的一种常用方法是使用系统调用（System Call），也称为内核调用（Kernel Call）。系统调用是一种通过软件中断机制使用户模式应用程序与内核模式交互的技术，在应用程序需要访问受限资源时，可以通过系统调用请求内核模式执行相应的操作。</p>
<p>Windows 操作系统中提供了许多系统调用，例如 CreateFile、ReadFile、WriteFile 等，可以用于文件和设备的操作，同时也可以使用 Win32 API 或者 .NET Framework 等高级编程接口来调用系统调用，实现用户模式和内核模式之间的通信。</p>
<p>需要注意的是，在进行系统调用时，需要确保输入参数的合法性和正确性，避免恶意或者错误的输入导致系统的崩溃或者安全漏洞。同时，也需要遵循 Windows 操作系统的编程规范和安全策略，以确保系统的安全和稳定性。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2023/03/26/RPC/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>RPC（Remote Procedure Call，远程过程调用）是一种计算机通信协议，它允许一个计算机程序调用另一个计算机上的程序，而不需要程序员显式编写远程调用的代码。RPC 通过网络传输协议（如TCP/IP）来传输数据并执行远程过程调用，使得分布式计算变得更加容易。<br>在 RPC 中，客户端程序通过调用本地的 Stub（存根）来执行远程过程调用。Stub 将客户端调用的参数打包成网络传输格式，然后通过网络传输协议将数据发送给服务端。服务端接收到数据后，将数据解包并调用本地的实现，然后将结果打包成网络传输格式返回给客户端。客户端接收到结果后，将结果解包并返回给调用者。<br>RPC 的优点包括：</p>
<ul>
<li>简化分布式计算：RPC 允许程序员通过远程调用的方式，调用其他计算机上的程序，从而简化了分布式计算的实现。</li>
<li>提高代码可复用性：RPC 允许程序员将功能模块封装为服务，使得不同的程序可以共享同一个服务，从而提高了代码的可复用性。</li>
<li>提高系统可扩展性：RPC 允许程序员将服务部署在不同的计算机上，从而提高了系统的可扩展性。</li>
<li>支持多种开发语言：RPC 可以支持多种开发语言，从而使得不同的程序可以使用不同的语言进行开发，同时仍然可以进行远程调用。</li>
</ul>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="GRPC"><a href="#GRPC" class="headerlink" title="GRPC"></a>GRPC</h3><p>GPRC 是一种高性能、开源、通用的RPC框架，由 Google 开发并开源。它支持多种编程语言，包括 C++、Java、Go、Python、Ruby、Node.js等。GPRC 基于 HTTP/2 协议，支持双向流、流控制、头部压缩、多路复用等特性，可以提供高效的通信性能和优秀的用户体验。</p>
<p>GPRC 的核心特点包括：</p>
<ul>
<li>高性能：GPRC 采用 HTTP/2 协议，支持双向流、流控制、头部压缩、多路复用等特性，可以提供高效的通信性能。</li>
<li>多语言支持：GPRC 支持多种编程语言，包括 C++、Java、Go、Python、Ruby、Node.js 等。</li>
<li>简单易用：GPRC 提供了简单易用的接口和工具，可以方便地进行开发和调试。</li>
<li>通用性：GPRC 可以用于各种应用场景，包括微服务、分布式系统、云计算等。</li>
<li>开源：GPRC 是开源的，任何人都可以免费使用、修改和分发。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>RTTI</title>
    <url>/2023/03/30/RTTI/</url>
    <content><![CDATA[<p>RTTI（Run-Time Type Information）指运行时类型信息，是一种 C++ 的运行时特性。RTTI 技术可以在程序运行时获取对象的类型信息，以及在对象之间进行类型转换。</p>
<p>在 C++ 中，类可以通过继承、多态等方式形成对象之间的层次关系。RTTI 技术可以让程序在运行时判断对象的实际类型，以便执行不同的操作。C++ 中提供了两种 RTTI 技术：</p>
<p>dynamic_cast：可以在运行时检查对象之间的类型关系，进行安全的类型转换。</p>
<p>typeid：可以获取对象的类型信息，包括类名和地址等。</p>
<p>使用 RTTI 技术可以让程序更加灵活和安全，可以在程序运行时根据需要进行类型转换和动态绑定，避免出现类型错误和运行时错误。但是，RTTI 技术也会带来一些性能损失和安全风险，需要谨慎使用。</p>
<p>总之，RTTI 技术是 C++ 的一种运行时特性，可以在程序运行时获取对象的类型信息，以及进行类型转换和动态绑定等操作，是 C++ 编程中非常重要的一部分。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>React 生命周期</title>
    <url>/2023/06/11/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>组件初始化执行构造函数，只执行一次。</p>
<p>继承Component则必须显式调用super(props)，否则this.props会出现未定义bug。</p>
<p>可在其中声明state。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">        <span class="attr">text</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h2><p>该函数返回一个对象，会合并到 state 中，返回 null 则不更新 state。组件挂载和更新阶段都会调用。此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。如果由于父组件更新触发该函数，则是 preState。如果是子组件自身更新触发该函数，则是nextState</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">nextProps, prevState</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">parentText</span>: nextProps.<span class="property">text</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p>函数返回一个布尔值。true 则执行后续流程，false 则不执行 render 函数及其后续生命周期函数。常用于性能优化。根据返回值来判断是否执行后续的生命周期函数，是否对组件进行re-render（重渲染）</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Child组件的shouldComponentUpdate()&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>返回一个 VNode、VNode 数组或 framgments、Portals、字符串或者数字、布尔类型或者 null 则什么都不渲染。不可执行 setState，否则会造成死循环。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;child-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Child组件的text:&#123;this.state.text&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h2><p>在更新之前获取state的快照，此时可以获取Dom信息。</p>
<p>只有在更新阶段会执行。</p>
<pre><code>使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()。

此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。
</code></pre>
<p>  /**</p>
<ul>
<li>Pre-commit阶段：可以读取DOM</li>
<li>返回值作为componentDidUpdate生命周期函数的第三个参数</li>
<li>@param {object} prevProps</li>
<li>@param {object} prevState</li>
<li>/<br>getSnapshotBeforeUpdate(prevProps, prevState) {<br>console.log(‘Child组件的getSnapshotBeforeUpdate()’, prevProps, prevState);<br>return {<br>  value: ‘getSnapshotBeforeUpdate’,<br>};<br>}<br>​</li>
</ul>
<h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><p>组件加载完之后执行，适合执行包含副作用的函数，例如请求数据和设置事件监听等。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Child组件的componentDidMount()&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><p>组件更新完毕之后执行。</p>
<p>注意如果在这个函数中设置 state，需要在一定的条件下执行，否则可能引发死循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, valueFromSnapshot</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">&#x27;组件的componentDidUpdate()&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;从组件的getSnapshotBeforeUpdate获得的值&#x27;</span>,</span><br><span class="line">    prevProps,</span><br><span class="line">    prevState,</span><br><span class="line">    valueFromSnapshot</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="componentWillUnMount"><a href="#componentWillUnMount" class="headerlink" title="componentWillUnMount"></a>componentWillUnMount</h2><p>组件卸载前执行该生命周期函数。</p>
<p>/**</p>
<ul>
<li>组件卸载前执行该生命周期函数</li>
<li>执行场景：</li>
<li>1.组件在父组件中移除了</li>
<li>2.组件中设置了key值，父组件在render过程中，发现子组件两次key值不同</li>
<li>/<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Child组件的componentWillUnmount()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 内存淘汰策略</title>
    <url>/2023/03/31/Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis 是一种基于内存的键值存储数据库，由于内存资源是有限的，当内存不足时，Redis 会进行内存淘汰以释放一些空间。Redis 支持多种内存淘汰策略，以下是一些常见的策略：</p>
<ul>
<li>volatile-lru：淘汰最近最少使用的键，且这些键有过期时间。</li>
<li>volatile-ttl：淘汰最近将要过期的键，即 TTL 值较小的键。</li>
<li>volatile-random：随机淘汰一些有过期时间的键。</li>
<li>allkeys-lru：淘汰最近最少使用的键，不考虑是否设置过期时间。</li>
<li>allkeys-random：随机淘汰一些键。</li>
</ul>
<p>另外，Redis 还支持手动设置内存使用限制，并提供了一些命令可以用于监视内存使用情况，如 INFO 命令和 MEMORY USAGE 命令。在实际使用中，需要根据具体的业务场景选择合适的内存淘汰策略以及设置适当的内存使用限制。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2023/03/28/Redis/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis 是一种基于内存的开源键值对存储系统，支持多种数据结构，包括字符串、哈希、列表、集合、有序集合等。与传统的关系型数据库相比，Redis 具有以下优势：</p>
<ul>
<li>高性能：Redis 将数据存储在内存中，读写速度非常快，可以达到每秒百万级别的操作。</li>
<li>多种数据结构支持：Redis 支持多种数据结构，可以更灵活地存储和处理数据，满足不同业务需求。</li>
<li>数据持久化：Redis 支持数据持久化，可以将数据保存到磁盘中，避免数据丢失。</li>
<li>高可用性：Redis 支持主从复制和 Sentinel 机制，可以保证数据的高可用性和容错性。</li>
<li>丰富的功能：Redis 支持多种功能，包括事务、发布订阅、Lua 脚本、分布式锁等，使得它可以应用于各种场景。</li>
</ul>
<p>Redis主要应用于缓存、队列、计数器、分布式锁、会话管理等场景，可以提高系统的性能和可靠性。同时，需要注意 Redis 的缺点，如数据容量受限、数据持久化性能较差等，需要根据具体的业务需求和场景来选择合适的方案。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 索引</title>
    <url>/2023/03/28/MySQL-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>MySQL索引是一种用于提高数据库查询性能的数据结构，它可以帮助数据库快速定位和访问数据。索引可以理解为是一个排序好的快速查找表，它在查询时可以快速定位到目标数据，从而提高查询效率。</p>
<p>MySQL中常见的索引类型包括以下几种：</p>
<ul>
<li>B-Tree 索引：B-Tree 索引是一种基于 B-Tree 数据结构的索引类型，它可以在 O(logN) 的时间内查找到目标数据。B-Tree 索引适用于范围查询、排序和分组等操作。</li>
<li>哈希索引：哈希索引是一种基于哈希表的索引类型，它可以在 O(1) 的时间内查找到目标数据。哈希索引适用于等值查询，但不适用于范围查询、排序和分组等操作。</li>
<li>全文索引：全文索引是一种用于全文搜索的索引类型，它可以建立在字符、文本和二进制数据类型的列上，支持全文搜索和模糊搜索等操作。</li>
<li>空间索引：空间索引是一种用于地理空间数据的索引类型，它可以建立在 Geometry 和 Geography 类型的列上，支持空间查询和空间分析等操作。</li>
</ul>
<p>在 MySQL 中，使用索引可以加速数据的查询操作，但也会增加数据库的维护成本和存储空间。因此，在使用索引时需要根据具体的业务场景和数据特点来选择适合的索引类型和索引策略，以达到最佳的性能和存储效率。同时，还需要定期优化索引，删除不必要的索引，以减少数据库的负担。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAlchemy 增删改查</title>
    <url>/2023/04/23/SQLAlchemy-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    <content><![CDATA[<p>SQLAlchemy是一个Python的ORM（对象关系映射）框架，可以轻松地连接到各种数据库，并提供了方便的API来进行增删改查等常见操作。</p>
<h2 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h2><p>可以使用Session对象的add()方法将新的对象添加到数据库中。例如：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> mymodels <span class="keyword">import</span> User, engine</span><br><span class="line"></span><br><span class="line">Session = sessionmaker(bind=engine)</span><br><span class="line">session = Session()</span><br><span class="line"></span><br><span class="line">new_user = User(name=<span class="string">&#x27;Alice&#x27;</span>, age=<span class="number">20</span>)</span><br><span class="line">session.add(new_user)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>

<p>首先创建一个 Session 对象，然后创建一个新的User对象，并使用add()方法将其添加到会话中。最后调用commit()方法提交更改，将新的用户保存到数据库中。</p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>可以使用 Session 对象的 delete() 方法将对象从数据库中删除。例如：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">user_to_delete = session.query(User).filter_by(name=<span class="string">&#x27;Alice&#x27;</span>).first()</span><br><span class="line">session.delete(user_to_delete)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>

<p>首先查询要删除的 User 对象，并使用 delete() 方法将其从会话中删除。最后再次调用 commit() 方法提交更改，将删除操作同步到数据库中。</p>
<h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>可以直接修改对象的属性值，然后使用 Session 对象的 commit() 方法将更改提交到数据库。例如：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">user_to_update = session.query(User).filter_by(name=<span class="string">&#x27;Alice&#x27;</span>).first()</span><br><span class="line">user_to_update.age = <span class="number">21</span></span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure>

<p>首先查询要修改的 User 对象，并直接修改其 age 属性的值。最后调用 commit() 方法提交更改，将更新操作同步到数据库中。</p>
<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>可以使用查询语句构造器（query）来构建查询。例如：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line">users = session.query(User).<span class="built_in">all</span>()</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line">    <span class="built_in">print</span>(user.name, user.age)</span><br></pre></td></tr></table></figure>

<p>首先使用 query() 方法创建一个查询对象，然后调用 all() 方法获取所有的结果。最后使用循环遍历结果，并输出每个用户的姓名和年龄。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP 五层网络模型</title>
    <url>/2023/03/25/TCP-IP-%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><ul>
<li>应用层（Application Layer）：应用层是网络协议的最高层，负责处理应用程序间的数据交换和通信。常见的应用层协议有 HTTP、FTP、SMTP、DNS 等。</li>
<li>传输层（Transport Layer）：传输层负责数据的传输和流量控制，提供可靠的端到端的数据传输。常见的传输层协议有 TCP、UDP 等。</li>
<li>网络层（Network Layer）：网络层负责数据包的路由和转发，以及 IP 地址的分配和转换。常见的网络层协议有 IP、ICMP 等。</li>
<li>数据链路层（Data Link Layer）：数据链路层负责数据的分帧和组装，以及数据的错误检测和纠正。常见的数据链路层协议有以太网、PPP 等。</li>
<li>物理层（Physical Layer）：物理层负责数据在物理媒介上的传输，如电缆、光纤等。常见的物理层协议有 RS-232、V.35 等。</li>
</ul>
<p>TCP/IP 五层网络模型是一种参考模型，它通常被用于网络协议的设计和实现。这个模型的主要优点是将网络协议按照功能进行了划分，使得不同层次的协议可以独立地设计和实现，提高了网络协议的灵活性和可扩展性。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+-----------------------------------+</span><br><span class="line">|     应用层 (Application Layer)     |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|      传输层 (Transport Layer)      |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|       网络层 (Network Layer)       |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|    数据链路层 (Data Link Layer)    |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|      物理层 (Physical Layer)       |</span><br><span class="line">+-----------------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><ul>
<li>应用层（Application Layer）：应用层数据格式由应用程序决定，通常采用文本、图片、音视频等形式。</li>
<li>传输层（Transport Layer）：传输层数据格式主要由 TCP 和 UDP 协议确定。TCP 协议将数据分割成多个数据段，每个数据段包含序列号、确认号、窗口大小、校验和等信息。UDP 协议的数据格式相对简单，只包含源端口、目标端口、数据长度和校验和等信息。</li>
<li>网络层（Network Layer）：网络层数据格式主要由 IP 协议确定。IP 协议将数据分割成多个数据包，每个数据包包含源 IP 地址、目标 IP 地址、协议类型、数据长度和校验和等信息。</li>
<li>数据链路层（Data Link Layer）：数据链路层数据格式由不同的协议确定。以太网协议的数据帧格式包括帧头、源 MAC 地址、目标 MAC 地址、数据和帧尾等信息。PPP 协议的数据帧格式包括帧起始标识符、地址、控制、协议和数据等信息。</li>
<li>物理层（Physical Layer）：物理层数据格式由不同的物理媒介和信号类型决定。例如，以太网使用的是电缆传输，信号类型为电信号；而光纤传输使用的是光信号。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/2023/03/25/TCP/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>TCP（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输协议，常用于 Internet 上的数据传输。TCP 协议在传输数据之前，必须先建立一个连接，并且在数据传输完成后，还要释放这个连接。这个连接建立的过程称为“三次握手”，连接释放的过程称为“四次挥手”。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>TCP协议具有以下特点：</p>
<ul>
<li>可靠性：TCP 协议通过序列号、确认应答和重传机制等技术，保证数据传输的可靠性和完整性。</li>
<li>面向连接：在 TCP 协议中，数据传输前需要先建立一个连接，传输完成后需要释放这个连接。</li>
<li>有序性：TCP 协议通过序列号来保证数据包的有序传输。</li>
<li>流量控制：TCP 协议通过滑动窗口机制来控制数据传输的速率，避免网络拥塞。</li>
<li>拥塞控制：TCP 协议通过拥塞窗口机制来控制数据传输的速率，避免网络拥堵。</li>
</ul>
<p>因为 TCP 协议具有可靠性和面向连接的特点，所以它常用于传输重要的数据，如电子邮件、文件传输、网页浏览等。但是，由于 TCP 协议需要进行连接建立和释放，以及数据包的确认和重传等操作，会带来一定的开销和延迟，因此在实时性要求较高的场景下，如音视频通信等，通常使用 UDP 协议。</p>
<h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |          Source Port          |       Destination Port        |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |                        Sequence Number                        |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |                    Acknowledgment Number                      |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line"> | Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line"> |       |           |G|K|H|T|N|N|                               |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |           Checksum            |         Urgent Pointer        |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |                    Options                    |    Padding    |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"> |                             data                              |</span><br><span class="line"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<ul>
<li>源端口号（Source Port）：占用 16 位，指定发送方的端口号。</li>
<li>目的端口号（Destination Port）：占用 16 位，指定接收方的端口号。</li>
<li>序列号（Sequence Number）：占用 32 位，指定当前发送的数据段的序列号。</li>
<li>确认号（Acknowledgment Number）：占用 32 位，指定已经接收到的数据段的序列号。</li>
<li>数据偏移量（Data Offset）：占用 4 位，指定 TCP 首部的长度。</li>
<li>保留位（Reserved）：占用 6 位，保留供将来使用。</li>
<li>标志位（Flags）：占用 6 位，包含了以下 6 个标志位：<ul>
<li>URG：表示紧急指针是否有效。</li>
<li>ACK：表示确认号是否有效。</li>
<li>PSH：表示接收方是否应该立即将数据交给应用层。</li>
<li>RST：表示连接是否需要重置。</li>
<li>SYN：表示连接是否需要同步。</li>
<li>FIN：表示发送方是否已经完成发送。</li>
</ul>
</li>
<li>窗口大小（Window Size）：占用 16 位，指定接收方缓存区的大小，用于流量控制。</li>
<li>校验和（Checksum）：占用 16 位，用于检验 TCP 数据段是否有误。</li>
<li>紧急指针（Urgent Pointer）：占用 16 位，指定紧急数据的偏移量，用于紧急数据传输。</li>
<li>选项（Options）：占用可变长度，包含了一些额外的</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>TraceMe 破解</title>
    <url>/2023/03/31/TraceMe-%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="OllyDbg-布局"><a href="#OllyDbg-布局" class="headerlink" title="OllyDbg 布局"></a>OllyDbg 布局</h2><p><img src="../img/uTools_1680274052975.png" alt="OllyDbg"></p>
<table>
<thead>
<tr>
<th>窗口</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>反汇编窗口</td>
<td>显示被调试程序的反汇编代码</td>
</tr>
<tr>
<td>寄存器窗口</td>
<td>显示当前所选线程的 CPU 寄存器内容</td>
</tr>
<tr>
<td>信息窗口</td>
<td>显示反汇编窗口中选中的第一个命令的参数及一些跳转目标地址、字串等</td>
</tr>
<tr>
<td>数据窗口</td>
<td>显示内存或文件的内容</td>
</tr>
<tr>
<td>堆栈窗口</td>
<td>显示当前线程的堆栈</td>
</tr>
</tbody></table>
<h2 id="打开-TraceMe"><a href="#打开-TraceMe" class="headerlink" title="打开 TraceMe"></a>打开 TraceMe</h2><p><img src="../img/uTools_1680273647953.png" alt="TraceMe"></p>
<h3 id="入口点"><a href="#入口点" class="headerlink" title="入口点"></a>入口点</h3><p><img src="../img/uTools_1680278193444.png" alt="入口点"></p>
<h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><h3 id="序列号验证过程"><a href="#序列号验证过程" class="headerlink" title="序列号验证过程"></a>序列号验证过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph</span><br><span class="line">A[输入姓名] --&gt;|GetDlgItemTextA 函数从编辑框中提取字符| B[计算机序列号]</span><br><span class="line">B --&gt;|调用 Istrcmp 函数进行字符比较| C&#123;比较序列号&#125;</span><br><span class="line">C --&gt;|N| D[错误对话框]</span><br><span class="line">C --&gt;|Y| E[正确对话框]</span><br></pre></td></tr></table></figure>

<h3 id="跟踪-GetDlgItemTextA"><a href="#跟踪-GetDlgItemTextA" class="headerlink" title="跟踪 GetDlgItemTextA"></a>跟踪 GetDlgItemTextA</h3><p>按“Crtl+G”打开输入表达式跟随，输入 GetDlgItemTextA</p>
<p><img src="../img/uTools_1680279373010.png" alt="GetDlgItemTextA"></p>
<p>找到 GetDlgItemTextA，双击那一行的十六进制数据，按“F2”设置断点</p>
<p><img src="../img/uTools_1680279584614.png" alt="GetDlgItemTextA"></p>
<p>按“F9” 运行程序，在输入框输入数据，点击 check</p>
<p><img src="../img/uTools_1680279918903.png" alt="TraceMe"></p>
<p><img src="../img/uTools_1680279940383.png" alt="GetDlgItemTextA"></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP</title>
    <url>/2023/03/25/UDP/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>UDP（User Datagram Protocol）是一种无连接的、不可靠的数据报传输协议，常用于 Internet 上的数据传输。UDP 协议不进行连接建立和释放操作，也不保证数据传输的可靠性和完整性，因此在传输过程中，数据包可能会丢失、重复或乱序等。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>UDP 协议具有以下特点：</p>
<ul>
<li>无连接：UDP 协议不需要进行连接建立和释放操作，数据包的传输是一次独立的操作。</li>
<li>不可靠：UDP 协议不保证数据传输的可靠性和完整性，数据包可能会丢失、重复或乱序等。</li>
<li>单播、广播和多播：UDP 协议支持单播、广播和多播等数据包的传输方式。</li>
<li>简单、高效：UDP 协议的数据包结构简单，传输效率高，适用于实时性要求较高的场景，如音视频通信等。</li>
</ul>
<p>由于 UDP 协议不进行连接建立和释放操作，以及数据包的确认和重传等操作，因此它的传输效率比 TCP 协议更高。但是，由于 UDP 协议不保证数据传输的可靠性和完整性，因此在传输重要的数据时，需要使用其他方式进行保障，如应用层的重传机制、冗余校验等。</p>
<h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+--------+--------+--------+--------+ </span><br><span class="line">|     Source      |   Destination   | </span><br><span class="line">|      Port       |      Port       | </span><br><span class="line">+--------+--------+--------+--------+ </span><br><span class="line">|                 |                 | </span><br><span class="line">|     Length      |    Checksum     | </span><br><span class="line">+--------+--------+--------+--------+ </span><br><span class="line">|                                   |  </span><br><span class="line">|               data                | </span><br><span class="line">+--------+--------+--------+--------+      </span><br></pre></td></tr></table></figure>

<ul>
<li>源端口号（Source Port）：占用 16 位，指定发送方的端口号。</li>
<li>目的端口号（Destination Port）：占用 16 位，指定接收方的端口号。</li>
<li>数据长度（Length）：占用 16 位，指定 UDP 数据段的长度。</li>
<li>校验和（Checksum）：占用 16 位，用于检验 UDP 数据段是否有误。</li>
<li>数据（Data）：占用可变长度，包含了实际传输的数据。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>UML</title>
    <url>/2023/04/14/UML/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>VTLE</title>
    <url>/2023/03/30/VTLE/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>“VTLE” 是 Virtualized Time-Locked Encryption 的缩写，指的是基于虚拟化的时间锁加密技术。它是一种新型的加密技术，能够在保证数据安全性的同时，实现数据的可控共享和可审计性。</p>
<p>VTLE 技术的核心思想是利用虚拟化技术将数据与密钥分离，并通过时间锁保护密钥。具体来说，VTLE 技术将密钥放在一个加密容器中，并设置时间锁，只有在设定的时间到达后才能解密并获得密钥。同时，VTLE 技术还可以通过虚拟机实现密钥与数据的分离，确保密钥不会被窃取。</p>
<p>与传统的加密技术相比，VTLE 技术具有以下优点：</p>
<ul>
<li>数据可控共享：通过虚拟化技术，VTLE 技术可以将数据和密钥分离，实现数据的可控共享，可以灵活地控制数据的访问权限。</li>
<li>密钥安全性高：VTLE 技术将密钥放在一个加密容器中，并设置时间锁，保证密钥的安全性。</li>
<li>数据可审计性：VTLE 技术可以通过虚拟化技术实现数据的记录和审计，保证数据的可审计性。</li>
</ul>
<p>总之，VTLE 技术是一种新型的加密技术，具有数据可控共享、密钥安全性高、数据可审计性等优点，可以为数据安全提供更好的保障。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>WOW64</title>
    <url>/2023/03/31/WOW64/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>WOW64 是 Windows 操作系统中的一种兼容性层，它允许 32 位应用程序运行在 64 位 Windows 系统上。WOW64 被包含在所有 64 位版本的 Windows 中，包括 Windows XP，Windows Vista，Windows 7，Windows 8和Windows 10。它允许 32 位应用程序访问 64 位 Windows 操作系统和硬件资源，如内存和处理器速度，同时仍然保持与 32 位应用程序的兼容性。WOW64 层还为 64 位 Windows 系统上的 32 位驱动程序和其他系统组件提供支持。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL</title>
    <url>/2023/04/18/WSL/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Win32 API</title>
    <url>/2023/03/30/Win32-API/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Win32 API 是 Windows 操作系统的核心应用程序编程接口（Application Programming Interface），为开发 Windows 应用程序提供了一组标准的函数和数据结构。它包含了大量的系统级函数，可以访问 Windows 操作系统的许多系统功能，如文件系统、系统配置、网络、进程管理、窗口管理、用户权限等等。</p>
<p>在使用 Win32 API 时，需要了解一些基本的概念和技术，如消息循环、窗口过程、控件、资源等等。使用 Win32 API 进行开发可以获得更高的灵活性和更高的性能，但需要投入更多的时间和精力。同时，也可以使用基于 Win32 API 的开发框架，如 MFC（Microsoft Foundation Classes）和 ATL（Active Template Library）等，来简化开发过程。</p>
<p>Win32 API是面向 C/C++ 编程语言的，可以使用 Visual Studio 等开发工具进行开发。近年来，随着 C++11 等新标准的出现，也可以使用现代 C++ 编写 Win32 应用程序。</p>
<h2 id="主要动态链接库"><a href="#主要动态链接库" class="headerlink" title="主要动态链接库"></a>主要动态链接库</h2><h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>由 KERNEL32.DLL 实现，操作系统系统的核心功能服务，包括进程与线程控制、内存管理、文件访问等</p>
<h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><p>由 USER32.DLL 实现，负责处理用户接口，包括键盘和鼠标输入、窗口和菜单管理等</p>
<h3 id="GDI"><a href="#GDI" class="headerlink" title="GDI"></a>GDI</h3><p>由 GDI32.DLL 实现，图像设备接口，允许程序在屏幕和打印机上显示文本和图像</p>
<h3 id="对象安全性"><a href="#对象安全性" class="headerlink" title="对象安全性"></a>对象安全性</h3><h3 id="注册表操作"><a href="#注册表操作" class="headerlink" title="注册表操作"></a>注册表操作</h3><p>ADAVAPI32.DLL</p>
<h3 id="通用控件"><a href="#通用控件" class="headerlink" title="通用控件"></a>通用控件</h3><p>COMCTL32.DLL</p>
<h3 id="公共对话框"><a href="#公共对话框" class="headerlink" title="公共对话框"></a>公共对话框</h3><p>COMDLG32.DLL</p>
<h3 id="用户界面外壳"><a href="#用户界面外壳" class="headerlink" title="用户界面外壳"></a>用户界面外壳</h3><p>SHELL32.DLL</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>NETAPI32.DLL</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows hook</title>
    <url>/2023/03/30/Windows-hook/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Windows hook 是一种 Windows 操作系统提供的机制，允许程序截获和处理系统级事件或消息。应用程序可以通过注册钩子函数来捕获和处理很多系统级事件或消息，例如键盘输入、鼠标事件、窗口创建和销毁、窗口消息等。在钩子函数中，程序可以对事件或消息进行修改、过滤、延迟处理等操作，从而实现一些有用的功能，例如全局热键、鼠标指针的跟踪、录制和回放用户的操作等。</p>
<p>Windows hook 机制分为两种类型：全局钩子和局部钩子。全局钩子能够监视整个系统的事件和消息，而局部钩子只能监视当前进程的事件和消息。全局钩子需要在 DLL 中实现，并通过安装到系统的消息队列中来工作。而局部钩子则直接安装到应用程序的消息队列中。</p>
<p>Windows hook 机制提供了一种非常灵活和强大的方式来监视和处理系统级事件和消息。但是，由于钩子函数运行在系统级别，因此使用不当可能会对系统的稳定性和安全性造成影响。因此，在使用 Windows hook 时需谨慎，避免出现不可预见的结果。</p>
<h2 id="常用-hook"><a href="#常用-hook" class="headerlink" title="常用 hook"></a>常用 hook</h2><h3 id="消息钩子"><a href="#消息钩子" class="headerlink" title="消息钩子"></a>消息钩子</h3><ul>
<li>鼠标钩子：允许程序监视和处理鼠标事件，例如鼠标移动、单击、双击等。</li>
<li>键盘钩子：允许程序监视和处理键盘事件，例如按键、释放键等。</li>
<li>窗口钩子：允许程序监视和处理窗口事件，例如创建窗口、销毁窗口、移动窗口、改变窗口大小等。</li>
<li>系统消息钩子：允许程序监视和处理系统消息，例如定时器消息、输入消息、网络消息等。</li>
<li>线程钩子：允许程序监视和处理线程事件，例如线程创建、线程退出、线程挂起、线程恢复等。</li>
<li>Shell 钩子：允许程序监视和处理 Shell 事件，例如 Shell 启动、Shell 关闭、Shell 菜单操作等。</li>
</ul>
<h3 id="IAT-HOOK"><a href="#IAT-HOOK" class="headerlink" title="IAT HOOK"></a>IAT HOOK</h3><p>IAT hook 是一种常见的 Hook 技术，指的是修改程序导入表中的函数地址，从而截获程序对该函数的调用。IAT，即 Import Address Table，是 PE 文件格式中的一部分，记录了程序导入的函数和DLL文件的名称及地址等信息。在程序运行时，系统会根据 IAT 中的信息，将 DLL 文件加载到内存中，并将 DLL 中导出的函数地址填充到 IAT 中对应的位置，以便程序调用。</p>
<p>IAT hook 攻击者会修改程序的 IAT 表中的函数地址，将其指向攻击者自己编写的恶意代码。当程序调用被修改的函数时，就会跳转到攻击者的代码执行，攻击者可以利用这个机会实现一些恶意行为，例如窃取数据、篡改数据、植入恶意代码等。</p>
<p>为了防止 IAT hook 攻击，可以采取以下措施：</p>
<p>加载 DLL 文件时，校验 DLL 的数字签名，确保 DLL 文件未被篡改。</p>
<p>对 IAT 表中的函数地址进行校验，确保函数地址的合法性。</p>
<p>对 IAT 表进行加密或混淆，使攻击者无法轻易地修改其中的函数地址。</p>
<p>定期检查程序的 IAT 表，发现异常情况及时进行处理。</p>
<p>总之，IAT hook 技术是一种常见的 Hook 技术，可以被黑客用来攻击程序和窃取数据。为了保护程序和数据的安全，需要采取有效的防护措施来防止 IAT hook 攻击。</p>
<h3 id="EAT-HOOK"><a href="#EAT-HOOK" class="headerlink" title="EAT HOOK"></a>EAT HOOK</h3><p>EAT Hook 是一种 Hook 技术，指的是修改程序的导出表（Export Address Table，EAT），从而截获其他程序对该程序的调用。EAT 是 PE 文件格式中的一部分，记录了程序导出的函数和函数地址等信息。在程序运行时，其他程序可以通过 EAT 表中的函数地址调用该程序导出的函数。</p>
<p>EAT Hook 攻击者会修改程序的 EAT 表中的函数地址，将其指向攻击者自己编写的恶意代码。当其他程序调用该程序导出的函数时，就会跳转到攻击者的代码执行，攻击者可以利用这个机会实现一些恶意行为，例如窃取数据、篡改数据、植入恶意代码等。</p>
<p>为了防止 EAT Hook 攻击，可以采取以下措施：</p>
<p>加载 DLL 文件时，校验 DLL 的数字签名，确保 DLL 文件未被篡改。</p>
<p>对 EAT 表中的函数地址进行校验，确保函数地址的合法性。</p>
<p>对 EAT 表进行加密或混淆，使攻击者无法轻易地修改其中的函数地址。</p>
<p>定期检查程序的 EAT 表，发现异常情况及时进行处理。</p>
<p>总之，EAT Hook 技术是一种常见的 Hook 技术，可以被黑客用来攻击程序和窃取数据。为了保护程序和数据的安全，需要采取有效的防护措施来防止 EAT Hook 攻击。</p>
<h3 id="SSDT-Hook"><a href="#SSDT-Hook" class="headerlink" title="SSDT Hook"></a>SSDT Hook</h3><p>SSDT Hook（System Service Descriptor Table Hook）是指黑客通过修改 Windows 操作系统内核的 System Service Descriptor Table（SSDT）表中的函数地址，从而截获系统调用（system call），并将其指向黑客自己编写的恶意代码。这种攻击方法可以用于实现恶意软件的隐藏和绕过安全检测等目的。</p>
<p>Windows 操作系统中的每个系统调用都有一个系统服务例程来实现，这些系统服务例程的地址存储在 SSDT 表中。当进程调用系统服务例程时，系统会根据 SSDT 表中的信息，找到对应的系统服务例程并执行。黑客通过修改 SSDT 表中的函数地址，可以将系统调用重定向到自己编写的恶意代码，从而实现恶意行为。</p>
<p>为了防止 SSDT Hook 攻击，可以采取以下措施：</p>
<p>加强 Windows 操作系统的内核安全性，阻止黑客修改 SSDT 表。</p>
<p>对 SSDT 表中的函数地址进行校验，确保函数地址的合法性。</p>
<p>对 SSDT 表进行加密或混淆，使攻击者无法轻易地修改其中的函数地址。</p>
<p>定期检查 SSDT 表，发现异常情况及时进行处理。</p>
<p>总之，SSDT Hook 技术是一种恶意软件使用的高级攻击技术，可以用于实现恶意软件的隐藏和绕过安全检测等目的。为了保护系统和数据的安全，需要采取有效的防护措施来防止 SSDT Hook 攻击。</p>
<h3 id="IDT-HOOK"><a href="#IDT-HOOK" class="headerlink" title="IDT HOOK"></a>IDT HOOK</h3><p>IDT Hook（Interrupt Descriptor Table Hook）是指黑客通过修改 Windows 操作系统内核的中断描述符表（Interrupt Descriptor Table，IDT）表中的函数地址，从而截获和篡改中断处理过程，从而实现恶意行为。这种攻击方法可以用于实现恶意软件的隐藏和绕过安全检测等目的。</p>
<p>Windows 操作系统中的中断处理程序是由中断描述符表（IDT）控制的。IDT 表是一个中断的入口表，用于存放中断处理程序的地址。当一个中断请求到达处理器时，处理器会查找 IDT 表中对应的中断处理程序的地址，并跳转到该地址执行中断处理程序。黑客通过修改 IDT 表中的中断处理程序地址，可以将中断请求重定向到自己编写的恶意代码，从而实现恶意行为。</p>
<p>为了防止 IDT Hook 攻击，可以采取以下措施：</p>
<p>加强 Windows 操作系统的内核安全性，阻止黑客修改 IDT 表。</p>
<p>对 IDT 表中的中断处理程序地址进行校验，确保地址的合法性。</p>
<p>对 IDT 表进行加密或混淆，使攻击者无法轻易地修改其中的中断处理程序地址。</p>
<p>定期检查 IDT 表，发现异常情况及时进行处理。</p>
<p>总之，IDT Hook 技术是一种恶意软件使用的高级攻击技术，可以用于实现恶意软件的隐藏和绕过安全检测等目的。为了保护系统和数据的安全，需要采取有效的防护措施来防止 IDT Hook 攻击。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 内存分布情况</title>
    <url>/2023/03/31/Windows-%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>内核空间（Kernel Space）：内核空间是操作系统内核运行的区域，通常占用了系统的前 2GB 内存空间。这个区域包括操作系统内核代码、驱动程序、中断向量表等。</li>
<li>用户空间（User Space）：用户空间是用户应用程序运行的区域，通常占用了系统剩余的内存空间。这个区域包括用户应用程序代码、数据、堆栈等。<br>堆是内核空间中专门用于动态分配内存的区域，它与用户空间中的堆是不同的。内核堆通常包括非常小的内存块，用于管理内核数据结构和驱动程序等。</li>
<li>非分页池（Non-Paged Pool）：非分页池是一种特殊的内存池，用于存储操作系统内核数据结构和驱动程序等，这些数据结构在操作系统运行期间不能被交换到磁盘上。</li>
<li>分页池（Paged Pool）：分页池是一种特殊的内存池，用于存储操作系统内核数据结构和驱动程序等，这些数据结构在操作系统运行期间可以被交换到磁盘上。</li>
<li>内存映射文件（Memory-Mapped File）：内存映射文件是一种特殊的文件访问方式，将文件映射到内存中，以加快文件的访问速度。内存映射文件通常使用 MapViewOfFile 函数实现。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 内存管理</title>
    <url>/2023/03/26/Windows-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Windows 内存管理是操作系统管理系统内存的一组方法和技术。以下是 Windows 内存管理的一些主要方面：</p>
<ul>
<li>虚拟内存：Windows 使用虚拟内存技术，允许应用程序使用比物理内存更大的内存空间。虚拟内存使用物理内存和硬盘上的虚拟内存页面文件来管理内存。</li>
<li>进程地址空间：每个进程都有自己的地址空间，其中包含应用程序代码、堆、栈以及其他内存区域。Windows 管理进程地址空间的方式包括调整地址空间大小、保护内存区域以及映射共享内存等。</li>
<li>内存分配：Windows 提供了内存分配函数，例如 GlobalAlloc、HeapAlloc 和 VirtualAlloc 等，用于动态分配内存。这些函数根据内存池的实际情况来分配和释放内存。</li>
<li>内存管理器：Windows 内存管理器负责管理系统内存。内存管理器通过虚拟内存和物理内存之间的映射来管理系统内存。它还跟踪内存使用情况，重用已分配但未使用的内存以及回收不再使用的内存。</li>
<li>内存优化：Windows 提供了一些内存优化工具，例如内存诊断工具和内存压缩工具，用于帮助用户优化系统内存使用。这些工具可以查找内存泄漏、优化内存分配以及压缩内存页面文件等。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 消息机制</title>
    <url>/2023/03/30/Windows-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Windows 消息机制是 Windows 操作系统中的一种基本通信机制，用于应用程序之间的消息传递和交互。Windows 消息机制基于消息队列（Message Queue）和消息处理函数（Window Procedure），可以实现应用程序之间的高效通信和响应。</p>
<p>在 Windows 消息机制中，每个应用程序都有自己的窗口句柄（Window Handle），用于表示应用程序的窗口。当应用程序需要发送消息或者接收消息时，可以通过窗口句柄和消息类型来实现，具体步骤如下：</p>
<ul>
<li>创建窗口：应用程序可以使用 CreateWindow 函数或者 CreateWindowEx 函数创建窗口，并获得窗口句柄。</li>
<li>发送消息：应用程序可以使用 SendMessage 函数或者 PostMessage 函数向其他窗口发送消息。SendMessage 函数是同步的，它会等待接收端处理完消息后再返回结果；而 PostMessage 函数是异步的，它会将消息放入接收端的消息队列中，然后立即返回。</li>
<li>处理消息：每个窗口都有一个消息处理函数（Window Procedure），用于处理接收到的消息。当接收到消息时，Windows 操作系统会调用窗口的消息处理函数来处理消息，并返回处理结果。</li>
<li>回调函数：应用程序也可以使用回调函数来处理消息，回调函数是在应用程序的上下文中执行的函数，用于处理特定类型的消息。</li>
</ul>
<p>需要注意的是，在使用 Windows 消息机制时，需要遵循 Windows 消息的格式和类型，以确保消息的正确传递和处理。同时，也需要注意避免消息循环和死锁等问题，以确保应用程序的稳定性和可靠性。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 虚拟化</title>
    <url>/2023/03/30/Windows-%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    <content><![CDATA[<p>Windows 线程是由操作系统内核创建和管理的，每个线程都有自己的线程控制块（Thread Control Block，TCB），用于存储线程的状态信息和上下文环境。TCB 包含了以下几个方面的信息：</p>
<p>线程的状态信息，例如运行状态、阻塞状态、挂起状态等。</p>
<p>线程的上下文环境，包括处理器的寄存器、堆栈、程序计数器等。</p>
<p>线程的优先级和调度信息，例如线程的调度策略、时间片大小等。</p>
<p>线程的安全对象，例如线程的同步对象、事件对象等。</p>
<p>当线程需要被挂起或恢复时，操作系统会将线程的上下文环境保存到线程控制块中，以便后续恢复。当线程需要被调度执行时，操作系统会从线程控制块中恢复线程的上下文环境，并将线程的状态设置为运行状态。</p>
<p>在 Windows 中，线程控制块是由操作系统内核创建和管理的，程序员无法直接访问和修改线程控制块中的信息。但是，程序员可以通过系统提供的 API 函数来获取和修改线程的状态信息和上下文环境，例如 GetThreadContext、SetThreadContext、SuspendThread、ResumeThread 等函数。</p>
<p>总之，Windows 线程是由操作系统内核创建和管理的，每个线程都有自己的线程控制块（TCB），用于存储线程的状态信息和上下文环境。操作系统会将线程的上下文环境保存到线程控制块中，以便后续恢复，程序员可以通过系统提供的 API 函数来获取和修改线程的状态信息和上下文环境。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 进程</title>
    <url>/2023/03/31/Windows-%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Windows 进程是指正在运行在 Windows 操作系统中的程序实例。每个进程都有自己的内存空间和资源，可以独立运行和终止。在 Windows 中，进程可以通过任务管理器或其他进程管理工具进行查看和管理。</p>
<p>Windows 进程可以分为系统进程和用户进程两种类型。系统进程是指由操作系统启动并运行的进程，如系统服务、后台程序等。用户进程是指由用户启动的程序或应用，如浏览器、文本编辑器、游戏等。</p>
<p>每个 Windows 进程都有一个唯一的进程标识符（PID），用于标识进程的身份。进程还可以包含多个线程，每个线程也有自己的标识符和执行代码。</p>
<p>Windows 进程的管理包括查看进程信息、结束进程、启动新进程等操作。可以通过任务管理器或其他进程管理工具来实现。此外，还可以通过系统设置和组策略等方式来管理和配置系统中的进程。</p>
<h2 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h2><p>Windows 进程信息包含了进程的各种属性和状态，如进程 ID、父进程 ID、进程优先级、进程资源使用情况、进程的打开句柄、进程的命令行参数等。Windows 中的进程信息可以通过任务管理器、命令行工具和系统API等方式进行访问和查看。</p>
<p>Windows 任务管理器是一个常用的工具，它可以查看当前所有运行的进程，并显示它们的 CPU 和内存占用情况。任务管理器还可以结束进程、启动新进程、查看进程详细信息等操作。</p>
<p>除了任务管理器外，Windows 还提供了一些命令行工具和 API，例如 tasklist、taskkill、GetProcessId、GetProcessMemoryInfo 等，可以用于查看进程信息、结束进程、获取进程资源使用情况等操作。这些工具和 API 可以在命令提示符或 PowerShell 中使用，也可以在编写 Windows 应用程序时调用。</p>
<p>在 Windows 中，进程信息保存在操作系统的内存中，可以通过系统 API 和内核函数来访问和操作。Windows API 包含了丰富的进程管理和监控函数，可以实现对进程的启动、结束、查看、监控等操作。</p>
<h2 id="进程链"><a href="#进程链" class="headerlink" title="进程链"></a>进程链</h2><p>在 Windows 中，进程链（Process Chain）是指父进程和其直接或间接创建的所有子进程之间的关系链。每个进程都有一个父进程，除了系统启动进程 System Idle Process 和 Session Manager 进程 smss.exe 之外，它们是所有进程的祖先进程。</p>
<p>Windows 中的进程链可以通过任务管理器和命令行工具等方式进行查看和管理。任务管理器可以列出当前所有进程的信息，包括进程 ID、进程名称、进程状态等，也可以在详细信息页面中查看进程的父进程 ID 和子进程 ID 等信息。在命令行中，可以使用 tasklist 命令来列出所有进程的信息，使用 taskkill 命令来结束进程。</p>
<p>在 Windows 中，通过进程链可以实现进程管理、进程间通信、进程间协作等功能。进程链可以用于实现父进程与子进程之间的数据共享和通信，也可以用于实现进程的协作和协同工作。例如，父进程可以启动多个子进程来执行不同的任务，子进程之间可以通过管道、共享内存等方式进行数据交换和通信。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>X11 协议</title>
    <url>/2023/03/30/X11-%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>X11 协议是一种用于图形用户界面（GUI）的网络协议，用于在 Unix 和 Linux 系统中实现窗口系统和图形界面。X11 协议最初由麻省理工学院开发，现在已经成为了 Unix 和 Linux 系统中最常用的窗口系统协议。</p>
<p>X11 协议的核心思想是将窗口系统分为两部分：服务器和客户端。服务器负责维护窗口系统的状态，并将客户端请求转换为图形显示。客户端则负责维护用户的输入和输出，并将用户的输入发送给服务器进行处理。</p>
<p>X11 协议定义了一组协议规范和 API，用于定义窗口系统和图形界面的各种属性和功能，如窗口创建、绘图、事件处理、字体管理、颜色管理等。通过这些规范和 API，开发人员可以在 Unix 和 Linux 系统中实现各种 GUI 应用程序和窗口系统。</p>
<p>在 Qt 中，X11 协议是实现 GUI 应用程序的重要基础之一，通过 Xlib 库和 XCB 库与 X11 服务器通信，使用 X11 窗口系统 API 创建和管理窗口，使用 X11 事件系统处理 GUI 事件。通过 Qt 的封装和抽象，开发人员可以更加方便地使用 X11 协议实现 GUI 应用程序和窗口系统。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>bind、call 和 apply</title>
    <url>/2023/02/07/bind%E3%80%81call-%E5%92%8C-apply/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><code>call</code>、<code>apply</code> 和 <code>bind</code> 作用是改变函数执行时的上下文，简而言之就是改变函数运行时的 <code>this</code> 指向</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">test</span> = <span class="string">&quot;lucy&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="string">&quot;martin&quot;</span>,</span><br><span class="line">  <span class="attr">say</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">test</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">say</span>(); <span class="comment">// &quot;martin&quot;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">say</span>, <span class="number">0</span>); <span class="comment">// &quot;lucy&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">say</span>.<span class="title function_">bind</span>(obj), <span class="number">0</span>); <span class="comment">// &quot;martin&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">test</span> = <span class="string">&quot;lucy&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="string">&quot;martin&quot;</span>,</span><br><span class="line">  <span class="attr">say</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">test</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">say</span>(); <span class="comment">// &quot;martin&quot;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">say</span>, <span class="number">0</span>); <span class="comment">// &quot;lucy&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p><code>apply</code> 接受两个参数，第一个参数是 <code>this</code> 的指向，第二个参数是接受的参数，以数组的形式传入</p>
<p>改变 <code>this</code> 指向后会立即执行，且此方法只是临时改变 <code>this</code> 指向一次</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">myname</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">apply</span>(obj, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// this 指向 obj</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 严格模式下是 undefined，否则是 window</span></span><br><span class="line"><span class="comment">// 当第一个参数为 null、undefined 的时候，默认指向 window</span></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 严格模式下是 null，否则是 null</span></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="literal">undefined</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 严格模式下是 undefined，否则是 window</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">myname</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">fn.<span class="title function_">apply</span>(obj, [<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p><code>call</code> 方法的第一个参数也是 <code>this</code> 的指向，后面传入的是一个参数列表</p>
<p>跟 <code>apply</code> 一样，改变 <code>this</code> 指向后原函数会立即执行，且此方法只是临时改变 <code>this</code> 指向一次</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">myname</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">call</span>(obj, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// this 指向 obj</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 严格模式下是 undefined，否则是 window</span></span><br><span class="line"><span class="comment">// 当第一个参数为 null、undefined 的时候，默认指向 window</span></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 严格模式下是 null，否则是 window</span></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">undefined</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 严格模式下是 undefined，否则是 window</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">myname</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">fn.<span class="title function_">call</span>(obj, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// this 指向 obj</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 严格模式下是 undefined，否则是 window</span></span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 严格模式下是 null，否则是 window</span></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">undefined</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind 方法和 call 很相似，第一个参数也是 <code>this</code> 的指向，后面传入的也是一个参数列表（但是这个参数列表可以分多次传入）</p>
<p>改变 <code>this</code> 指向后不会立即执行，而是返回一个永久改变 <code>this</code> 指向的函数</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span>, ...args: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bindFn = fn.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">bindFn</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> bindFn = fn.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">bindFn</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从上面可以看到，<code>apply</code>、<code>call</code> 和 <code>bind</code> 三者的区别在于：</p>
<ul>
<li>三者都可以改变函数的 <code>this</code> 对象指向</li>
<li>三者第一个参数都是 <code>this</code> 要指向的对象，如果没有这个参数或者参数为 <code>undefined</code> 或者 <code>null</code>，则默认指向全局 <code>window</code></li>
<li>三者都可以传参，但是 <code>apply</code> 是数组，而 <code>call</code> 是列表，且 <code>apply</code> 和 <code>call</code> 是一次性传入参数，而 <code>bind</code> 可以分为多次传入</li>
<li><code>bind</code> 是返回绑定 <code>this</code> 之后的函数，<code>apply</code> 和 <code>call</code> 则是立即执行</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现 <code>bind</code> 的步骤，我们可以分解成为三部分：</p>
<ul>
<li>修改 <code>this</code> 指向</li>
<li>动态传递参数</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：只在 bind 中传递函数参数</span></span><br><span class="line">fn.<span class="title function_">bind</span>(obj, <span class="number">1</span>, <span class="number">2</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：在 bind 中传递函数参数，也在返回函数中传递参数</span></span><br><span class="line">fn.<span class="title function_">bind</span>(obj, <span class="number">1</span>)(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>兼容 <code>new</code> 关键字</li>
</ul>
<p>代码如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="attr">myBind</span>: <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    context: <span class="built_in">Object</span> | <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    ...argument: <span class="built_in">number</span>[] | <span class="built_in">string</span>[]</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) =&gt;</span> <span class="function">(<span class="params"><span class="variable language_">this</span>: <span class="built_in">Function</span> | <span class="built_in">void</span>, ...argument: <span class="built_in">number</span>[] | <span class="built_in">string</span>[]</span>) =&gt;</span> <span class="title class_">Function</span>;</span><br><span class="line">  <span class="keyword">new</span> (...<span class="attr">args</span>: <span class="built_in">number</span>[] | <span class="built_in">string</span>[]): <span class="title class_">Function</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  context: <span class="built_in">Object</span> | <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">  ...argument: <span class="built_in">number</span>[] | <span class="built_in">string</span>[]</span></span><br><span class="line"><span class="params"></span>): <span class="function">(<span class="params"><span class="variable language_">this</span>: <span class="built_in">Function</span> | <span class="built_in">void</span></span>) =&gt;</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">const</span> args = [...argument],</span><br><span class="line">    fn = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="variable language_">this</span>: <span class="built_in">Function</span> | <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">    ...argument: <span class="built_in">number</span>[] | <span class="built_in">string</span>[]</span></span><br><span class="line"><span class="params">  </span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="keyword">new</span> <span class="title function_">fn</span>(...argument) : context,</span><br><span class="line">      args.<span class="title function_">concat</span>(...argument)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context, ...argument</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">const</span> args = [...argument],</span><br><span class="line">    fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params">...argument</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="keyword">new</span> <span class="title function_">fn</span>(...argument) : context,</span><br><span class="line">      args.<span class="title function_">concat</span>(...argument)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ fstream 库</title>
    <url>/2023/03/25/c-fstream-%E5%BA%93/</url>
    <content><![CDATA[<p>fstream 是 C++ 标准库中的一个输入输出库，用于读写文件。通过 fstream 库，可以创建文件、打开文件、读取文件、写入文件等。fstream 库中包括了三个类：</p>
<ul>
<li>ifstream：输入文件流，用于从文件中读取数据。</li>
<li>ofstream：输出文件流，用于向文件中写入数据。</li>
<li>fstream：文件流，既可以读取文件，也可以向文件中写入数据。</li>
</ul>
<p>fstream 库中的主要函数和操作如下：</p>
<p>打开文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">file</span><span class="params">(<span class="string">&quot;filename&quot;</span>, mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，filename 是文件名，mode 是打开方式（如in、out、app等）。</p>
<p>关闭文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p>读取文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">file &gt;&gt; data;</span><br></pre></td></tr></table></figure>

<p>其中，file 是已打开的文件对象，data 是要读取的数据。</p>
<p>写入文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">file &lt;&lt; data;</span><br></pre></td></tr></table></figure>

<p>其中，file 是已打开的文件对象，data 是要写入的数据。</p>
<p>判断文件是否打开成功：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    <span class="comment">// 文件已打开</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 文件打开失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fstream 库中的函数和操作都需要使用头文件 <code>#include &lt;fstream&gt;</code> 来进行引用。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        file &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Failed to open file!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序创建了一个名为 data.txt 的文件，并向其中写入了一行文本。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ iostream 库</title>
    <url>/2023/03/25/c-iostream-%E5%BA%93/</url>
    <content><![CDATA[<p><code>iostream</code> 是C++标准库中的一个输入输出库，包含了一些常用的输入输出对象和函数，如 <code>cin</code>、<code>cout</code>、<code>cerr</code>、<code>clog</code> 等。<code>iostream</code> 库定义了输入流和输出流，它们都是模板类，可以用于读取和写入各种数据类型。<code>iostream</code> 库中的主要对象和函数如下：</p>
<h2 id="输入对象"><a href="#输入对象" class="headerlink" title="输入对象"></a>输入对象</h2><ul>
<li>cin：标准输入流，从标准输入设备（通常是键盘）读取数据。</li>
<li>istream：输入流类，是cin的基类，用于读取各种数据类型。</li>
</ul>
<h2 id="输出对象"><a href="#输出对象" class="headerlink" title="输出对象"></a>输出对象</h2><ul>
<li>cout：标准输出流，向标准输出设备（通常是显示器）输出数据。</li>
<li>cerr：标准错误输出流，向标准错误输出设备（通常也是显示器）输出数据，通常用于输出错误信息。</li>
<li>clog：日志输出流，向标准错误输出设备（通常也是显示器）输出数据，通常用于输出日志信息。</li>
<li>ostream：输出流类，是cout、cerr、clog的基类，用于输出各种数据类型。</li>
</ul>
<h2 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h2><ul>
<li>getline：从输入流中读取一行数据。</li>
<li>put、write：向输出流中写入一个字符或一段字符。</li>
<li>get、read：从输入流中读取一个字符或一段字符。</li>
<li>flush：刷新输出缓冲区，将缓冲区中的数据写入输出流中。</li>
<li>ends：终止字符串，即将 <code>\n</code> 加入末尾</li>
<li>endl：终止字符串并刷新输出缓存区</li>
</ul>
<p><code>iostream</code> 库中的对象和函数都需要使用头文件 <code>#include &lt;iostream&gt;</code> 来进行引用。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The number is: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序从标准输入设备读取一个整数，然后向标准输出设备输出这个整数。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>commit 规范设置</title>
    <url>/2023/03/03/commit-%E8%A7%84%E8%8C%83%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="git-hook"><a href="#git-hook" class="headerlink" title="git hook"></a>git hook</h2><table>
<thead>
<tr>
<th>git hook</th>
<th>执行时机</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>applypatch-msg</td>
<td>git am执行前</td>
<td>默认情况下，如果 commit-msg 启用的话，applpatch-msg 钩子在启用时会运行 commit-msg 钩子</td>
</tr>
<tr>
<td>pre-applypatc</td>
<td>git am 执行前</td>
<td>默认的 pre-applypatch 钩子在启用时运行 pre-commit 钩子（如果后者已启用）</td>
</tr>
<tr>
<td>post-applypatch</td>
<td>git am 执行后</td>
<td>这个钩子主要用于通知，不能影响 git-am 的结果</td>
</tr>
<tr>
<td>pre-commit</td>
<td>git commit 执行前</td>
<td>可以使用 git commit –no verify 命令绕过该钩子</td>
</tr>
<tr>
<td>pre-merge-commit</td>
<td>git merge 执行前</td>
<td>可以使用 git merge –no verify 命令绕过该钩子</td>
</tr>
<tr>
<td>prepare-commit-msg</td>
<td>git commit 执行之后，编辑器打开之前</td>
<td></td>
</tr>
<tr>
<td>commit-msg</td>
<td>git commit 执行前</td>
<td>可以使用 git commit –no verify 命令绕过该钩子</td>
</tr>
<tr>
<td>post-commit</td>
<td>git commit 执行后</td>
<td>不影响 git commit 的结果</td>
</tr>
<tr>
<td>pre-rebase</td>
<td>git rebase执行前</td>
<td></td>
</tr>
<tr>
<td>post-checkout</td>
<td>git checkout 或 git switch执行后如果不使用 –no-checkout 参数，则在 git clone 之后也会执行post-mergegit merge 执行后在执行git pull 时也会被调用pre-pushgit push 执行前pre-receivegit receive pack 执行前updateproc-receivepost-receivegit receive pack 执行前不影响 git receive pack 的执行结果post-update当git receive pack对 git push 作出反应并更新仓库中的引用时reference-transactionpush-to-checkout当git receive pack对 git push 作出反应并更新仓库中的引用时，以及当推送试图更新当前被签出的分支且 receive.denyCurrentBranch配置被updateInstead时pre-auto-gcgit gc –auto 执行前post-rewrite执行 git commit –amend 或 git rebase 时sendemail-validategit send-email 执行前fsmonitor-watchman配置core.fsmonitor被设置为.git/hooks/fsmonitor-watchman 或.git/hooks/fsmonitor-watchmanv2时p4-changelistgit-p4 submit 执行并编辑完changelist message 之后可以使用 git-p4 submit –no-verify绕过该钩子p4-prepare-changelistgit-p4 submit 执行后，编辑器启动前可以使用 git-p4 submit –no-verify绕过该钩子p4-post-changelistgit-p4 submit 执行后p4-pre-submitgit-p4 submit 执行前可以使用 git-p4 submit –no-verify绕过该钩子post-index-change索引被写入 read-cache.c do_write_locked_index后</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Web-项目-commit-规范设置"><a href="#Web-项目-commit-规范设置" class="headerlink" title="Web 项目 commit 规范设置"></a>Web 项目 commit 规范设置</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g commitizen</span><br><span class="line">npm install -D cz-customizable @commitlint/config-conventional @commitlint/cli husky</span><br></pre></td></tr></table></figure>

<p>安装后就可以使用 <code>git cz</code> 来 <code>commit</code></p>
<h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p><code>package.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;commitizen&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node_modules/cz-customizable&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cz-customizable&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.cz-configrc.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>.cz-config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 可选类型</span></span><br><span class="line">  <span class="attr">types</span>: [</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;feat&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;feat:     新功能&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;fix&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;fix:      修复&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;docs&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;docs:     文档变更&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;style&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;style:    代码格式(不影响代码运行的变动)&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;refactor&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;refactor: 重构&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;perf&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;perf:     性能优化&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;test&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;test:     增加测试&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;chore&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;chore:    构建过程或辅助工具的变动&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;revert&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;revert:   回退&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;build&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;build:    打包&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">value</span>: <span class="string">&#x27;ci&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;ci:       与持续集成服务有关的改动&#x27;</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 消息步骤</span></span><br><span class="line">  <span class="attr">messages</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;请选择提交类型:&#x27;</span>,</span><br><span class="line">    <span class="attr">customScope</span>: <span class="string">&#x27;请输入修改范围(可选):&#x27;</span>,</span><br><span class="line">    <span class="attr">subject</span>: <span class="string">&#x27;请简要描述提交(必填):&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&#x27;请输入详细描述(可选):&#x27;</span>,</span><br><span class="line">    <span class="attr">footer</span>: <span class="string">&#x27;请输入要关闭的issue(可选):&#x27;</span>,</span><br><span class="line">    <span class="attr">confirmCommit</span>: <span class="string">&#x27;确认使用以上信息提交？(y/n/e/h)&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 跳过问题</span></span><br><span class="line">  <span class="attr">skipQuestions</span>: [<span class="string">&#x27;footer&#x27;</span>],</span><br><span class="line">  <span class="comment">// subject文字长度默认是72</span></span><br><span class="line">  <span class="attr">subjectLimit</span>: <span class="number">72</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commitlint.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 继承的规则</span></span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&#x27;@commitlint/config-conventional&#x27;</span>],</span><br><span class="line">  <span class="comment">// 定义规则类型</span></span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="comment">// type 类型定义，表示 git 提交的 type 必须在以下类型范围内</span></span><br><span class="line">    <span class="string">&#x27;type-enum&#x27;</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="string">&#x27;always&#x27;</span>,</span><br><span class="line">      [</span><br><span class="line">        <span class="string">&#x27;feat&#x27;</span>, <span class="comment">// 新功能 feature</span></span><br><span class="line">        <span class="string">&#x27;fix&#x27;</span>, <span class="comment">// 修复 bug</span></span><br><span class="line">        <span class="string">&#x27;docs&#x27;</span>, <span class="comment">// 文档注释</span></span><br><span class="line">        <span class="string">&#x27;style&#x27;</span>, <span class="comment">// 代码格式(不影响代码运行的变动)</span></span><br><span class="line">        <span class="string">&#x27;refactor&#x27;</span>, <span class="comment">// 重构(既不增加新功能，也不是修复bug)</span></span><br><span class="line">        <span class="string">&#x27;perf&#x27;</span>, <span class="comment">// 性能优化</span></span><br><span class="line">        <span class="string">&#x27;test&#x27;</span>, <span class="comment">// 增加测试</span></span><br><span class="line">        <span class="string">&#x27;chore&#x27;</span>, <span class="comment">// 构建过程或辅助工具的变动</span></span><br><span class="line">        <span class="string">&#x27;revert&#x27;</span>, <span class="comment">// 回退</span></span><br><span class="line">        <span class="string">&#x27;build&#x27;</span>, <span class="comment">// 打包</span></span><br><span class="line">        <span class="string">&#x27;ci&#x27;</span>, <span class="comment">// 与持续集成服务有关的改动</span></span><br><span class="line">      ],</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// subject 大小写不做校验</span></span><br><span class="line">    <span class="string">&#x27;subject-case&#x27;</span>: [<span class="number">0</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx husky install</span><br><span class="line">npx husky add .husky/commit-msg</span><br></pre></td></tr></table></figure>

<p>用以下命令替换 <code>.husky/commit-msg</code> 中的 <code>undefined</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx commitlint --edit <span class="variable">$1</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>const、typeof和define</title>
    <url>/2023/04/18/const%E3%80%81typeof%E5%92%8Cdefine/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>defineProperty 实践</title>
    <url>/2023/02/08/defineProperty-%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop, descriptor);</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>object</td>
<td>要在其定义的对象</td>
</tr>
<tr>
<td>property</td>
<td>要定义或修改的属性的名称</td>
</tr>
<tr>
<td>descriptor</td>
<td>将被定义或修改的属性描述符</td>
</tr>
</tbody></table>
<h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><table>
<thead>
<tr>
<th>属性描述符</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>任意值</td>
<td>设置属性的值，默认为 undefined</td>
</tr>
<tr>
<td>writable</td>
<td>布尔值</td>
<td>设置属性是否可写入。</td>
</tr>
<tr>
<td>enumerable</td>
<td>布尔值</td>
<td>设置属性是否可被枚。</td>
</tr>
<tr>
<td>configurable</td>
<td>布尔值</td>
<td>设置属性是否可被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改</td>
</tr>
<tr>
<td>get</td>
<td>函数</td>
<td>设置被获取时执行的回调函数，默认为 undefined。</td>
</tr>
<tr>
<td>set</td>
<td>函数</td>
<td>设置被设置时执行的回调函数，默认为 undefined。</td>
</tr>
</tbody></table>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(obj) === <span class="string">&quot;[object Object]&quot;</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(obj[item]) === <span class="string">&quot;[object Object]&quot;</span>) &#123;</span><br><span class="line">        obj[item] = <span class="keyword">new</span> <span class="title class_">Observe</span>(obj[item]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, item, &#123;</span><br><span class="line">          <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">            obj[item] = val;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我要去渲染 DOM&quot;</span>);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj[item];</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="attr">_data</span>: <span class="built_in">any</span>;</span><br><span class="line">  <span class="attr">$data</span>: <span class="built_in">any</span>;</span><br><span class="line">  <span class="attr">mounted</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">&#123; data, mounted &#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_data</span> = <span class="keyword">new</span> <span class="title class_">Observe</span>(<span class="title function_">data</span>());</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = vm.<span class="property">_data</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mounted</span> = mounted.<span class="title function_">bind</span>(vm.<span class="property">_data</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">mounted</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;李华&quot;</span>,</span><br><span class="line">      <span class="attr">address</span>: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">      <span class="attr">connect</span>: &#123;</span><br><span class="line">        <span class="attr">qq</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">        <span class="attr">email</span>: <span class="string">&quot;123456@qq.com&quot;</span>,</span><br><span class="line">        <span class="attr">phone</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;小红&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/07/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo 指令</title>
    <url>/2023/02/18/hexo-%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo init [folder]</span><br></pre></td></tr></table></figure>

<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>
<p>本命令相当于执行了以下几步：</p>
<blockquote>
<p>Git clone hexo-starter 和 hexo-theme-landscape 主题到当前目录或指定目录。<br>使用 Yarn、pnpm 或 npm 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 Node.js 安装。</p>
</blockquote>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 _config.yml 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo new <span class="string">&quot;post title with whitespace&quot;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-p, –path</td>
<td>自定义新文章的路径</td>
</tr>
<tr>
<td>-r, –replace</td>
<td>如果存在同名文章，将其替换</td>
</tr>
<tr>
<td>-s, –slug</td>
<td>文章的 Slug，作为新文章的文件名和发布后的 URL</td>
</tr>
</tbody></table>
<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo new page --path about/me <span class="string">&quot;About me&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p>
<p>注意！<code>title</code> 是必须指定的！如果你这么做并不能达到你的目的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo new page --path about/me</span><br></pre></td></tr></table></figure>

<p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 me.md 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p>
<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo generate</span><br></pre></td></tr></table></figure>

<p>生成静态文件。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-d, –deploy</td>
<td>文件生成后立即部署网站</td>
</tr>
<tr>
<td>-w, –watch</td>
<td>监视文件变动</td>
</tr>
<tr>
<td>-b, –bail</td>
<td>生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td>-f, –force</td>
<td>强制重新生成文件</td>
</tr>
</tbody></table>
<p>Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。<br>使用该参数的效果接近 hexo clean &amp;&amp; hexo generate<br>-c, –concurrency  最大同时生成文件的数量，默认无限制</p>
<p>该命令可以简写为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo g</span><br></pre></td></tr></table></figure>

<h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>发表草稿。</p>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo server</span><br></pre></td></tr></table></figure>

<p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/">http://localhost:4000/</a>。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-p, –port</td>
<td>重设端口</td>
</tr>
<tr>
<td>-s, –static</td>
<td>只使用静态文件</td>
</tr>
<tr>
<td>-l, –log</td>
<td>启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody></table>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo deploy</span><br></pre></td></tr></table></figure>

<p>部署网站。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-g, –generate</td>
<td>部署之前预先生成静态文件</td>
</tr>
</tbody></table>
<p>该命令可以简写为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo d</span><br></pre></td></tr></table></figure>

<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>

<p>渲染文件。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-o, –output</td>
<td>设置输出路径</td>
</tr>
</tbody></table>
<h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo migrate &lt;<span class="built_in">type</span>&gt;</span><br></pre></td></tr></table></figure>

<p>从其他博客系统 迁移内容。</p>
<h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo clean</span><br></pre></td></tr></table></figure>

<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo list &lt;<span class="built_in">type</span>&gt;</span><br></pre></td></tr></table></figure>

<p>列出网站资料。</p>
<h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo version</span><br></pre></td></tr></table></figure>

<p>显示 Hexo 版本。</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo --safe</span><br></pre></td></tr></table></figure>

<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>
<h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo --debug</span><br></pre></td></tr></table></figure>

<p>在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p>
<h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo --silent</span><br></pre></td></tr></table></figure>

<p>隐藏终端信息。</p>
<h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 custom.yml 代替默认的 _config.yml</span></span><br><span class="line"></span><br><span class="line">npx hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高</span></span><br><span class="line"></span><br><span class="line">npx hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>

<p>自定义配置文件的路径，指定这个参数后将不再使用默认的 _config.yml。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 custom.yml 代替默认的 _config.yml</span></span><br><span class="line"></span><br><span class="line">npx hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json</span></span><br><span class="line"></span><br><span class="line">npx exo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>

<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p>
<h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo --draft</span><br></pre></td></tr></table></figure>

<p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p>
<h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx hexo --cwd /path/to/cwd</span><br></pre></td></tr></table></figure>

<p>自定义当前工作目录（Current working directory）的路径。</p>
]]></content>
  </entry>
  <entry>
    <title>i++ 和 ++i</title>
    <url>/2023/03/31/i-%E5%92%8C-i/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>i++ 和 ++i 是 C++ 中的自增运算符，它们都可以用于将变量 i 的值加 1，但它们的返回值和执行顺序略有不同。</p>
<h3 id="i"><a href="#i" class="headerlink" title="i++"></a>i++</h3><p>i++ 是后置自增运算符，它的执行顺序是先使用变量 i 的当前值，然后再将 i 的值加 1。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = i++; <span class="comment">// j = 0, i = 1</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，i++ 先将 i 的当前值 0 赋值给 j，然后再将 i 的值加 1，最终 i 的值变成了 1。</p>
<h3 id="i-1"><a href="#i-1" class="headerlink" title="++i"></a>++i</h3><p>++i 是前置自增运算符，它的执行顺序是先将变量 i 的值加 1，然后再使用 i 的新值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = ++i; <span class="comment">// j = 1, i = 1</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，++i 先将 i 的值加 1，然后再将 i 的新值 1 赋值给 j。</p>
<p>另外，i++ 返回的是 i 的原始值，而 ++i 返回的是 i 加 1 后的值。因此，i++ 和 ++i 在使用时需要根据具体情况选择合适的自增运算符。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>mbox observer</title>
    <url>/2023/06/18/mbox-observer/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>observer 函数/装饰器可以用来将 React 组件转变成响应式组件。 它用 mobx.autorun 包装了组件的 render 函数以确保任何组件渲染中使用的数据变化时都可以强制刷新组件。 observer 是由单独的 mobx-react 包提供的。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observer&#125; <span class="keyword">from</span> <span class="string">&quot;mobx-react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timerData = <span class="title function_">observable</span>(&#123;</span><br><span class="line">    <span class="attr">secondsPassed</span>: <span class="number">0</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    timerData.<span class="property">secondsPassed</span>++;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@observer</span> <span class="keyword">class</span> <span class="title class_">Timer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Seconds passed: &#123; this.props.timerData.secondsPassed &#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Timer</span> <span class="attr">timerData</span>=<span class="string">&#123;timerData&#125;</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="property">body</span>);</span><br></pre></td></tr></table></figure>

<p>当 observer 需要组合其它装饰器或高阶组件时，请确保 observer 是最深处(第一个应用)的装饰器，否则它可能什么都不做。</p>
<blockquote>
<p>使用 @observer 装饰器是可选的，它和 observer(class Timer … { }) 达到的效果是一样的。</p>
</blockquote>
<h2 id="组件中的间接引用值"><a href="#组件中的间接引用值" class="headerlink" title="组件中的间接引用值"></a>组件中的间接引用值</h2><p>MobX 可以做很多事，但是它无法使原始数据类型值转变成可观察的。所以值是不可观察的，但是对象的属性可以。这意味着 @observer 实际上是对间接引用(dereference)值的反应。 那么在上面的示例中，如果是用下面这种方式初始化的，Timer 组件是不会有反应的:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Timer</span> <span class="attr">timerData</span>=<span class="string">&#123;timerData.secondsPassed&#125;</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="property">body</span>)</span><br></pre></td></tr></table></figure>

<p>在这个代码片段中只是把 secondsPassed 的当前值传递给了 Timer 组件，这个值是不可变值 0（JS 中所有的原始类型值都是不可变的）。 这个数值永远都不会改变，因此 Timer 组件不会更新。secondsPassed 的值将来会发生改变， 所以我们需要在组件中访问它。或者换句话说: 值需要通过引用来传递而不是通过（字面量）值来传递。</p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>rust 变量绑定与解构</title>
    <url>/2023/02/09/rust-%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%A7%A3%E6%9E%84/</url>
    <content><![CDATA[<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 变量不可变可以避免运行时检查从而提高性能，但是有时需要给变量重新赋值时，</span></span><br><span class="line">    <span class="comment">// 针对不可变的变量需要重新构造一个新的重名对象，而构造重名对象的过程时丧失了性能。</span></span><br><span class="line">    <span class="comment">// 一般情况下建议使用不可变变量，如果需要使用大量的临时变量则使用 mut</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, a);</span><br><span class="line">    <span class="comment">// 要想使用可以修改的变量，在变量前加 mut</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 只能修改值，不能修改类型</span></span><br><span class="line">    <span class="comment">// b = &quot;b&quot;;</span></span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;:&#123;1&#125;&quot;</span>, a, b);</span><br><span class="line">    <span class="comment">// 如果一个变量没有被使用 rust 会警告，如果一个变量不会被使用，应该在签名加下划线</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_y</span> = a;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_x</span> = b;</span><br><span class="line">    <span class="comment">// rust 解构</span></span><br><span class="line">    <span class="keyword">let</span> (_c, <span class="keyword">mut</span> _d): (<span class="type">bool</span>, <span class="type">bool</span>) = (<span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 常量不能加 mut，并且必须注明类型。并且最好大写</span></span><br><span class="line">    <span class="keyword">const</span> _E: &amp;<span class="type">str</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// 变量遮蔽</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;hello a&quot;</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">0x1A</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">0o1234567</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">0b10001111</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">123_321</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3.2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: <span class="type">f32</span> = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Struct</span> &#123;</span><br><span class="line">    e: <span class="type">i32</span>,</span><br><span class="line">    f: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (a, b, c, d, e);</span><br><span class="line">    (a, b) = (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    [c, .., d, _] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    Struct &#123; e, .. &#125; = Struct &#123; e: <span class="number">5</span>, f: <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, d);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust 基本类型</title>
    <url>/2023/02/09/rust-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><table>
<thead>
<tr>
<th>长度</th>
<th>有符号类型</th>
<th>无符号类型</th>
</tr>
</thead>
<tbody><tr>
<td>8 位</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr>
<td>16 位</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr>
<td>32 位</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>64 位</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr>
<td>128 位</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>视架构而定</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody></table>
<p>表达形式</p>
<table>
<thead>
<tr>
<th>数字字面量</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>十进制</td>
<td><code>98_222</code></td>
</tr>
<tr>
<td>十六进制</td>
<td><code>0xff</code></td>
</tr>
<tr>
<td>八进制</td>
<td><code>0o77</code></td>
</tr>
<tr>
<td>二进制</td>
<td><code>0b1111_0000</code></td>
</tr>
<tr>
<td>字节 (仅限于 <code>u8</code>)</td>
<td><code>b&#39;A&#39;</code></td>
</tr>
</tbody></table>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p><code>f32</code> 和 <code>f64</code><br>分别为 32 位大小和 64 位大小</p>
<p>会报错</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">f64</span> = <span class="number">3.2</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">f32</span> = a;</span><br></pre></td></tr></table></figure>

<p>正确写法</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3.2</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span>: <span class="type">f32</span> = a;</span><br></pre></td></tr></table></figure>

<p>浮点数无法作为 HashMap 的 key</p>
<h4 id="浮点数陷阱"><a href="#浮点数陷阱" class="headerlink" title="浮点数陷阱"></a>浮点数陷阱</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">abc</span>: (<span class="type">f32</span>, <span class="type">f32</span>, <span class="type">f32</span>) = (<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">xyz</span>: (<span class="type">f64</span>, <span class="type">f64</span>, <span class="type">f64</span>) = (<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>, (abc.<span class="number">0</span> + abc.<span class="number">1</span>).<span class="title function_ invoke__">to_bits</span>()); <span class="comment">// 3e99999a</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>, (xyz.<span class="number">0</span> + xyz.<span class="number">1</span>).<span class="title function_ invoke__">to_bits</span>()); <span class="comment">// 3fd3333333333334</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>, abc.<span class="number">2</span>.<span class="title function_ invoke__">to_bits</span>()); <span class="comment">// 3e99999a</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>, xyz.<span class="number">2</span>.<span class="title function_ invoke__">to_bits</span>()); <span class="comment">// 3fd3333333333333</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, abc.<span class="number">0</span> + abc.<span class="number">1</span> == abc.<span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, xyz.<span class="number">0</span> + xyz.<span class="number">1</span> == xyz.<span class="number">2</span>); <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(xyz.<span class="number">0</span> + xyz.<span class="number">1</span>, xyz.<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(abc.<span class="number">0</span> + abc.<span class="number">1</span>, abc.<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>代码崩溃</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">x</span> = (-<span class="number">42.0_f32</span>).<span class="title function_ invoke__">sqrt</span>();</span><br><span class="line">  <span class="built_in">assert_eq!</span>(x, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (-<span class="number">42.0_f32</span>).<span class="title function_ invoke__">sqrt</span>();</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">is_nan</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;未定义的数学行为&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp; 位与</td>
<td>相同位置均为 1 时则为 1，否则为 0</td>
</tr>
<tr>
<td></td>
<td>位或</td>
</tr>
<tr>
<td>^ 异或</td>
<td>相同位置不相同则为 1，相同则为 0</td>
</tr>
<tr>
<td>! 位非</td>
<td>把位中的 0 和 1 相互取反，即 0 置为 1，1 置为 0</td>
</tr>
<tr>
<td>&lt;&lt; 左移</td>
<td>所有位向左移动指定位数，右位补零</td>
</tr>
<tr>
<td>&gt;&gt; 右移</td>
<td>所有位向右移动指定位数，左位补零</td>
</tr>
</tbody></table>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="comment">// 编译器会进行自动推导，给予twenty i32的类型</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">twenty</span> = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">// 类型标注</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">twenty_one</span>: <span class="type">i32</span> = <span class="number">21</span>;</span><br><span class="line">  <span class="comment">// 通过类型后缀的方式进行类型标注：22是i32类型</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">twenty_two</span> = <span class="number">22i32</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有同样类型，才能运算</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">addition</span> = twenty + twenty_one + twenty_two;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, twenty, twenty_one, twenty_two, addition);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于较长的数字，可以用_进行分割，提升可读性</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">one_million</span>: <span class="type">i64</span> = <span class="number">1_000_000</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, one_million.<span class="title function_ invoke__">pow</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个f32数组，其中42.0会自动被推导为f32类型</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">forty_twos</span> = [</span><br><span class="line">    <span class="number">42.0</span>,</span><br><span class="line">    <span class="number">42f32</span>,</span><br><span class="line">    <span class="number">42.0_f32</span>,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印数组中第一个值，并控制小数位为2位</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;:.2&#125;&quot;</span>, forty_twos[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串字面量和字符串切片 &amp;str</p>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>由于 Unicode 都是 4 个字节编码，因此字符类型也是占用 4 个字节：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">xyz</span> = &#x27;👹&#x27;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;xyz)); <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>bool：true 和 false</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// 使用类型标注,显式指定f的类型</span></span><br><span class="line">    <span class="keyword">if</span> f &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;这是段毫无意义的代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>单个 unicode 字符，存储为 4 个字节</p>
<h2 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a>单元类型</h2><p>单元类型就是 <code>()</code>，可以用来作为 map 的 key</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line"><span class="built_in">println!</span>()</span><br></pre></td></tr></table></figure>

<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">Vec</span>&lt;<span class="type">f64</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> (a, b) = (<span class="string">&quot;hi&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误示范</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = (<span class="keyword">let</span> <span class="variable">a</span> = <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误示范</p>
<p>加了分号</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">        x + <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样没有返回值，会返回一个 <code>()</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>x++</code> 不成立，会报错</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">        x++</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust 安装</title>
    <url>/2023/02/09/rust-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>

<h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>使用 rustup 安装，一次输入或选择以下选项，第二个选择 MSVC 可能会出问题</p>
<ul>
<li>Customize installation</li>
<li>x86_64-pc-windows-gnu</li>
<li>stable</li>
<li>default</li>
<li>yes</li>
<li>Proceed with installation</li>
</ul>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustup self uninstall</span><br></pre></td></tr></table></figure>

<h2 id="版本查看"><a href="#版本查看" class="headerlink" title="版本查看"></a>版本查看</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustc -V</span><br><span class="line">&gt;rustc 1.56.1 (59eed8a2a 2021-11-01)</span><br><span class="line"></span><br><span class="line">cargo -V</span><br><span class="line">&gt;cargo 1.57.0 (b2e52d7ca 2021-10-21)</span><br></pre></td></tr></table></figure>

<h2 id="创建并运行"><a href="#创建并运行" class="headerlink" title="创建并运行"></a>创建并运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo new Project</span><br><span class="line">cargo run</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>style-components</title>
    <url>/2023/06/27/style-components/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>　　1、styled-components 样式化组件，主要作用是它可以编写实际的CSS代码来设计组件样式，也不需要组件和样式之间的映射，即创建后就是一个正常的React 组件，<br>　　并且可以附加样式给当前组件。 优化react组件<br>　　2、在一个组件内会将结构、样式和逻辑写在一起，虽然这违背了关注点分离的原则，但是这有利于组件间的隔离。为了顺应组件化的潮流<br>　　3、使用styled-components不需要再使用className属性来控制样式，而是将样式写成更具语义化的组件的形式<br>　　4、使用style-components会随机生成一个class名称，这样不会污染到全局变量，当然因为随机生成，维护会增加难度<br>三、基本使用<br>　　1、安装<br>csharp复制代码cnpm i styled-components -S    ||    yarn add styled-components</p>
<p>　　2、引入<br>javascript复制代码import styled from “styled-components”;</p>
<p>　　3、使用<br>javascript复制代码export const Header = styled.div<code>  width:100%;   height:1rem;   background:red      </code></p>
<p>import {Header} from “./style/index”;<br>class App extends Component{<br>　　render(){<br>　　　　return (<br>　　　　　　<Header/><br>　　　　)<br>　　}<br>}</p>
<p>四、全局默认样式引入<br>引入新的API createGlobalStyle ，在下面创建一个 GlobalStyle 变量，用 createGlobalStyle 方法把全局样式包裹在其中<br>javascript复制代码import { createGlobalStyle } from “styled-components”;<br>export const GlobalStyle = createGlobalStyle`</p>
<p>css复制代码html, body, ul, li, ol, dl, dd, dt, p, h1, h2, h3, h4, h5, h6, form, fieldset, legend, img { margin:0; padding:0; }</p>
<p>fieldset, c{ border:none; }</p>
<p>img{display: block;}</p>
<p>address, caption, cite, code, dfn, th, var { font-style:normal; font-weight:normal; }</p>
<p>ul, ol ,li{ list-style:none; }</p>
<p>body { color:#333; font:12px BASE “SimSun”,”宋体”,”Arial Narrow”,HELVETICA; background:#fff;}</p>
<p>a { color:#666; text-decoration:none; }</p>
<p>*{box-sizing:border-box}</p>
<p>body,html,#root{<br>    height: 100%;<br>    overflow: hidden;<br>}</p>
<p>javascript复制代码//将 <GlobalStyle /> 组件放在 render() 中最外层元素下面</p>
<p>import React, { Component ,Fragment} from ‘react’;<br>import {GlobalStyle} from “./reset”;<br>class App extends Component {<br>　　render() {<br>　　　　return (<br>　　　　　　<Fragment><br>　　　　　　　　<GlobalStyle/><br>　　　　　　</Fragment><br>　　　　);<br>　　}<br>}</p>
<p>export default App;</p>
<p>五、传参<br>　如果我们需要动态改变元素的样式，则可以通过传递参数的方式进行改变<br>javascript复制代码import {Header} from “style/index.js”</p>
<p>render(){<br>  return (<br>        <Header bgColor="red"/><br>    )<br>}</p>
<p>style/index.js<br>javascript复制代码import styled from “styled-components”;<br>export const Header = styled.div<code>　　width:100px; 　　height:200px; 　　props.bgColor&#125;</code>　　</p>
<p>六、继承<br>　　如果我们需要继承样式的时候我们可以通过 styled(继承的组件名称)``<br>javascript复制代码const button = styled.button<code>  border:0;   width:100px;   height:40px;   text-align:center;   color:#000;      </code></p>
<p>export const StyledButton = styled(button)<code>  color:#fff;  </code></p>
<p>七、修改组件内部标签<br>　　在调用组件的时候我们可以通过as来修改组件  as=”元素名称”<br>javascript复制代码render(){<br>  return (<br>    <Header as="p"/><br>  )<br>}    </p>
<p>Header组件内部渲染的时候就是用的p标签<br>八、定义组件属性<br>javascript复制代码export const Input = styled.input.attrs({<br>    value:(props)=&gt;props.value,<br>    name:”input”<br>})<code>  border:0;   width:100px;   height:100px;</code></p>
<p>九、背景图片引入<br>javascript复制代码import logo from “./imgs/logo.png”;</p>
<p>export const BgLogo =  styled.div<code>  width:100px;   height:200px;   background:url($&#123;logo&#125;) no-repate;  </code></p>
<p>十、塑造组件<br>　　有一种情况，一些原本就已经是组件，需要给这些组件添加样式，这时需要用到塑造组件<br>javascript复制代码import React from “react”;<br>import styled from “styled-components”;</p>
<p>const Link = ({className,children})=&gt;(<br>        <a className={className}><br>             {children}<br>         </a><br>)<br>export StyleLink = styled(Link)<code>  color:red  </code></p>
<p>十一、动画</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> move = keyframes<span class="string">`</span></span><br><span class="line"><span class="string">  0%&#123;</span></span><br><span class="line"><span class="string">         transform:rotate(0%);  </span></span><br><span class="line"><span class="string">   &#125;  </span></span><br><span class="line"><span class="string">  100%&#123;</span></span><br><span class="line"><span class="string">     transform :rotate(100%);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">TransFormDiv</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">   width:100px;</span></span><br><span class="line"><span class="string">   height:100px;</span></span><br><span class="line"><span class="string">   background:red;</span></span><br><span class="line"><span class="string">   animation:<span class="subst">$&#123;move&#125;</span> 2s;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>十二、当标签过多时需要划分太多组件，我们可以通过以下写法来简化组件的编写<br>　　&amp;代表父级</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">StyledUl</span> = styled.<span class="property">ul</span><span class="string">`</span></span><br><span class="line"><span class="string">    border:1px solid #ccc;</span></span><br><span class="line"><span class="string">    &gt;li&#123;</span></span><br><span class="line"><span class="string">         border-bottom:1px solid #green;</span></span><br><span class="line"><span class="string">         line-height:30px;</span></span><br><span class="line"><span class="string">         padding-left:20px;      </span></span><br><span class="line"><span class="string">        &amp;&gt;p&#123;</span></span><br><span class="line"><span class="string">            color:red</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">    &#125;  </span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>x86 汇编</title>
    <url>/2023/03/30/x86-%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<h2 id="x86-汇编"><a href="#x86-汇编" class="headerlink" title="x86 汇编"></a>x86 汇编</h2><p>x86 汇编是一种低级别的程序设计语言，用于编写 Intel x86 处理器的汇编代码。x86 汇编是一种直接面向硬件的编程语言，可以访问和操作处理器的寄存器、内存、I/O 端口等硬件资源，以及执行各种汇编指令，例如算术指令、逻辑指令、移位指令、比较指令、跳转指令等。</p>
<p>x86 汇编的语法比较复杂，需要了解处理器的指令集、寄存器、内存地址等硬件知识，同时也需要具备一定的编程经验和能力。x86 汇编通常用于编写操作系统、设备驱动程序、底层的系统软件、嵌入式系统等需要直接访问硬件的应用程序。</p>
<p>由于 x86 汇编直接面向硬件，可以极大地提高程序的执行速度和效率，同时也具有很高的灵活性和可移植性。但是，x86 汇编也有一些缺点，例如代码的可读性较差、编写和调试难度较大、代码的可移植性较差等。</p>
<p>总之，x86 汇编是一种低级别的程序设计语言，用于编写 Intel x86 处理器的汇编代码。x86 汇编可以访问和操作处理器的硬件资源，具有很高的执行速度和效率，但也需要具备一定的编程经验和能力。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>主动防御实现逻辑</title>
    <url>/2023/03/30/%E4%B8%BB%E5%8A%A8%E9%98%B2%E5%BE%A1%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>主动防御是指在应对攻击时采取主动措施，使攻击者难以得手或者减轻攻击的影响。实现主动防御的逻辑主要包括以下几个步骤：</p>
<ul>
<li>按照安全标准和最佳实践对系统进行加固，包括操作系统、应用程序、网络设备等方面，以减少系统被攻击的风险。</li>
<li>部署安全设备和技术，如防火墙、入侵检测系统（IDS）、入侵防御系统（IPS）等，以检测和阻止攻击行为。</li>
<li>对系统进行实时监控和日志记录，以及时发现异常事件和攻击行为。</li>
<li>针对已知的安全漏洞和攻击方式，采取相应的防御措施，如修补漏洞、限制网络访问、禁止危险操作等。</li>
<li>定期对系统进行安全评估和漏洞扫描，及时发现并修补漏洞。</li>
<li>对系统进行备份和恢复策略的规划，以保证在遭受攻击或者其他灾难时能够及时恢复。</li>
<li>对系统进行安全教育和培训，提高用户的安全意识和防范能力。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>人脸数据集网站</title>
    <url>/2023/04/14/%E4%BA%BA%E8%84%B8%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h2 id="网站（排名不分先后）"><a href="#网站（排名不分先后）" class="headerlink" title="网站（排名不分先后）"></a>网站（排名不分先后）</h2><ul>
<li><a href="https://www.seeprettyface.com/index.html">https://www.seeprettyface.com/index.html</a></li>
<li><a href="https://paperswithcode.com/dataset/aflw">https://paperswithcode.com/dataset/aflw</a></li>
<li><a href="http://www.ee.surrey.ac.uk/CVSSP/xm2vtsdb/">http://www.ee.surrey.ac.uk/CVSSP/xm2vtsdb/</a></li>
<li><a href="http://mmlab.ie.cuhk.edu.hk/projects/CelebA.html">http://mmlab.ie.cuhk.edu.hk/projects/CelebA.html</a></li>
<li><a href="http://mmlab.ie.cuhk.edu.hk/projects/TCDCN.html">http://mmlab.ie.cuhk.edu.hk/projects/TCDCN.html</a></li>
<li><a href="http://biometrics.idealtest.org/dbDetailForUser.do?id=9#/">http://biometrics.idealtest.org/dbDetailForUser.do?id=9#/</a></li>
<li><a href="https://www.cvmart.net/dataSets">https://www.cvmart.net/dataSets</a></li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 C++</title>
    <url>/2023/03/25/%E4%BB%80%E4%B9%88%E6%98%AF-C/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>C++ 是一种通用的、高效的、面向对象的编程语言，它是 C 语言的扩展。C++ 支持多种编程范式，包括面向对象、面向过程和泛型编程。C++ 的特点包括：</p>
<ul>
<li>高效性：C++ 可以直接访问计算机硬件，具有很高的性能和效率。</li>
<li>面向对象：C++ 支持面向对象编程，可以实现封装、继承和多态等特性。</li>
<li>泛型编程：C++ 支持泛型编程，可以实现通用代码和模板。</li>
<li>可移植性：C++ 的代码可以在不同的平台上运行，具有很好的可移植性。</li>
<li>强大的标准库：C++ 提供了丰富的标准库，包括输入输出、字符串处理、容器、算法等组件。</li>
</ul>
<p>C++ 广泛应用于各种领域，包括操作系统、嵌入式系统、游戏开发、科学计算、金融分析、人工智能等。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 OOP</title>
    <url>/2023/03/25/%E4%BB%80%E4%B9%88%E6%98%AF-OOP/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>OOP 是面向对象编程（Object-Oriented Programming）的缩写，是一种编程范式或编程风格，它的核心思想是将数据和操作数据的方法打包在一起，形成对象（Object）。在 OOP 中，对象是程序的基本单元，它拥有数据和行为。</p>
<p>OOP 通过封装、继承和多态等机制，使得代码更加灵活、易于扩展和维护。其中，封装是指将数据和方法放在一个抽象的单元中，防止外部直接访问和修改对象的数据，从而保护对象的状态；继承是指通过定义一个新类来继承已有的类的属性和方法，从而实现代码复用和扩展；多态是指同一种方法或操作在不同的对象上具有不同的行为和表现形式，使得程序更加灵活和易于拓展。</p>
<p>OOP 已经成为现代编程语言中最重要的编程范式之一，被广泛应用于各种应用领域，如桌面应用程序、游戏开发、网页应用程序、移动应用程序、人工智能等。其中，一些主要的OOP语言包括Java、C++、C#、Python等。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是对象</title>
    <url>/2023/03/25/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>在面向对象编程中，对象（Object）是程序的基本单元，它是一种由数据和行为组成的抽象单元。对象具有以下特点：</p>
<ul>
<li>对象有状态（State）：即对象所包含的数据，用于描述对象的特征和属性。</li>
<li>对象有行为（Behavior）：即对象所包含的方法，用于描述对象能够进行的操作。</li>
<li>对象有标识（Identity）：即对象的唯一标识，用于区分不同的对象。</li>
</ul>
<p>在程序运行时，可以创建多个对象，每个对象都有自己的状态和行为，它们之间相互独立，但也可以通过一些特定的机制（如消息传递、继承、多态等）进行交互和合作，从而实现程序的功能。</p>
<p>举个例子，如果我们定义一个汽车类（Car），那么每个汽车对象都有自己的颜色、品牌、速度等状态，也都可以加速、刹车、转弯等行为。通过创建多个汽车对象，我们可以模拟出多个汽车在路上行驶的场景，而每个汽车对象的状态和行为都是相互独立的。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是框架</title>
    <url>/2023/04/08/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>框架（Framework）是指在软件开发过程中，提供了一整套解决方案的基础架构，使得开发者可以基于该架构进行应用程序的开发，而不必从头开始设计和实现所有功能。框架通常由一系列的库、工具、规范和模板组成，它们共同形成一种完整的开发环境，可以帮助开发者快速搭建应用程序的基础结构。常见的框架有Web框架、前端框架、后端框架等。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>你好，世界！</title>
    <url>/2023/03/31/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C%EF%BC%81/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">mt19937 <span class="title">mt</span><span class="params">(random_device &#123;&#125;())</span></span>;</span><br><span class="line"><span class="type">int</span> root = <span class="number">0</span>, len = <span class="number">1</span>, val[<span class="number">100010</span>], lazy[<span class="number">100010</span>], lc[<span class="number">100010</span>], rc[<span class="number">100010</span>], sz[<span class="number">100010</span>], w[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newNode</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    val[len] = v;</span><br><span class="line">    sz[len] = <span class="number">1</span>;</span><br><span class="line">    w[len] = <span class="built_in">mt</span>();</span><br><span class="line">    lc[len] = rc[len] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updateSize</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    sz[p] = sz[lc[p]] + sz[rc[p]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    lazy[lc[id]] ^= <span class="number">1</span>;</span><br><span class="line">    lazy[rc[id]] ^= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">swap</span>(lc[id], rc[id]);</span><br><span class="line">    lazy[id] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> k, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!id) &#123;</span><br><span class="line">        x = y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lazy[id])	<span class="built_in">pushdown</span>(id);</span><br><span class="line">    <span class="keyword">if</span>(sz[lc[id]] + <span class="number">1</span> &lt;= k) &#123;</span><br><span class="line">        x = id;</span><br><span class="line">        <span class="built_in">split</span>(rc[id], k - sz[lc[id]] - <span class="number">1</span>, rc[id], y);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y = id;</span><br><span class="line">        <span class="built_in">split</span>(lc[id], k, x, lc[id]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">updateSize</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !y)	<span class="keyword">return</span> x + y;</span><br><span class="line">    <span class="keyword">if</span>(w[x] &gt; w[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy[x])	<span class="built_in">pushdown</span>(x);</span><br><span class="line">        rc[x] = <span class="built_in">merge</span>(rc[x], y);</span><br><span class="line">        <span class="built_in">updateSize</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy[y])	<span class="built_in">pushdown</span>(y);</span><br><span class="line">        lc[y] = <span class="built_in">merge</span>(x, lc[y]);</span><br><span class="line">        <span class="built_in">updateSize</span>(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LDR</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!id)	<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(lazy[id])	<span class="built_in">pushdown</span>(id);</span><br><span class="line">    <span class="built_in">LDR</span>(lc[id]);</span><br><span class="line">    cout &lt;&lt; (<span class="type">char</span>)val[id];</span><br><span class="line">    <span class="built_in">LDR</span>(rc[id]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operation</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="built_in">split</span>(root, l - <span class="number">1</span>, x, y);</span><br><span class="line">    <span class="built_in">split</span>(y, r - l + <span class="number">1</span>, y, z);</span><br><span class="line">    lazy[y] ^= <span class="number">1</span>;</span><br><span class="line">    root = <span class="built_in">merge</span>(x, <span class="built_in">merge</span>(y, z));</span><br><span class="line">&#125;</span><br><span class="line">string arr = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : arr) &#123;</span><br><span class="line">        root = <span class="built_in">merge</span>(root, <span class="built_in">newNode</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">operation</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">operation</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">LDR</span>(root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LibreOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>创建服务器 git 仓库</title>
    <url>/2023/02/19/%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8-git-%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="创建-git-用户并配置ssh-key"><a href="#创建-git-用户并配置ssh-key" class="headerlink" title="创建 git 用户并配置ssh key"></a>创建 git 用户并配置ssh key</h2><p>创建一个 <code>git</code> 用户，并在家目录下建立一个 <code>.ssh</code> 目录，赋予其700权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo adduser -m git</span><br><span class="line">su git</span><br><span class="line"><span class="built_in">mkdir</span> ~/.ssh &amp;&amp; <span class="built_in">chmod</span> 700 ~/.ssh</span><br><span class="line"><span class="built_in">touch</span> ~/.ssh/authorized_keys &amp;&amp; <span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>然后只需要将 <code>ssh</code> 连接的公钥复制到 <code>authorized_keys</code> 文件中就可以通过 <code>ssh</code> 连接 <code>git</code> 用户了</p>
<h2 id="限制git用户的shell"><a href="#限制git用户的shell" class="headerlink" title="限制git用户的shell"></a>限制git用户的shell</h2><p>上面创建的git用户可以通过ssh连接，进行任何操作。为了安全性，我们需要将git用户的活动限制在与Git相关的范围，也就是把git用户的shell改成 <code>git-shell</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chsh git -s $(<span class="built_in">which</span> git-shell)</span><br></pre></td></tr></table></figure>

<p>当然通过修改<code>/etc/profile</code>也可以达成这一目的。</p>
<h2 id="创建-blog-对应的-git-仓库"><a href="#创建-blog-对应的-git-仓库" class="headerlink" title="创建 blog 对应的 git 仓库"></a>创建 blog 对应的 git 仓库</h2><p>在 <code>/www/wwwroot</code>下，创建一个空的<code>.git</code>仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init .git --bare --shared</span><br></pre></td></tr></table></figure>

<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config -e</span><br></pre></td></tr></table></figure>

<p>在 receive 下添加 <code>denyCurrentBranch = ignore</code>，保证仓库能更新</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[receive]</span><br><span class="line">        denyNonFastforwards = true</span><br><span class="line">        denyCurrentBranch = ignore</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>判断 DLL 还是 EXE</title>
    <url>/2023/03/30/%E5%88%A4%E6%96%AD-DLL-%E8%BF%98%E6%98%AF-EXE/</url>
    <content><![CDATA[<p>PE（Portable Executable）是Windows操作系统中可执行文件（Executable）和动态链接库（DLL）的文件格式。在Windows操作系统中，PE格式的可执行文件和DLL文件的区别主要在于它们的用途和导出函数表。</p>
<p>通常情况下，PE格式的可执行文件（EXE）是独立运行的程序，它包含了程序的代码、数据和资源等信息。而PE格式的动态链接库（DLL）则是可被多个程序共享的代码库，它包含了一些被其他程序调用的函数和变量等信息。因此，我们可以通过以下几种方式来判断一个PE文件是EXE还是DLL：</p>
<p>查看文件的扩展名：通常情况下，PE格式的可执行文件的扩展名为.exe，而PE格式的动态链接库的扩展名为.dll。但是，这并不是一个绝对的判断标准，因为有些DLL文件的扩展名可能会被修改为其他形式，例如.ocx、.sys等。</p>
<p>查看文件的导出函数表：PE 格式的动态链接库文件会包含一个导出函数表，它记录了该 DLL 文件中被其他程序调用的函数和变量等信息。通过查看导出函数表，我们可以判断一个PE文件是EXE还是 DLL。如果一个 PE 文件包含导出函数表，那么它就是一个 DLL 文件，否则它就是一个 EXE 文件。</p>
<p>使用专业工具：我们可以使用一些专业的 PE 文件查看工具，例如 PE Explorer、Dependency Walker 等，来查看 PE 文件的详细信息和导出函数表等内容，以判断一个 PE 文件是 EXE 还是 DLL。</p>
<p>需要注意的是，有些 PE 文件可能既包含可执行代码，又包含导出函数表，这种情况下，我们需要根据文件的实际用途和功能来判断它是 EXE 还是 DLL。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>前端国际化方案</title>
    <url>/2023/06/25/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="mbox-i18n"><a href="#mbox-i18n" class="headerlink" title="mbox-i18n"></a>mbox-i18n</h2><h2 id="i18n-next"><a href="#i18n-next" class="headerlink" title="i18n-next"></a>i18n-next</h2>]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>加壳脱壳原理</title>
    <url>/2023/03/30/%E5%8A%A0%E5%A3%B3%E8%84%B1%E5%A3%B3%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>反调试技术</title>
    <url>/2023/03/30/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>反调试技术是指通过一系列的手段，防止调试工具对程序进行调试，从而保护程序的安全性。常见的反调试技术包括：</p>
<ul>
<li>检测调试器：程序会检测自己是否被调试器调试，如果检测到调试器存在，则会采取相应的反调试措施。</li>
<li>检测调试器中断：程序会在关键的位置设置一个中断点，当调试器调试程序时，中断点会被触发，程序会采取相应的反调试措施。</li>
<li>检测调试器钩子：程序会在关键的位置检测调试器的钩子是否存在，如果存在，则会采取相应的反调试措施。</li>
<li>检测调试器注入：程序会在关键的位置检测是否有调试器注入程序中，如果存在，则会采取相应的反调试措施。</li>
<li>隐藏代码：程序会将关键的代码隐藏起来，使调试器无法识别。</li>
<li>随机代码：程序会在关键的位置插入一些随机代码，使调试器无法识别。</li>
</ul>
<p>通过使用反调试技术，程序可以有效地防止调试工具对其进行调试，从而提高程序的安全性。但是，反调试技术并不是万无一失的，一些高级调试工具和技术仍然可以绕过反调试技术对程序进行调试。因此，反调试技术只是保护程序安全的一个方面，还需要结合其他的安全技术来提高程序的安全性。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>同步异步阻塞非阻塞</title>
    <url>/2023/03/31/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>同步、异步、阻塞和非阻塞是计算机编程中常用的几个概念，它们用于描述程序的执行方式和任务的处理方式。</p>
<ul>
<li>同步（Synchronous）：指程序按照顺序依次执行，每个操作完成后再进行下一个操作。在同步模式下，如果一个操作耗时较长，程序会一直等待该操作完成后才会继续执行下一个操作。</li>
<li>异步（Asynchronous）：指程序在执行某个操作时，不需要等待该操作完成，而是可以继续执行其他操作。在异步模式下，程序可以通过回调函数等方式处理异步操作的结果，而不需要一直等待操作完成。</li>
<li>阻塞（Blocking）：指程序在执行某个操作时，如果该操作不能立即完成，则程序会一直等待，直到操作完成后才会继续执行。在阻塞模式下，程序会进入等待状态，直到操作完成。</li>
<li>非阻塞（Non-Blocking）：指程序在执行某个操作时，如果该操作不能立即完成，则程序会立即返回，而不是等待操作完成。在非阻塞模式下，程序不会进入等待状态，而是可以继续执行其他操作。</li>
</ul>
<p>这些概念常常用于描述网络编程、多线程编程等场景中的任务处理方式。例如，同步阻塞模式常常用于单线程程序中，异步非阻塞模式常常用于多线程程序中。</p>
<p>需要注意的是，这些概念并不是互相独立的，它们可以组合在一起形成不同的编程模式。例如，异步非阻塞模式通常需要使用回调函数和事件循环等技术，而同步阻塞模式则不需要。在实际编程中，应该根据具体的应用场景选择合</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>墙与门</title>
    <url>/2023/02/08/%E5%A2%99%E4%B8%8E%E9%97%A8/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：</p>
<p>-1 表示墙或是障碍物<br>0 表示一扇门<br>INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的。<br>你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可。</p>
<p>示例 1：<br>输入：rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]<br>输出：[[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]</p>
<p>示例 2：<br>输入：rooms = [[-1]]<br>输出：[[-1]]</p>
<p>示例 3：<br>输入：rooms = [[2147483647]]<br>输出：[[2147483647]]</p>
<p>示例 4：<br>输入：rooms = [[0]]<br>输出：[[0]]</p>
<blockquote>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/walls-and-gates">https://leetcode.cn/problems/walls-and-gates</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先设置一个标记数组，把所有门和障碍物标记上，标记门的同时也要把门放入一个队列，等所有门进入队列后，我们对这个队列进行广度优先遍历（先把门放进去是为了防止标记数组的重复创建），由于是从门（0）开始的，又是广度优先遍历，我们只需要进行简单的加 1 就可以得到到门的最短距离</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wallsAndGates</span>(<span class="params">rooms: <span class="built_in">number</span>[][]</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> m = rooms.<span class="property">length</span>,</span><br><span class="line">    n = rooms[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Array</span>(m).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="literal">true</span>));</span><br><span class="line">  <span class="keyword">const</span> dire = [</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (rooms[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">        stack.<span class="title function_">push</span>([i, j]);</span><br><span class="line">        map[i][j] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (rooms[i][j] === -<span class="number">1</span>) &#123;</span><br><span class="line">        map[i][j] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [cur_i, cur_j] = stack.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> dire) &#123;</span><br><span class="line">      <span class="keyword">const</span> [i, j] = [cur_i + item[<span class="number">0</span>], cur_j + item[<span class="number">1</span>]];</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; map[i][j]) &#123;</span><br><span class="line">        map[i][j] = <span class="literal">false</span>;</span><br><span class="line">        rooms[i][j] = rooms[cur_i][cur_j] + <span class="number">1</span>;</span><br><span class="line">        stack.<span class="title function_">push</span>([i, j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>多路 IO 复用</title>
    <url>/2023/03/25/%E5%A4%9A%E8%B7%AF-IO-%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<p>IO复用是指在一个线程中同时监听多个文件描述符的状态，以便在其中任意一个文件描述符就绪时进行相应的操作。常见的 IO 复用技术有 select、poll 和 epoll。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select 是最早的多路复用IO机制，使用 fd_set 数据结构存储需要监听的文件描述符，使用 select 函数进行监听，其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fd_set的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">fd_set</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fds_bits[__FDSET_LONGS];</span><br><span class="line">&#125; fd_set;</span><br></pre></td></tr></table></figure>

<p>其中，nfds 表示需要监听的文件描述符的最大值加 1，readfds、writefds、exceptfds 分别表示需要监听的可读、可写、异常事件的文件描述符集合，timeout 表示等待时间。</p>
<p>select 的缺点是，每次调用 select 函数时都需要将需要监听的文件描述符集合从用户空间拷贝到内核空间，而且 select 函数的最大文件描述符数量有限，一般为 1024。</p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll 是一种常用的 I/O 复用机制，可以同时监听多个文件描述符的状态，以便在其中任意一个文件描述符就绪时进行相应的操作。它是 select 的改进版，可以支持更多的文件描述符，同时也避免了 select 的一些缺陷。</p>
<p>poll 使用 pollfd 结构体存储需要监听的文件描述符，使用 poll 函数进行监听，其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，fds 表示需要监听的文件描述符和事件类型，nfds 表示需要监听的文件描述符数量，timeout表示等待时间。</p>
<p>pollfd 结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 要监听的事件类型</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 实际发生的事件类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，fd表示文件描述符，events 表示需要监听的事件类型，revents 表示实际发生的事件类型。</p>
<p>在使用 poll 时，需要将需要监听的文件描述符和事件类型存储在 pollfd 结构体中，并将所有结构体放入一个数组中，然后使用 poll 函数进行监听。当有文件描述符就绪时，poll 函数返回，同时可以通过 revents 字段获取实际发生的事件类型。</p>
<p>poll 的优点是可以同时监听大量的文件描述符，不受文件描述符数量的限制，而且在使用时只需要将需要监听的文件描述符存储在一个结构体数组中，更加方便。但其缺点是需要遍历整个文件描述符数组，效率较低。</p>
<p>需要注意的是，poll 的使用需要谨慎，需要注意文件描述符的合法性和正确的事件类型，避免对系统造成安全风险和性能问题。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll 是Linux 2.6 内核引入的一种新的多路复用 IO 机制，使用 epoll_create() 函数创建 epoll 句柄，使用 epoll_ctl() 函数向 epoll 中添加或删除需要监听的文件描述符，使用 epoll_wait() 函数进行监听，其函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，size 表示 epoll 支持的最大文件描述符数量，epfd 表示 epoll 句柄，op 表示添加或删除操作，fd 表示需要监听的文件描述符，event 表示事件类型及其他相关信息，events 表示返回的就绪事件，maxevents 表示最大事件数量，timeout 表示等待时间。</p>
<p>epoll 的优点是，epoll 使用事件驱动的方式，只有当事件发生时才进行处理，对于大量的文件描述符也可以高效地进行处理。而且，epoll 使用的是红黑树数据结构，可以快速地查找需要监听的文件描述符。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>大端小端</title>
    <url>/2023/03/31/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>大端和小端是两种不同的字节序（Byte Order）方式，用于表示多字节数据类型在内存中的存储顺序。在计算机中，多字节数据类型（如整型、浮点型）在内存中是以连续的字节序列的形式存储的，而不同的字节序列方式会影响到这些数据类型的值的解释。</p>
<ul>
<li>大端字节序（Big Endian）：高位字节存储在低地址，低位字节存储在高地址。如整数值 0x12345678 在内存中的存储方式为 12 34 56 78。</li>
<li>小端字节序（Little Endian）：低位字节存储在低地址，高位字节存储在高地址。如整数值 0x12345678 在内存中的存储方式为 78 56 34 12。</li>
</ul>
<p>在网络通信中，由于不同计算机 CPU 和操作系统采用的字节序列方式不同，因此需要在数据传输时进行字节序列的转换，以保证数据的正确性。通常采用的方式是将数据转换为网络字节序（也称为大端字节序），即先将高位字节传输，然后是低位字节。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>字体大小单位</title>
    <url>/2023/04/25/%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E5%8D%95%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="pt"><a href="#pt" class="headerlink" title="pt"></a>pt</h2><table>
<thead>
<tr>
<th align="center">PT号</th>
<th align="center">字号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">宋体1号</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">宋体2号</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">宋体3号</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">宋体4号</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">宋体5号</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">宋体6号</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">宋体7号</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">宋体8号</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">宋体9号</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">宋体10号</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">宋体11号</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">宋体12号</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">宋体13号</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">宋体14号</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">宋体15号</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">宋体16号</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">宋体17号</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">宋体18号</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">宋体20号</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center">宋体22号</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">宋体24号</td>
</tr>
<tr>
<td align="center">26</td>
<td align="center">宋体26号</td>
</tr>
<tr>
<td align="center">28</td>
<td align="center">宋体28号</td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">宋体30号</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">宋体32号</td>
</tr>
<tr>
<td align="center">34</td>
<td align="center">宋体34号</td>
</tr>
<tr>
<td align="center">36</td>
<td align="center">宋体36号</td>
</tr>
<tr>
<td align="center">38</td>
<td align="center">宋体38号</td>
</tr>
<tr>
<td align="center">40</td>
<td align="center">宋体40号</td>
</tr>
<tr>
<td align="center">42</td>
<td align="center">宋体42号</td>
</tr>
<tr>
<td align="center">44</td>
<td align="center">宋体44号</td>
</tr>
<tr>
<td align="center">46</td>
<td align="center">宋体46号</td>
</tr>
<tr>
<td align="center">48</td>
<td align="center">宋体48号</td>
</tr>
<tr>
<td align="center">54</td>
<td align="center">宋体54号</td>
</tr>
<tr>
<td align="center">60</td>
<td align="center">宋体60号</td>
</tr>
<tr>
<td align="center">66</td>
<td align="center">宋体66号</td>
</tr>
<tr>
<td align="center">72</td>
<td align="center">宋体72号</td>
</tr>
<tr>
<td align="center">80</td>
<td align="center">宋体80号</td>
</tr>
</tbody></table>
<h2 id="字号"><a href="#字号" class="headerlink" title="字号"></a>字号</h2>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>字符集编码</title>
    <url>/2023/03/31/%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>字符集编码是指将字符集中的字符映射到数字编码的过程。在计算机中，所有的数据都是以二进制的形式存储和处理的，因此需要一种方法将字符转换为相应的数字编码。常见的字符集编码包括 ASCII 码、Unicode 和 UTF-8等。</p>
<p>ASCII 码是一种最早的字符集编码，它将英文字母、数字、符号等常用字符映射为7位二进制数，共计 128 个字符。ASCII 码只适用于英文字符，无法表示其他语言的字符。</p>
<p>Unicode 是一种全球通用的字符集编码，它将世界上所有的字符都映射为唯一的数字编码。Unicode 编码通常使用 16 位或 32 位二进制数表示一个字符，可以表示包括中文、日语、韩语等多种语言的字符。</p>
<p>UTF-8 是一种基于 Unicode 的可变长度字符集编码，它将 Unicode 中的字符按照不同的编码长度进行存储，使得存储空间更加节省。UTF-8 编码适用于在国际互联网上传输和存储各种语言的文本。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>安排会议日程</title>
    <url>/2023/02/08/%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E6%97%A5%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定两个人的空闲时间表：slots1 和 slots2，以及会议的预计持续时间 duration，请你为他们安排 时间段最早 且合适的会议时间。</p>
<p>如果没有满足要求的会议时间，就请返回一个 空数组。</p>
<p>「空闲时间」的格式是 [start, end]，由开始时间 start 和结束时间 end 组成，表示从 start 开始，到 end 结束。</p>
<p>题目保证数据有效：同一个人的空闲时间不会出现交叠的情况，也就是说，对于同一个人的两个空闲时间 [start1, end1] 和 [start2, end2]，要么 start1 &gt; end2，要么 start2 &gt; end1。</p>
<p>示例 1：<br>输入：slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 8<br>输出：[60,68]</p>
<p>示例 2：<br>输入：slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 12<br>输出：[]</p>
<blockquote>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/meeting-scheduler">https://leetcode.cn/problems/meeting-scheduler</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="解题思路分析"><a href="#解题思路分析" class="headerlink" title="解题思路分析"></a>解题思路分析</h2><p>由于所给数据不一定是按照从小到大的顺序，因此我们要先进行排序<br>创建两个指针 p1 和 p2，用 while 遍历判断以下情况<br>判断每个人当前空闲时间是否大于等于会议持续时间</p>
<p>slot1[p1][1] - slot1[p1][0] &gt;= duration<br>slot2[p2][1] - slot2[p2][0] &gt;= duration</p>
<p>判断是否有共同的空闲时间且共同的空闲时间是否大于会议持续时间</p>
<p>slots1[p1][1] - slots2[p2][0] &gt;= duration<br>slots2[p2][1] - slots1[p1][0] &gt;= duration</p>
<p>. 如果两个条件都满足我们比较 slots[p1][0] 和 slots[p2][0] 的大小，返回其中较大的那个和 duration<br>如果都不满足，比较 slots[p1][1] 和 slots[p2][0] 的大小，较小的那个指针加一<br>在某些情况下，如 end2 &gt;= end1 &gt; start2 &gt;= start1 或 end1 &gt;= end2 &gt; start1 &gt;= start2，我们仅仅只需要判断 end1 - start2&gt;=duration 或 end2 - start1 &gt;= duration，但在某些情况下则不行，如 end2 &gt; end1 &gt; start1 &gt; start2，如果 end2 = 100，end1 = 51，start1 = 50，start2 = 1，duration = 20，结果会错误，所以我们还要分别判断 end1 - start1 &gt;= duration 和 end2 - start2 &gt;= duration</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">minAvailableDuration</span>(<span class="params"></span></span><br><span class="line"><span class="params">  slots1: <span class="built_in">number</span>[][],</span></span><br><span class="line"><span class="params">  slots2: <span class="built_in">number</span>[][],</span></span><br><span class="line"><span class="params">  duration: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> l1 = slots1.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> l2 = slots2.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> p1 = <span class="number">0</span>,</span><br><span class="line">    p2 = <span class="number">0</span>;</span><br><span class="line">  slots1.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">  slots2.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt; l1 &amp;&amp; p2 &lt; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      slots1[p1][<span class="number">1</span>] - slots2[p2][<span class="number">0</span>] &gt;= duration &amp;&amp;</span><br><span class="line">      slots2[p2][<span class="number">1</span>] - slots1[p1][<span class="number">0</span>] &gt;= duration &amp;&amp;</span><br><span class="line">      slots1[p1][<span class="number">1</span>] - slots1[p1][<span class="number">0</span>] &gt;= duration &amp;&amp;</span><br><span class="line">      slots2[p2][<span class="number">1</span>] - slots2[p2][<span class="number">0</span>] &gt;= duration</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">let</span> tmp = <span class="title class_">Math</span>.<span class="title function_">max</span>(slots1[p1][<span class="number">0</span>], slots2[p2][<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span> [tmp, tmp + duration];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (slots1[p1][<span class="number">1</span>] &lt; slots2[p2][<span class="number">1</span>]) &#123;</span><br><span class="line">        p1++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p2++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 Pytorch 和 CUDA</title>
    <url>/2023/04/14/%E5%AE%89%E8%A3%85-Pytorch-%E5%92%8C-CUDA/</url>
    <content><![CDATA[<h2 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install torch==1.8.0+cu111 torchvision==0.9.0+cu111 torchaudio==0.8.0 -f https://download.pytorch.org/whl/torch_stable.html</span><br></pre></td></tr></table></figure>

<h2 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h2><p><a href="https://pytorch-geometric.com/whl/">https://pytorch-geometric.com/whl/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install torch_scatter-2.0.6-cp38-cp38-linux_x86_64.whl</span><br><span class="line">pip install torch_sparse-0.6.9-cp38-cp38-linux_x86_64.whl</span><br><span class="line">pip install torch_cluster-1.5.9-cp38-cp38-linux_x86_64.whl</span><br><span class="line">pip install torch_spline_conv-1.2.1-cp38-cp38-linux_x86_64.whl</span><br><span class="line">pip install torch-geometric</span><br></pre></td></tr></table></figure>

<p>或</p>
<p><a href="https://download.pytorch.org/whl/torch_stable.html">https://download.pytorch.org/whl/torch_stable.html</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install torch-1.8.0+cu111-cp38-cp38-win_amd64.whl</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学虚拟人物</title>
    <url>/2023/03/25/%E5%AF%86%E7%A0%81%E5%AD%A6%E8%99%9A%E6%8B%9F%E4%BA%BA%E7%89%A9/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>爱丽丝（Alice）与鲍伯（Bob） 通例上，爱丽丝希望把一条讯息传送给鲍伯。</li>
<li>卡罗尔或查利（Carol或Charlie） 是通讯中的第三位参加者。</li>
<li>戴夫（Dave） 是通讯中的第四位参加者。</li>
<li>伊夫（Eve） 是一位偷听者（eavesdropper），但行为通常是被动的。她拥有偷听的技术，但不会中途篡改传送的讯息。在量子密码学中，伊夫也可以指环境（environment）。</li>
<li>艾萨克（Isaac） 是互联网服务提供者 (ISP)。</li>
<li>伊凡（Ivan） 是发行人，使用于商业密码学中。</li>
<li>贾斯汀（Justin） 是司法（justice）机关。</li>
<li>马洛里（Mallory） 是一位恶意攻击者（malicious attacker）。与伊夫不同的是，马洛里会篡改传送的讯息。对付马洛里所需的信息安全技术比对伊夫的高出很多。有时亦会叫作马文（Marvin）或马利特（Mallet）。</li>
<li>马提尔达（Matilda） 是一位商人（merchant），用于电子商务。</li>
<li>奥斯卡（Oscar） 是敌人，通常与马洛里一样。</li>
<li>帕特（Pat）或佩吉（Peggy） 是证明者（prover），维克托（Victor）是验证者（verifier）。两人会证实一项事件是否有实际进行，多使用于零知识证明。</li>
<li>普特（Plod或Officer Plod） 是执法官员。名称来自伊妮·布来敦所著的儿童文学《诺弟》（Noddy）中的角色“普特先生”。</li>
<li>史蒂夫（Steve） 代指隐写术（Steganography）。</li>
<li>特伦特（Trent） 是一位可信赖的仲裁人（trusted arbitrator），中立的第三者，根据存在的协议而判断。</li>
<li>特鲁迪（Trudy） 是侵入者（intruder），等同马洛里。</li>
<li>沃特（Walter） 是看守人（warden）。根据已存在的协议而保护爱丽丝和鲍伯。</li>
<li>佐伊（Zoe） 通常是一个安全协议中的最后参与者。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序 canvas 兼容问题</title>
    <url>/2023/02/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-canvas-%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>根据官方文档，微信小程序有两个不同版本的 <code>canvas</code>，官方推荐使用新版 <code>canvas</code>，不过实际实践中我发现在开发者工具可以使用新版 <code>canvas</code>，但在部分真机仍需要使用旧版写法</p>
<p>新版 <code>canvas</code> 标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">class</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">type</span>=<span class="string">&quot;2d&quot;</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>旧版 <code>canvas</code> 标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">class</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">canvas-id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>获取 canvas</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = wx.<span class="title function_">createSelectorQuery</span>().<span class="title function_">in</span>(<span class="variable language_">this</span>);</span><br><span class="line">query</span><br><span class="line">  .<span class="title function_">select</span>(<span class="string">&quot;#canvas&quot;</span>)</span><br><span class="line">  .<span class="title function_">fields</span>(&#123;</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">size</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">exec</span>(<span class="keyword">async</span> (res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> dom = res[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 判断 node 是否为 null，如果是调用旧版接口，否则调用新版接口</span></span><br><span class="line">    <span class="keyword">if</span> (dom.<span class="property">node</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">canvas</span>: <span class="title class_">WechatMiniprogram</span>.<span class="property">Canvas</span> = dom.<span class="property">node</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">ctx</span>: <span class="title class_">WechatMiniprogram</span>.<span class="property">RenderingContext</span> = canvas.<span class="title function_">getContext</span>(</span><br><span class="line">        <span class="string">&quot;2d&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">ctx</span>: <span class="title class_">WechatMiniprogram</span>.<span class="property">CanvasContext</span> = wx.<span class="title function_">createCanvasContext</span>(</span><br><span class="line">        <span class="string">&quot;canvas&quot;</span>,</span><br><span class="line">        <span class="variable language_">this</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序全局组件封装</title>
    <url>/2023/02/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p>在 <code>miniprogram</code> 目录新建 <code>components\custom-modal</code> 目录，并在该目录下创建一个组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// components/custom-modal/index.ts</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TData</span> &#123;</span><br><span class="line">  <span class="attr">isShow</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">state</span>: <span class="string">&quot;confirm&quot;</span> | <span class="string">&quot;cancel&quot;</span>;</span><br><span class="line">  <span class="attr">caption</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">content</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">confirm</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">cancel</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">showContent</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">showCancel</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">customContent</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用 interface 会报错缺少索引签名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TProperty</span> = &#123;</span><br><span class="line">  <span class="attr">height</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">NumberConstructor</span>;</span><br><span class="line">    value?: <span class="built_in">number</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="attr">customContent</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">BooleanConstructor</span>;</span><br><span class="line">    value?: <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用 interface 会报错缺少索引签名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TMethod</span> = &#123;</span><br><span class="line">  <span class="attr">confirm</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">cancel</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">showModal</span>: <span class="function">(<span class="params">options: CustomModal</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">hiddenModal</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TCustomInstanceProperty</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TIsPage</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="title class_">Component</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TProperty</span>, <span class="title class_">TMethod</span>, <span class="title class_">TCustomInstanceProperty</span>, <span class="title class_">TIsPage</span>&gt;(&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件的属性列表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">properties</span>: &#123;</span><br><span class="line">    <span class="attr">height</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="number">211</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">customContent</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">isShow</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">state</span>: <span class="string">&quot;confirm&quot;</span>,</span><br><span class="line">    <span class="attr">caption</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">showContent</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">showCancel</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">customContent</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">confirm</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    <span class="attr">cancel</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件的方法列表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">confirm</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// this.triggerEvent(&quot;parentConfirm&quot;);</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">confirm</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">hiddenModal</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">cancel</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// this.triggerEvent(&quot;parentCancel&quot;);</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">cancel</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">hiddenModal</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">showModal</span>(<span class="params">options: CustomModal</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> isShow = !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">isShow</span>;</span><br><span class="line">      <span class="keyword">const</span> &#123;</span><br><span class="line">        caption = <span class="string">&quot;标题&quot;</span>,</span><br><span class="line">        content = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        confrim = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        cancel = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        showContent = <span class="literal">true</span>,</span><br><span class="line">        showCancel = <span class="literal">true</span>,</span><br><span class="line">        customContent = <span class="literal">false</span>,</span><br><span class="line">      &#125; = options;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">isShow</span>: isShow,</span><br><span class="line">        <span class="attr">caption</span>: caption,</span><br><span class="line">        <span class="attr">content</span>: content,</span><br><span class="line">        <span class="attr">confirm</span>: confrim,</span><br><span class="line">        <span class="attr">cancel</span>: cancel,</span><br><span class="line">        <span class="attr">showContent</span>: showContent,</span><br><span class="line">        <span class="attr">showCancel</span>: showCancel,</span><br><span class="line">        <span class="attr">customContent</span>: customContent,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">hiddenModal</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> isShow = !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">isShow</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">isShow</span>: isShow,</span><br><span class="line">        <span class="attr">caption</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">content</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">confirm</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        <span class="attr">cancel</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        <span class="attr">showContent</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">showCancel</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">customContent</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>app.ts</code> 添加以下方法</p>
<p>app.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>&lt;<span class="title class_">IAppOption</span>&gt;(&#123;</span><br><span class="line">  <span class="title function_">showModal</span>(<span class="params">that: <span class="built_in">any</span>, options: CustomModal</span>)&#123;</span><br><span class="line">    that.<span class="title function_">selectComponent</span>(<span class="string">&#x27;#modal&#x27;</span>).<span class="title function_">showModal</span>(options??&#123;&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">hiddenModal</span>(<span class="params">that</span>)&#123;</span><br><span class="line">    that.<span class="title function_">selectComponent</span>(<span class="string">&#x27;#modal&#x27;</span>).<span class="title function_">hiddenModal</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>组件的控制文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// components/custom-modal/index.ts</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">TData</span> &#123;</span><br><span class="line">  <span class="attr">isShow</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">state</span>: <span class="string">&quot;confirm&quot;</span> | <span class="string">&quot;cancel&quot;</span>;</span><br><span class="line">  <span class="attr">caption</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">content</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">confirm</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">cancel</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">showContent</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">showCancel</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">customContent</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用 interface 会报错缺少索引签名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TProperty</span> = &#123;</span><br><span class="line">  <span class="attr">height</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">NumberConstructor</span>;</span><br><span class="line">    value?: <span class="built_in">number</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="attr">customContent</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">BooleanConstructor</span>;</span><br><span class="line">    value?: <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用 interface 会报错缺少索引签名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TMethod</span> = &#123;</span><br><span class="line">  <span class="attr">confirm</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">cancel</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">showModal</span>: <span class="function">(<span class="params">options: CustomModal</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="attr">hiddenModal</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TCustomInstanceProperty</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TIsPage</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="title class_">Component</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TProperty</span>, <span class="title class_">TMethod</span>, <span class="title class_">TCustomInstanceProperty</span>, <span class="title class_">TIsPage</span>&gt;(&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件的属性列表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">properties</span>: &#123;</span><br><span class="line">    <span class="attr">height</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="number">211</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">customContent</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">isShow</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">state</span>: <span class="string">&quot;confirm&quot;</span>,</span><br><span class="line">    <span class="attr">caption</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">showContent</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">showCancel</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">customContent</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">confirm</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    <span class="attr">cancel</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件的方法列表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">confirm</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// this.triggerEvent(&quot;parentConfirm&quot;);</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">confirm</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">hiddenModal</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">cancel</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// this.triggerEvent(&quot;parentCancel&quot;);</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">cancel</span>();</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">hiddenModal</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">showModal</span>(<span class="params">options: CustomModal</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> isShow = !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">isShow</span>;</span><br><span class="line">      <span class="keyword">const</span> &#123;</span><br><span class="line">        caption = <span class="string">&quot;标题&quot;</span>,</span><br><span class="line">        content = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        confrim = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        cancel = <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        showContent = <span class="literal">true</span>,</span><br><span class="line">        showCancel = <span class="literal">true</span>,</span><br><span class="line">        customContent = <span class="literal">false</span>,</span><br><span class="line">      &#125; = options;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">isShow</span>: isShow,</span><br><span class="line">        <span class="attr">caption</span>: caption,</span><br><span class="line">        <span class="attr">content</span>: content,</span><br><span class="line">        <span class="attr">confirm</span>: confrim,</span><br><span class="line">        <span class="attr">cancel</span>: cancel,</span><br><span class="line">        <span class="attr">showContent</span>: showContent,</span><br><span class="line">        <span class="attr">showCancel</span>: showCancel,</span><br><span class="line">        <span class="attr">customContent</span>: customContent,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">hiddenModal</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> isShow = !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">isShow</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">isShow</span>: isShow,</span><br><span class="line">        <span class="attr">caption</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">content</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">confirm</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        <span class="attr">cancel</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">        <span class="attr">showContent</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">showCancel</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">customContent</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>在其他界面中引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CustomModal</span> <span class="attr">id</span>=<span class="string">&quot;modal&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">CustomModal</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在其他界面中使用</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Component</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TProperty</span>, <span class="title class_">TMethod</span>, <span class="title class_">TCustomInstanceProperty</span>, <span class="title class_">TIsPage</span>&gt;(&#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">use</span>(<span class="params"></span>)&#123;</span><br><span class="line">      app.<span class="title function_">showModal</span>(<span class="variable language_">this</span>, &#123;</span><br><span class="line">          <span class="attr">caption</span>: <span class="string">&quot;错误&quot;</span>,</span><br><span class="line">          <span class="attr">content</span>: <span class="string">&quot;昵称不能为空&quot;</span>,</span><br><span class="line">          <span class="attr">confrim</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">          <span class="attr">showCancel</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序实现 i18n</title>
    <url>/2023/02/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0-i18n/</url>
    <content><![CDATA[<p>首先在 <code>miniprogram</code> 目录下创建 <code>behaviors</code> 目录，在此目录下创建 <code>i18n.ts</code> 文件</p>
<p>i18n.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;t&#125; <span class="keyword">from</span> <span class="string">&#x27;../utils/util&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">getApp</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> I18n=<span class="title class_">Behavior</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">language</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">locales</span>:&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">pageLifetimes</span>:&#123;</span><br><span class="line">    <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">language</span>:wx.<span class="title function_">getStorageSync</span>(<span class="string">&#x27;language&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">language</span> === <span class="string">&#x27;zh&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">          <span class="attr">locales</span>: <span class="built_in">require</span>(<span class="string">&#x27;../i18n/zh&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">          <span class="attr">locales</span>: <span class="built_in">require</span>(<span class="string">&#x27;../i18n/en&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    $(<span class="attr">key</span>:<span class="built_in">any</span>,<span class="attr">option</span>:<span class="built_in">any</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">t</span>(key,option)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">switchLanguage</span>(<span class="params">language:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        language</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">language</span> === <span class="string">&#x27;zh&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">          <span class="attr">locales</span>: <span class="built_in">require</span>(<span class="string">&#x27;../i18n/zh&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        wx.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;language&#x27;</span>,<span class="string">&#x27;zh&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">          <span class="attr">locales</span>: <span class="built_in">require</span>(<span class="string">&#x27;../i18n/en&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        wx.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;language&#x27;</span>,<span class="string">&#x27;en&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=I18n</span><br></pre></td></tr></table></figure>

<p>在 <code>miniprogram</code> 目录下创建 <code>i18n</code> 目录，在此目录下创建下 <code>zh.ts</code> 和 <code>en.ts</code> 文件</p>
<p>zh.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map=&#123;</span><br><span class="line">  <span class="attr">language</span>:<span class="string">&#x27;语言&#x27;</span>,</span><br><span class="line">  <span class="attr">start</span>:<span class="string">&#x27;开始训练&#x27;</span>,</span><br><span class="line">  <span class="attr">train</span>:<span class="string">&#x27;训练&#x27;</span>,</span><br><span class="line">  <span class="attr">mine</span>:<span class="string">&#x27;我的&#x27;</span>,</span><br><span class="line">  <span class="attr">network</span>:<span class="string">&#x27;配网&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=map</span><br></pre></td></tr></table></figure>

<p>en.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map=&#123;</span><br><span class="line">  <span class="attr">language</span>:<span class="string">&#x27;language&#x27;</span>,</span><br><span class="line">  <span class="attr">start</span>:<span class="string">&#x27;start traing&#x27;</span>,</span><br><span class="line">  <span class="attr">train</span>:<span class="string">&#x27;train&#x27;</span>,</span><br><span class="line">  <span class="attr">mine</span>:<span class="string">&#x27;mine&#x27;</span>,</span><br><span class="line">  <span class="attr">network</span>:<span class="string">&#x27;network&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=map</span><br></pre></td></tr></table></figure>

<p>在 <code>app.ts</code> 判断当前语言环境</p>
<p>app.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">App</span>(&#123;</span><br><span class="line">  <span class="attr">onLaunch</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/** 获得本地语言 */</span></span><br><span class="line">    <span class="keyword">let</span> language = wx.<span class="title function_">getSystemInfoSync</span>().<span class="property">language</span></span><br><span class="line">    <span class="keyword">if</span> (wx.<span class="title function_">getStorageSync</span>(<span class="string">&quot;language&quot;</span>) === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (language == <span class="string">&quot;zh&quot;</span> || language == <span class="string">&quot;zh_CN&quot;</span>) &#123;</span><br><span class="line">        wx.<span class="title function_">setStorageSync</span>(<span class="string">&quot;language&quot;</span>, <span class="string">&quot;zh&quot;</span>)</span><br><span class="line">        <span class="comment">// TO-DO</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wx.<span class="title function_">setStorageSync</span>(<span class="string">&quot;language&quot;</span>, <span class="string">&quot;en&quot;</span>)</span><br><span class="line">        <span class="comment">// TO-DO</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wx.<span class="title function_">getStorageSync</span>(<span class="string">&quot;language&quot;</span>) === <span class="string">&quot;zh&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// TO-DO</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wx.<span class="title function_">getStorageSync</span>(<span class="string">&quot;language&quot;</span>) === <span class="string">&quot;en&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// TO-DO</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>相同的语言环境可能有不同的名称，所以我们要判断多个</p>
<p>在 <code>miniprogram</code> 目录下创建 <code>wxs</code> 文件，在该目录下创建 <code>i18n.wxs</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i18n = &#123;</span><br><span class="line">  <span class="attr">t</span>: <span class="keyword">function</span> (<span class="params">str, arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = str;</span><br><span class="line">    <span class="keyword">if</span> (arr) &#123;</span><br><span class="line">      arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(result)&#123;</span><br><span class="line">          result = result.<span class="title function_">replace</span>(<span class="string">&#x27;&#123;&#x27;</span>+item.<span class="property">key</span>+<span class="string">&#x27;&#125;&#x27;</span>, item.<span class="property">value</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = i18n</span><br></pre></td></tr></table></figure>

<p>在页面组件中使用（使用 <code>Component</code> 构造）</p>
<p>页面的 <code>ts</code> 文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> I18n=<span class="built_in">require</span>(<span class="string">&#x27;../../behaviors/i18n&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">getApp</span>()</span><br><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">behaviors</span>:[I18n],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>页面的 <code>wxml</code> 文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">src</span>=<span class="string">&quot;../../wxs/i18n.wxs&quot;</span> <span class="attr">module</span>=<span class="string">&quot;i18n&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">wxs</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;i18n.t(locales[&#x27;language&#x27;])&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>locals 表示当前的语言列表，language 表示要取出的值</p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序实现简单的 Store</title>
    <url>/2023/02/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84-Store/</url>
    <content><![CDATA[<p>在 <code>miniprogram</code> 目录下创建 <code>utils</code>，并在该目录下创建 <code>wex.ts</code> 文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wex</span>&lt;T <span class="keyword">extends</span> &#123; [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">store</span>: T;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">observer</span>: T;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">pages</span>: <span class="title class_">Set</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">store: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pages</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">store</span> = store;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Proxy</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">observer</span> = <span class="keyword">new</span> <span class="title class_">Proxy</span>(store, &#123;</span><br><span class="line">        <span class="attr">set</span>: <span class="function">(<span class="params">target: &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;, p: <span class="built_in">string</span>, value</span>) =&gt;</span> &#123;</span><br><span class="line">          target[p] = value;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">pages</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">            element.<span class="title function_">setData</span>(&#123;</span><br><span class="line">              [p]: value,</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">get</span>: <span class="function">(<span class="params">target, p: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> target[p];</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;) <span class="keyword">as</span> T;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">observer</span> = &#123;&#125; <span class="keyword">as</span> T;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">store</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">observer</span>, key, &#123;</span><br><span class="line">          <span class="attr">set</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">store</span>[key] = value;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">pages</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">element: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">              element.<span class="title function_">setData</span>(&#123;</span><br><span class="line">                [key]: value,</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">get</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">store</span>[key];</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addPage</span>(<span class="params">page: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pages</span>.<span class="title function_">add</span>(page);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">removePage</span>(<span class="params">page: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pages</span>.<span class="title function_">delete</span>(page);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setData</span>(<span class="params">key: <span class="built_in">string</span>, value: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">store</span>[key] !== value)&#123;</span><br><span class="line">      (<span class="variable language_">this</span>.<span class="property">observer</span>[key] <span class="keyword">as</span> T) = value;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据未更改&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getData</span>(<span class="params">key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">observer</span>[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Wex</span>;</span><br></pre></td></tr></table></figure>

<p>由于 Proxy 可能在一些微信上不支持，所以我们要做判断，在支持 Proxy 的情况下优先使用 Proxy，否则使用 <code>defineProperty</code></p>
<p>接下来在 <code>miniprogram</code> 下创建 <code>store</code> 目录，并在该目录下创建 <code>index.ts</code> 文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Wex</span> <span class="keyword">from</span> <span class="string">&quot;../utils/wex&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">useInfo</span>: <span class="title class_">UserInfo</span> = &#123;</span><br><span class="line">  <span class="attr">nickName</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">avatarUrl</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">openid</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> useInfoStore = <span class="keyword">new</span> <span class="title class_">Wex</span>&lt;<span class="title class_">UserInfo</span>&gt;(useInfo);</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  useInfoStore</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们以修改用户头像为例子，首先我们在 <code>pages</code> 目录下创建 <code>index.ts</code> 文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useInfoStore &#125; <span class="keyword">from</span> <span class="string">&quot;../../store/index&quot;</span>;</span><br><span class="line"><span class="title class_">Component</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TProperty</span>, <span class="title class_">TMethod</span>, <span class="title class_">TCustomInstanceProperty</span>, <span class="title class_">TIsPage</span>&gt;(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">nickName</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">avatarUrl</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">lifetimes</span>: &#123;</span><br><span class="line">    <span class="title function_">attached</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">nickName</span>: useInfoStore.<span class="title function_">getData</span>(<span class="string">&quot;nickName&quot;</span>),</span><br><span class="line">        <span class="attr">avatarUrl</span>: useInfoStore.<span class="title function_">getData</span>(<span class="string">&quot;avatarUrl&quot;</span>),</span><br><span class="line">      &#125;);</span><br><span class="line">      useInfoStore.<span class="title function_">addPage</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>创建一个 <code>set.ts</code> 文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pages/mine/set.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; useInfoStore &#125; <span class="keyword">from</span> <span class="string">&quot;../../store/index&quot;</span>;</span><br><span class="line"><span class="title class_">Component</span>&lt;<span class="title class_">TData</span>, <span class="title class_">TProperty</span>, <span class="title class_">TMethod</span>, <span class="title class_">TCustomInstanceProperty</span>, <span class="title class_">TIsPage</span>&gt;(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">avatarUrl</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">nickName</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">lifetimes</span>: &#123;</span><br><span class="line">    <span class="title function_">attached</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">avatarUrl</span>: useInfoStore.<span class="title function_">getData</span>(<span class="string">&quot;avatarUrl&quot;</span>),</span><br><span class="line">        <span class="attr">nickName</span>: useInfoStore.<span class="title function_">getData</span>(<span class="string">&quot;nickName&quot;</span>),</span><br><span class="line">      &#125;);</span><br><span class="line">      useInfoStore.<span class="title function_">addPage</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">confirm</span>(<span class="params"></span>) &#123;</span><br><span class="line">      useInfoStore.<span class="title function_">setData</span>(<span class="string">&quot;nickName&quot;</span>, <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">nickName</span>);</span><br><span class="line">      useInfoStore.<span class="title function_">setData</span>(<span class="string">&quot;avatarUrl&quot;</span>, <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">avatarUrl</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序组件通信</title>
    <url>/2023/02/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>子组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// components/componentA.ts</span></span><br><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">behaviors</span>: [<span class="string">&#x27;wx://component-export&#x27;</span>],</span><br><span class="line">  <span class="title function_">export</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">hello</span>:<span class="string">&quot;hello wrold&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.wxml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;tap&quot;</span>&gt;</span>切换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ComponentA</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ComponentA</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = getApp&lt;<span class="title class_">IAppOption</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="title function_">tap</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> child=<span class="variable language_">this</span>.<span class="title function_">selectComponent</span>(<span class="string">&quot;#test&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(child)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hell owrld&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序配网</title>
    <url>/2023/02/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%91/</url>
    <content><![CDATA[<p>在 <code>app.json</code> 添加配网插件</p>
<p>app.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;airkiss&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;provider&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wx610ea582556c983e&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>界面文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;c-tip&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;c-tip__img&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;c-tip__item&quot;</span>&gt;</span>确认手机已连接到家庭 WIFI 路由器网络<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;c-tip__item&quot;</span>&gt;</span>输入家庭路由密码，点击确认开始配网<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;m-input&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;m-input__item&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;WIFI&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;wifi&#125;&#125;&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;inputWIFI&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;m-input__item&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;inputPassword&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;m-input__submit btn circle-btn bg-green&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;confirm&quot;</span>&gt;</span>确认<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>样式文件</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">row-gap</span>: <span class="number">60</span>rpx;</span><br><span class="line">&#125;       </span><br><span class="line"><span class="selector-class">.c-tip</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: column nowrap;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">row-gap</span>: <span class="number">20</span>rpx;</span><br><span class="line">  <span class="attribute">counter-reset</span>: view;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-tag">__img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">360</span>rpx;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">360</span>rpx;</span><br><span class="line">    <span class="attribute">background</span>: url(<span class="string">https://newgym.cn/img/setupnet.png</span>) no-repeat center/cover;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">40</span>rpx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-tag">__item</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">24</span>rpx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-tag">__item</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-tag">__item</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>:view;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">counter</span>(view) <span class="string">&#x27;. &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> airkiss = requirePlugin(<span class="string">&#x27;airkiss&#x27;</span>);</span><br><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">wifi</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">bssid</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">is5G</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">onLoad</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">getTabBar</span> === <span class="string">&#x27;function&#x27;</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">getTabBar</span>()) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getTabBar</span>().<span class="title function_">setData</span>(&#123;</span><br><span class="line">          <span class="attr">selected</span>: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">version</span>: airkiss.<span class="property">version</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">let</span> that = <span class="variable language_">this</span></span><br><span class="line">      wx.<span class="title function_">startWifi</span>(&#123;</span><br><span class="line">        <span class="title function_">success</span>(<span class="params">res</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">errMsg</span>, <span class="string">&#x27;wifi初始化成功&#x27;</span>)</span><br><span class="line">          that.<span class="title function_">getWifiInfo</span>();</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">fail</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">          wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;请连接路由器!&#x27;</span>,</span><br><span class="line">            <span class="attr">duration</span>: <span class="number">2000</span>,</span><br><span class="line">            <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">getWifiInfo</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">onUnload</span>(<span class="params"></span>)&#123;</span><br><span class="line">      airkiss.<span class="title function_">stopAirkiss</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">getWifiInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> that = <span class="variable language_">this</span></span><br><span class="line">      wx.<span class="title function_">getConnectedWifi</span>(&#123;</span><br><span class="line">        <span class="title function_">success</span>(<span class="params">res</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getConnectedWifi ok:&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(res))</span><br><span class="line">          <span class="keyword">if</span> (<span class="string">&#x27;getConnectedWifi:ok&#x27;</span> === res.<span class="property">errMsg</span>) &#123;</span><br><span class="line">            that.<span class="title function_">setData</span>(&#123;</span><br><span class="line">              <span class="attr">wifi</span>: res.<span class="property">wifi</span>.<span class="property">SSID</span>,</span><br><span class="line">              <span class="attr">bssid</span>:res.<span class="property">wifi</span>.<span class="property">BSSID</span>,</span><br><span class="line">              <span class="attr">is5G</span>: res.<span class="property">wifi</span>.<span class="property">frequency</span> &gt; <span class="number">4900</span></span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">              <span class="attr">title</span>: <span class="string">&#x27;请连接路由器&#x27;</span>,</span><br><span class="line">              <span class="attr">duration</span>: <span class="number">2000</span>,</span><br><span class="line">              <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">fail</span>(<span class="params">res</span>) &#123;</span><br><span class="line">          wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;请连接路由器&#x27;</span>,</span><br><span class="line">            <span class="attr">duration</span>: <span class="number">2000</span>,</span><br><span class="line">            <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">inputWIFI</span>(<span class="params">evt: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;</span><br><span class="line">        value</span><br><span class="line">      &#125; = evt.<span class="property">detail</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">wifi</span>: value,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">inputPassword</span>(<span class="params">evt: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;</span><br><span class="line">        value</span><br><span class="line">      &#125; = evt.<span class="property">detail</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">password</span>: value,</span><br><span class="line">        <span class="attr">showClearBtn</span>: !!value.<span class="property">length</span>,</span><br><span class="line">        <span class="attr">isWaring</span>: <span class="literal">false</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">confirm</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> that=<span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;wifi:&quot;</span>, <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">wifi</span>, <span class="string">&quot;,password:&quot;</span>, <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">password</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">wifi</span>.<span class="property">length</span> &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;请连接路由器&#x27;</span>,</span><br><span class="line">          <span class="attr">duration</span>: <span class="number">2000</span>,</span><br><span class="line">          <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">password</span>.<span class="property">length</span> &lt; <span class="number">8</span>) &#123;</span><br><span class="line">        wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;请输出不少于8位的密码&#x27;</span>,</span><br><span class="line">          <span class="attr">duration</span>: <span class="number">2000</span>,</span><br><span class="line">          <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">is5G</span>) &#123;</span><br><span class="line">        wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;请链接至2.4G频段的路由器&#x27;</span>,</span><br><span class="line">          <span class="attr">duration</span>: <span class="number">2000</span>,</span><br><span class="line">          <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      wx.<span class="title function_">showLoading</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;配网中&#x27;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">//这里最好加微信小程序判断账号密码是否为空，以及其长度和是否为5G频段</span></span><br><span class="line">      airkiss.<span class="title function_">startAirkiss</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">wifi</span>, <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">password</span>, <span class="keyword">function</span> (<span class="params">res: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">        wx.<span class="title function_">hideLoading</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        <span class="keyword">switch</span> (res.<span class="property">code</span>) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">              <span class="attr">title</span>: <span class="string">&#x27;初始化失败&#x27;</span>,</span><br><span class="line">              <span class="attr">content</span>: res.<span class="property">result</span>,</span><br><span class="line">              <span class="attr">showCancel</span>: <span class="literal">false</span>,</span><br><span class="line">              <span class="attr">confirmText</span>: <span class="string">&#x27;收到&#x27;</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">              <span class="attr">title</span>: <span class="string">&#x27;配网成功&#x27;</span>,</span><br><span class="line">              <span class="attr">content</span>: <span class="string">&#x27;设备IP：&#x27;</span> + res.<span class="property">ip</span> + <span class="string">&#x27;\r\n 设备Mac：&#x27;</span> + that.<span class="property">data</span>.<span class="property">ssid</span>,</span><br><span class="line">              <span class="attr">showCancel</span>: <span class="literal">false</span>,</span><br><span class="line">              <span class="attr">confirmText</span>: <span class="string">&#x27;好的&#x27;</span>,</span><br><span class="line">              <span class="attr">success</span>:<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="property">confirm</span>)&#123;</span><br><span class="line">                  wx.<span class="title function_">navigateBack</span>(&#123;&#125;)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">              <span class="attr">title</span>: <span class="string">&#x27;配网失败&#x27;</span>,</span><br><span class="line">              <span class="attr">content</span>: <span class="string">&#x27;请检查密码是否正确&#x27;</span>,</span><br><span class="line">              <span class="attr">showCancel</span>: <span class="literal">false</span>,</span><br><span class="line">              <span class="attr">confirmText</span>: <span class="string">&#x27;收到&#x27;</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2023/02/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">fn</span>(arr[j], arr[j + <span class="number">1</span>])) &#123;</span><br><span class="line">        arr[j] = arr[i] + arr[j];</span><br><span class="line">        arr[i] = arr[j] - arr[i];</span><br><span class="line">        arr[j] = arr[j] - arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">        arr[j] = arr[i] + arr[j];</span><br><span class="line">        arr[i] = arr[j] - arr[i];</span><br><span class="line">        arr[j] = arr[j] - arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">        arr[i] = arr[i] + arr[j];</span><br><span class="line">        arr[j] = arr[i] - arr[j];</span><br><span class="line">        arr[i] = arr[i] - arr[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组和链表</title>
    <url>/2023/03/27/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>数组和链表都是数据结构中常用的数据类型，但是它们在实现和使用上有很大的区别。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种线性数据结构，它在内存中是一段连续的空间。数组的元素可以是任何数据类型，但是它们必须是相同的数据类型。数组中元素的位置是通过它们的下标来确定的，下标从0开始。</p>
<p>数组的优点是可以快速访问元素，因为它们在内存中是连续存储的。但是数组的缺点是它们在插入和删除元素时效率较低，因为需要移动其他元素以空出空间。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种非线性数据结构，它由一系列节点组成。每个节点包含一个数据元素和一个指向下一个节点的指针。链表中的节点可以是任何数据类型。</p>
<p>链表的优点是它们在插入和删除元素时效率较高，因为只需要修改节点之间的指针。但是链表的缺点是访问元素时效率较低，因为需要从头节点开始遍历链表。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>总的来说，数组适合用于快速访问元素，而链表适合用于频繁插入和删除元素。在实际应用中，需要根据具体情况选择不同的数据结构</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>文件描述符</title>
    <url>/2023/03/25/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<p>文件描述符（File Descriptor）是一个整数，用于标识打开的文件、套接字等 I/O 资源，是操作系统管理 I/O 资源的一种方式。在 Linux、Unix 等操作系统中，所有的I/O操作都是通过文件描述符进行的。</p>
<p>文件描述符是一个非负整数，通常使用int类型进行表示，它是一种抽象的概念，用于表示打开的文件、套接字等 I/O 资源。在Linux系统中，每个进程都有一个独立的文件描述符表，用于管理进程打开的文件和其他 I/O 资源。</p>
<p>文件描述符的值在进程中是唯一的，当打开一个文件或套接字时，操作系统会为其分配一个文件描述符，并返回给应用程序。在使用文件描述符进行 I/O 操作时，需要使用系统调用，例如read、write、close 等。</p>
<p>文件描述符的取值范围通常是 0 到 1023，其中 0、1、2 已经被系统占用，分别表示标准输入、标准输出和标准错误。因此，应用程序可以使用的文件描述符范围是 3 到 1023。</p>
<p>需要注意的是，文件描述符是一种非常低级的I/O操作方式，通常应该使用更加高级的 I/O 操作方式，例如文件流、套接字库等。在使用文件描述符时，需要注意文件描述符的取值范围、合法性和正确的使用方式，避免对系统造成安全风险和性能问题。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>断点类型</title>
    <url>/2023/03/30/%E6%96%AD%E7%82%B9%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>行断点（Line breakpoint）：在代码的某一行设置断点，程序将在此处停止执行。</li>
<li>条件断点（Conditional breakpoint）：在某个条件下触发断点，只有满足条件时程序才会停止执行。</li>
<li>计数器断点（Hit count breakpoint）：在某个代码块或循环中执行一定次数后触发断点。</li>
<li>异常断点（Exception breakpoint）：在程序抛出异常时触发断点。</li>
<li>时间断点（Time breakpoint）：在程序执行到一定时间点时触发断点。</li>
<li>触发器断点（Trigger breakpoint）：在程序执行特定的操作（如读取文件、调用函数等）时触发断点。</li>
<li>内存断点（Memory breakpoint）：在程序访问特定内存地址时触发断点。</li>
<li>日志断点（Log breakpoint）：在程序输出特定日志信息时触发断点。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最大值</title>
    <url>/2023/02/08/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的最大值 。</p>
<p>示例 1：</p>
<p>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置 最大值</p>
<p>[1 3 -1] -3 5 3 6 7 3<br>1 [3 -1 -3] 5 3 6 7 3<br>1 3 [-1 -3 5] 3 6 7 5<br>1 3 -1 [-3 5 3] 6 7 5<br>1 3 -1 -3 [5 3 6] 7 6<br>1 3 -1 -3 5 [3 6 7] 7<br>示例 2：</p>
<p>输入：nums = [1], k = 1<br>输出：[1]</p>
<blockquote>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/sliding-window-maximum">https://leetcode.cn/problems/sliding-window-maximum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">res</span>: <span class="built_in">number</span>[] = [],</span><br><span class="line">    l = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= l - k; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; i + k; j++) &#123;</span><br><span class="line">      max = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[j], max);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">push</span>(max);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先队列解法"><a href="#优先队列解法" class="headerlink" title="优先队列解法"></a>优先队列解法</h2><p>利用搜索插入算法每次都把最大值和下标插入队首，判断队首的下标是否超出了当前窗口，则就弹出，否则就不弹出</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">nums: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">stack</span>: <span class="title class_">Array</span>&lt;&#123; <span class="attr">key</span>: <span class="built_in">number</span>; <span class="attr">value</span>: <span class="built_in">number</span> &#125;&gt; = [],</span><br><span class="line">    l = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">res</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">searchInsert</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">      right = stack.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">let</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (stack[mid].<span class="property">value</span> &lt;= target) &#123;</span><br><span class="line">        right = mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="title function_">searchInsert</span>(nums[i]);</span><br><span class="line">    stack.<span class="title function_">splice</span>(j, <span class="number">0</span>, &#123; <span class="attr">key</span>: i, <span class="attr">value</span>: nums[i] &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="title function_">push</span>(stack[<span class="number">0</span>].<span class="property">value</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = k; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="title function_">searchInsert</span>(nums[i]);</span><br><span class="line">    stack.<span class="title function_">splice</span>(j, <span class="number">0</span>, &#123; <span class="attr">key</span>: i, <span class="attr">value</span>: nums[i] &#125;);</span><br><span class="line">    <span class="keyword">while</span> (stack[<span class="number">0</span>].<span class="property">key</span> &lt;= i - k) &#123;</span><br><span class="line">      stack.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">push</span>(stack[<span class="number">0</span>].<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 JavaScript 的优先队列解法会导致超时（暴力解法没超时…），所以附上一个 C++ 解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; queue;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            queue.<span class="built_in">push</span>(&#123;nums[i],i&#125;);</span><br><span class="line">            <span class="keyword">if</span>(queue.<span class="built_in">size</span>()&gt;=k)&#123;</span><br><span class="line">                <span class="keyword">while</span>(queue.<span class="built_in">top</span>().second &lt;= i - k)&#123;</span><br><span class="line">                    queue.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                res.<span class="built_in">push_back</span>(queue.<span class="built_in">top</span>().first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2023/03/25/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>红黑树（Red-Black Tree）是一种自平衡二叉查找树，通过约束任何一条从根到叶子的路径上各个节点的颜色，使得从根到叶子的所有路径都具有相同数目的黑色节点。红黑树的基本思想是通过对节点进行颜色标记，使得树在动态插入、删除节点时保持平衡，从而保证了操作的时间复杂度。</p>
<p>红黑树的特征：</p>
<ul>
<li>每个节点要么是红色，要么是黑色。</li>
<li>根节点是黑色的。</li>
<li>每个叶子节点（NIL 节点，空节点）是黑色的。</li>
<li>如果一个节点是红色的，则它的两个子节点都是黑色的。</li>
<li>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点。</li>
<li>红黑树的插入和删除操作，都需要进行颜色的调整和旋转操作，以保持平衡。红黑树的查找、插入、删除操作的时间复杂度均为 O(log n)，是一种高效的数据结构。</li>
</ul>
<p>红黑树在实际应用中广泛使用，例如 C++ STL 中的 set、map、multiset 和 multimap 都是基于红黑树实现的。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>线程通信方式</title>
    <url>/2023/03/25/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>虚拟内存</title>
    <url>/2023/03/31/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>虚拟内存是一种计算机内存管理技术，它允许操作系统将物理内存和硬盘空间组合使用，以提高系统性能和可用性。虚拟内存使得应用程序能够访问比物理内存更多的内存，因为它允许操作系统将一部分应用程序数据存储在硬盘上，而不是全部存储在内存中。</p>
<p>当应用程序需要更多内存时，操作系统会将一部分当前未使用的内存页面（即数据块）移动到硬盘上，以释放物理内存。当应用程序再次需要访问已经移动到硬盘上的页面时，操作系统会将它们再次加载到物理内存中。</p>
<p>虚拟内存的优点是可以提高系统的可用内存和性能，因为它允许应用程序使用比物理内存更多的内存。然而，虚拟内存也会导致性能下降，因为它需要操作系统和硬盘之间频繁地交换数据。因此，为了最大化系统性能，需要合理设置虚拟内存大小，并定期清理硬盘上的页面文件。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络常见加密算法</title>
    <url>/2023/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>计算机网络中常见的加密算法包括：</p>
<ul>
<li>对称加密算法：对称加密算法采用同一个密钥进行加密和解密，常见的对称加密算法包括 DES、3DES、AES、RC4 等。</li>
<li>非对称加密算法：非对称加密算法采用一对公私钥进行加密和解密，常见的非对称加密算法包括 RSA、DSA、ECC 等。</li>
<li>哈希算法：哈希算法将任意长度的数据映射成固定长度的哈希值，常见的哈希算法包括 MD5、SHA-1、SHA-2 等。</li>
<li>数字签名算法：数字签名算法用于验证数据的完整性和真实性，常见的数字签名算法包括 RSA、DSA、ECDSA 等。</li>
<li>消息认证码算法：消息认证码算法用于验证数据的完整性和真实性，常见的消息认证码算法包括 HMAC、CMAC 等。</li>
</ul>
<p>这些加密算法在计算机网络中被广泛应用，以保障数据的安全性和可靠性。其中，对称加密算法通常用于保护数据的机密性，非对称加密算法和数字签名算法用于保护数据的完整性和真实性，哈希算法和消息认证码算法用于验证数据的完整性和真实性。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤驱动</title>
    <url>/2023/03/30/%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="WFP"><a href="#WFP" class="headerlink" title="WFP"></a>WFP</h2><p>WFP（Windows Filtering Platform）是一种网络过滤技术，它在 Windows 操作系统中实现了一种灵活的网络数据包处理机制，可以对网络数据包进行过滤、修改、重定向等操作。WFP技术可以应用于防火墙、入侵检测、网络监控等领域。</p>
<p>WFP 技术的实现需要通过开发 Windows 过滤驱动程序来实现。过滤驱动程序可以插入到 WFP 处理链中，拦截网络数据包并进行处理。过滤驱动程序可以实现各种函数来处理网络数据包，例如过滤、转发、修改、阻止、重定向等操作。</p>
<p>WFP 技术的主要优势是其灵活性和可扩展性。WFP 提供了一套灵活的 API，可以让开发人员轻松地控制网络数据包的传输和处理。开发者可以通过 WFP API 来实现自定义的网络过滤功能，例如实现特定协议的过滤、实现入侵检测、实现网络流量分析等功能。</p>
<p>WFP 技术还提供了一套安全模型，可以控制过滤驱动程序的权限和访问级别，以确保系统安全和稳定性。WFP技术也可以与其它系统安全技术相结合，例如 Windows 防火墙、IPSec 等，实现更加全面的网络安全保护。</p>
<h2 id="NDIS"><a href="#NDIS" class="headerlink" title="NDIS"></a>NDIS</h2><p>NDIS（Network Driver Interface Specification）是一种网络驱动程序接口规范，用于在 Windows 操作系统中实现网络设备驱动程序。NDIS 规范定义了网络驱动程序与操作系统之间的接口规范，使得不同网络设备的驱动程序可以使用相同的接口与操作系统交互。</p>
<p>NDIS 规范包括两部分：NDIS 驱动程序接口和NDIS驱动程序模型。NDIS 驱动程序接口定义了网络驱动程序与操作系统之间的通信接口，例如网络数据包的发送和接收、设备状态的查询和设置等。NDIS 驱动程序模型定义了网络驱动程序的架构和模型，包括 Miniport 驱动程序、Protocol 驱动程序、Intermediate 驱动程序等。</p>
<p>NDIS 驱动程序接口支持多种网络接口类型，例如以太网、无线局域网、蓝牙、调制解调器等。NDIS 驱动程序还支持虚拟网络设备，例如虚拟网络适配器、虚拟局域网等，使得开发人员可以实现各种网络应用和功能。</p>
<p>NDIS 规范的主要优势是其通用性和兼容性。NDIS 规范使得开发人员可以使用相同的接口和模型来开发不同类型的网络驱动程序，从而大大简化了网络驱动程序的开发和维护。同时，NDIS 规范与 Windows 操作系统紧密集成，可以提供更好的性能和稳定性。</p>
<p>总之，NDIS 是一种网络驱动程序接口规范，用于在 Windows 操作系统中实现网络设备驱动程序。NDIS 规范定义了网络驱动程序与操作系统之间的接口规范和驱动程序模型，具有通用性和兼容性等优势，可以大大简化网络驱动程序的开发</p>
<h2 id="TDI"><a href="#TDI" class="headerlink" title="TDI"></a>TDI</h2><p>TDI（Transport Driver Interface）是一种网络传输协议驱动程序接口，用于在Windows操作系统中实现网络协议栈的驱动程序。TDI 技术提供了一种标准的接口规范，使得网络协议栈的开发人员可以使用相同的接口与操作系统交互，从而简化了网络协议栈的开发和维护。</p>
<p>TDI 技术定义了网络协议栈驱动程序与操作系统之间的通信接口，包括网络数据包的发送和接收、连接建立和断开、错误处理和事件通知等。通过 TDI 接口，开发人员可以实现自定义的网络协议栈驱动程序，并与 Windows 操作系统集成，实现网络通信和数据传输等功能。</p>
<p>TDI技术的主要优势是其灵活性和可扩展性。TDI 接口规范提供了一套标准的接口，使得开发人员可以使用不同的网络协议栈实现不同的网络应用和功能。TDI 技术还支持多种网络传输协议，例如 TCP/IP、NetBIOS、IPX/SPX 等，可以应用于不同的网络环境和应用场景。</p>
<p>除了 TDI 之外，Windows 操作系统还提供了一些其他的网络协议栈驱动程序接口，例如 NDIS、WFP 等。这些接口提供了不同的功能和应用场景，使得开发人员可以选择最适合自己的接口来实现网络应用和功能。</p>
<p>总之，TDI 是一种网络传输协议驱动程序接口，用于在 Windows 操作系统中实现网络协议栈的驱动程序。TDI 技术通过提供标准的接口规范，简化了网络协议栈的开发和维护，具有灵活性和可扩展性等优势。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程通信方式</title>
    <url>/2023/03/25/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>管道通信是一种基于文件描述符的通信方式，可以用于实现父进程和子进程之间的通信。管道通信只能实现单向通信，需要配合 fork() 函数使用，通常用于父子进程之间的通信。</p>
<h3 id="命名管道通信"><a href="#命名管道通信" class="headerlink" title="命名管道通信"></a>命名管道通信</h3><p>命名管道通信也是一种基于文件描述符的通信方式，可以用于实现不同进程之间的通信。命名管道通信可以实现双向通信，需要先创建一个命名管道文件，并在不同进程中打开这个文件进行通信。</p>
<h3 id="共享内存通信"><a href="#共享内存通信" class="headerlink" title="共享内存通信"></a>共享内存通信</h3><p>共享内存通信是一种高效的进程间通信方式，不同进程之间可以共享同一个内存区域，直接读写内存区域中的数据。共享内存通信需要使用系统调用或第三方库来创建共享内存对象，并使用 mmap() 函数将共享内存映射到进程地址空间中。</p>
<h3 id="信号量通信"><a href="#信号量通信" class="headerlink" title="信号量通信"></a>信号量通信</h3><p>信号量通信是一种基于计数器的进程间通信方式，可以用于实现进程之间的同步和互斥。信号量通信需要使用系统调用或第三方库来创建信号量对象，并使用 sem_wait() 和 sem_post() 函数来实现进程之间的同步和互斥。</p>
<h3 id="消息队列通信"><a href="#消息队列通信" class="headerlink" title="消息队列通信"></a>消息队列通信</h3><p>消息队列通信是一种基于队列的进程间通信方式，可以用于实现进程之间的异步通信。消息队列通信需要使用系统调用或第三方库来创建消息队列对象，并使用 msgrcv() 和 msgsnd() 函数来实现不同进程之间的消息传递。</p>
<h3 id="套接字通信"><a href="#套接字通信" class="headerlink" title="套接字通信"></a>套接字通信</h3><p>套接字通信是一种基于网络协议的进程间通信方式，可以用于实现不同主机之间的通信。套接字通信需要使用套接字接口函数，如 socket()、bind()、listen()、accept()、connect()、send() 和 recv() 等，来创建和操作套接字对象。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度算法</title>
    <url>/2023/03/31/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>进程调度算法是操作系统中用于决定哪个进程应该被执行的算法。不同的调度算法具有不同的优缺点，可以根据实际需要选择合适的算法。</p>
<p>常见的进程调度算法包括：</p>
<ul>
<li>先来先服务调度算法（FCFS）：按照进程到达的顺序进行调度，即先到先服务。</li>
<li>短作业优先调度算法（SJF）：按照进程执行时间的长短进行调度，即短作业优先。</li>
<li>优先级调度算法（Priority Scheduling）：按照进程优先级进行调度，即优先级越高的进程优先执行。 </li>
<li>时间片轮转调度算法（Round Robin）：每个进程被分配一个时间片，在该时间片内执行，时间片结束后，进程被挂起并放入就绪队列，等待下一次调度。</li>
<li>多级反馈队列调度算法（Multilevel Feedback Queue）：将进程划分为多个队列，每个队列具有不同的优先级和时间片大小，进程根据所需时间和优先级动态调整队列。</li>
<li>最高响应比优先调度算法（Highest Response Ratio Next，HRRN）：按照进程的响应比（等待时间加服务时间除以服务时间）进行调度，响应比越高的进程优先执行。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析工具</title>
    <url>/2023/03/31/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>OllyDbg - OllyDbg 是一个 32 位汇编器级别的分析调试器。</li>
<li>IDA - 同类最佳的二进制代码分析工具，是世界级软件分析师、逆向工程师、恶意软件分析师和网络安全专业人员工具箱中不可或缺的项目。</li>
<li>Immunity Debugger - Immunity Debugger 是一种强大的新方法来编写漏洞利用、分析恶意软件和逆向工程…</li>
<li>Ghidra - 软件逆向工程 (SRE) 框架</li>
<li>SoftICE - SoftICE 是一款适用于 Windows 和 DOS 的调试软件，可以分析您的所有程序并进行修复。</li>
<li>Nirsoft Simple Program Debugger - Nirsoft Simple Program Debugger 是一款调试软件，可在连接到正在运行的程序或在调试模式下启动新程序后，分析并显示计算机上的所有主要调试事件。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>通用寄存器</title>
    <url>/2023/03/30/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>通用寄存器（General Purpose Register）是计算机中的一种寄存器，它可以存储不特定的数据，用于执行各种计算和操作。通用寄存器通常是 CPU 硬件中的一部分，由于其使用频繁，所以通常被集成在 CPU 内部，可以快速访问。</p>
<p>在 x86 架构的 CPU 中，通用寄存器主要有 8 个，分别为 AX、BX、CX、DX、SI、DI、BP、SP，其中：</p>
<ul>
<li>AX 寄存器是累加器（Accumulator）寄存器，用于存储运算结果和数据传输。</li>
<li>BX 寄存器是基址（Base）寄存器，用于存储数据的基地址。</li>
<li>CX 寄存器是计数（Counter）寄存器，用于实现循环操作。</li>
<li>DX 寄存器是数据（Data）寄存器，用于存储数据，也可用于存储I/O端口地址。</li>
<li>SI 寄存器是源变址（Source Index）寄存器，用于存储源操作数的地址。</li>
<li>DI 寄存器是目的变址（Destination Index）寄存器，用于存储目的操作数的地址。</li>
<li>BP 寄存器是基址指针（Base Pointer）寄存器，通常用于存储栈帧的基地址。</li>
<li>SP 寄存器是栈指针（Stack Pointer）寄存器，用于存储栈顶的指针地址。</li>
</ul>
<p>在实际的程序设计中，通用寄存器的使用非常广泛，可以用于存储变量、参数、指针等数据，也可以用于实现算术运算、逻辑运算、移位操作等。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
